// TODO: remove when the upstream kamon-monix support is merged: https://github.com/kamon-io/Kamon/pull/879
kanela.modules {
  executor-service {
    within += "monix.eval..*"
    within += "monix.execution..*"
    within += "monix.bio..*"
  }
}

kamon {
  environment {
    service = ${app.description.name}
  }
  trace {
    # Interval at which sampled finished spans will be flushed to SpanReporters.
    tick-interval = 10 seconds
    # Decides whether to include the stack trace of a Throwable as the "error.stacktrace" Span tag when a Span is marked
    # as failed.
    include-error-stacktrace = yes
    # Configures a sampler that decides which Spans should be sent to Span reporters. The possible values are:
    #   - always: report all traces.
    #   - never:  don't report any trace.
    #   - random: randomly decide using the probability defined in the random-sampler.probability setting.
    #   - adaptive: keeps dynamic samplers for each operation while trying to achieve a set throughput goal.
    #   - A FQCN of a kamon.trace.Sampler implementation to be used instead. The implementation must have a default
    #     constructor that will be used by Kamon when creating the instance.
    #
    sampler = "adaptive"
    # An adaptive sampler tries to balance a global throughput goal across all operations in the current application,
    # making the best possible effort to provide sampled traces of all operations.
    #
    adaptive-sampler {

      # The target maximum number of affirmative sample decisions to be taken by the sampler. The sampler will do a best
      # effort to balance sampling decisions across all operations to produce no more than this number of affirmative
      # decisions.
      throughput = 600

      # Groups allow to override the default balacing behavior for a particular subset of operations in this
      # application. With groups, users can guarantee that certain operations will always be sampled, never sampled, or
      # provide minimum and/or maximum sampled traces throughput goals.
      #
      # Groups have two properties: an operation name regex list which decides what operations get into the group and a
      # set of rules for that group. The available rules are:
      #
      #               sample: [always|never] Provides a definitive sampling decision for all operations in the group.
      #                       When this rule is set, the sampler will always return this decision and any other
      #                       configured rule will be ignored.
      #
      #   minimum-throughput: [number] Defines the minimum number of sampled traces expected per minute for each
      #                       operation in the group. Even though the sampler will do its best effort to provide the
      #                       minimum number of sampled traces, the actual minimum will vary depending on application
      #                       traffic and the global throughput goal.
      #
      #   maximum-throughput: [number] Defines the maximum number of sampled traces expected per minute for each
      #                       operation in the group, regardless of whether there is room left before meeting the global
      #                       throughput goal.
      #
      # For example, if you wanted to ensure that health check operations are never sampled you could include
      #
      #   health-checks {
      #     operations = ["GET \/status"]
      #
      #     rules {
      #       sample = never
      #     }
      #   }
      #
      #
      groups {
      }
    }
  }
}