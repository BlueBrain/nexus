"use strict";

var _telemetry = require("./telemetry");

var _createFlush = require("./create-flush");

const instance = new _telemetry.AnalyticsTracker();
const flush = (0, _createFlush.createFlush)(instance.isTrackingEnabled());
process.on(`exit`, flush); // For long running commands we want to occasionally flush the data
//
// The data is also sent on exit.

const intervalDuration = process.env.TELEMETRY_BUFFER_INTERVAL;
const interval = intervalDuration && Number.isFinite(+intervalDuration) ? Math.max(Number(intervalDuration), 1000) : 10 * 60 * 1000; // 10 min

function tick() {
  flush().catch(console.error).then(() => setTimeout(tick, interval));
}

module.exports = {
  trackFeatureIsUsed: name => instance.trackFeatureIsUsed(name),
  trackCli: (input, tags, opts) => instance.captureEvent(input, tags, opts),
  trackError: (input, tags) => instance.captureError(input, tags),
  trackBuildError: (input, tags) => instance.captureBuildError(input, tags),
  setDefaultTags: tags => instance.decorateAll(tags),
  decorateEvent: (event, tags) => instance.decorateNextEvent(event, tags),
  setTelemetryEnabled: enabled => instance.setTelemetryEnabled(enabled),
  startBackgroundUpdate: () => {
    setTimeout(tick, interval);
  },
  isTrackingEnabled: () => instance.isTrackingEnabled(),
  aggregateStats: data => instance.aggregateStats(data),
  addSiteMeasurement: (event, obj) => instance.addSiteMeasurement(event, obj),
  expressMiddleware: function (source) {
    return function (_req, _res, next) {
      try {
        instance.trackActivity(`${source}_ACTIVE`);
      } catch (e) {// ignore
      }

      next();
    };
  }
};