function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

import { find, filter } from 'lodash'; // eslint-disable-line

import { SchemaComposer } from '../..';
describe('github issue #186: error when merging existing schema', () => {
  it('test graphql query',
  /*#__PURE__*/
  _asyncToGenerator(function* () {
    const composer = new SchemaComposer();
    composer.Query.addFields({
      test: {
        type: 'String!',
        resolve: () => 'test field value!'
      },
      test3: {
        type: 'Int',
        args: {
          a: `input Filter { min: Int }`
        }
      }
    });
    const composer2 = new SchemaComposer(composer.buildSchema());
    composer2.Query.addFields({
      test2: {
        type: 'String!',
        resolve: () => 'test2 field value!'
      }
    });
    expect(() => {
      composer2.buildSchema();
    }).not.toThrowError('Query.test should provide "deprecationReason" instead of "isDeprecated".');
  }));
});