"use strict";

var _graphql = require("../graphql");

var _ = require("..");

var _InterfaceTypeComposer = require("../InterfaceTypeComposer");

var _InputTypeComposer = require("../InputTypeComposer");

var _ObjectTypeComposer = require("../ObjectTypeComposer");

var _ScalarTypeComposer = require("../ScalarTypeComposer");

var _EnumTypeComposer = require("../EnumTypeComposer");

var _UnionTypeComposer = require("../UnionTypeComposer");

var _graphqlVersion = require("../utils/graphqlVersion");

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

beforeEach(() => {
  _.schemaComposer.clear();
});
describe('InterfaceTypeComposer', () => {
  let objectType;
  let iftc;
  beforeEach(() => {
    objectType = new _graphql.GraphQLInterfaceType({
      name: 'Readable',
      fields: {
        field1: {
          type: _graphql.GraphQLString
        },
        field2: {
          type: _graphql.GraphQLString
        }
      }
    });
    iftc = new _InterfaceTypeComposer.InterfaceTypeComposer(objectType, _.schemaComposer);
  });
  describe('fields manipulation', () => {
    it('getFields()', () => {
      const fieldNames = Object.keys(iftc.getFields());
      expect(fieldNames).toEqual(expect.arrayContaining(['field1', 'field2']));

      const iftc2 = _.schemaComposer.createInterfaceTC('SomeType');

      expect(iftc2.getFields()).toEqual({});
    });
    describe('getField()', () => {
      it('should return field config', () => {
        expect(iftc.getFieldType('field1')).toBe(_graphql.GraphQLString);
      });
      it('should throw error if field does not exist', () => {
        expect(() => iftc.getField('unexisted')).toThrowError(/Cannot get field.*does not exist/);
      });
    });
    describe('setFields()', () => {
      it('should add field with standart config', () => {
        iftc.setFields({
          field3: {
            type: _graphql.GraphQLString
          }
        });
        const fields = objectType.getFields();
        expect(Object.keys(fields)).toContain('field3');
        expect(fields.field3.type).toBe(_graphql.GraphQLString);
      });
      it('should add fields with converting types from string to object', () => {
        iftc.setFields({
          field3: {
            type: 'String'
          },
          field4: {
            type: '[Int]'
          },
          field5: 'Boolean!'
        });
        expect(iftc.getFieldType('field3')).toBe(_graphql.GraphQLString);
        expect(iftc.getFieldType('field4')).toBeInstanceOf(_graphql.GraphQLList);
        expect(iftc.getFieldType('field4').ofType).toBe(_graphql.GraphQLInt);
        expect(iftc.getFieldType('field5')).toBeInstanceOf(_graphql.GraphQLNonNull);
        expect(iftc.getFieldType('field5').ofType).toBe(_graphql.GraphQLBoolean);
      });
      it('should add fields with converting args types from string to object', () => {
        iftc.setFields({
          field3: {
            type: 'String',
            args: {
              arg1: {
                type: 'String!'
              },
              arg2: '[Float]'
            }
          }
        });
        expect(iftc.getFieldArgType('field3', 'arg1')).toBeInstanceOf(_graphql.GraphQLNonNull);
        expect(iftc.getFieldArgType('field3', 'arg1').ofType).toBe(_graphql.GraphQLString);
        expect(iftc.getFieldArgType('field3', 'arg2')).toBeInstanceOf(_graphql.GraphQLList);
        expect(iftc.getFieldArgType('field3', 'arg2').ofType).toBe(_graphql.GraphQLFloat);
      });
      it('should add projection via `setField` and `addFields`', () => {
        iftc.setFields({
          field3: {
            type: _graphql.GraphQLString,
            projection: {
              field1: true,
              field2: true
            }
          },
          field4: {
            type: _graphql.GraphQLString
          },
          field5: {
            type: _graphql.GraphQLString,
            projection: {
              field4: true
            }
          }
        });
      });
      it('accept types as function', () => {
        const typeAsFn = () => _graphql.GraphQLString;

        iftc.setFields({
          input3: {
            type: typeAsFn
          }
        });
        expect(iftc.getField('input3').type).toBe(typeAsFn);
        expect(iftc.getFieldType('input3')).toBe(_graphql.GraphQLString); // show provide unwrapped/unhoisted type for graphql

        if (_graphqlVersion.graphqlVersion >= 14) {
          expect(iftc.getType()._fields().input3.type).toBe(_graphql.GraphQLString);
        } else {
          expect(iftc.getType()._typeConfig.fields().input3.type).toBe(_graphql.GraphQLString);
        }
      });
      it('accept fieldConfig as function', () => {
        iftc.setFields({
          input4: () => ({
            type: 'String'
          })
        }); // show provide unwrapped/unhoisted type for graphql

        if (_graphqlVersion.graphqlVersion >= 14) {
          expect(iftc.getType()._fields().input4.type).toBe(_graphql.GraphQLString);
        } else {
          expect(iftc.getType()._typeConfig.fields().input4.type).toBe(_graphql.GraphQLString);
        }
      });
    });
    it('addFields()', () => {
      iftc.addFields({
        field3: {
          type: _graphql.GraphQLString
        },
        field4: {
          type: '[Int]'
        },
        field5: 'Boolean!'
      });
      expect(iftc.getFieldType('field3')).toBe(_graphql.GraphQLString);
      expect(iftc.getFieldType('field4')).toBeInstanceOf(_graphql.GraphQLList);
      expect(iftc.getFieldType('field4').ofType).toBe(_graphql.GraphQLInt);
      expect(iftc.getFieldType('field5')).toBeInstanceOf(_graphql.GraphQLNonNull);
      expect(iftc.getFieldType('field5').ofType).toBe(_graphql.GraphQLBoolean);
    });
    describe('removeField()', () => {
      it('should remove one field', () => {
        iftc.removeField('field1');
        expect(iftc.getFieldNames()).toEqual(expect.arrayContaining(['field2']));
      });
      it('should remove list of fields', () => {
        iftc.removeField(['field1', 'field2']);
        expect(iftc.getFieldNames()).toEqual(expect.arrayContaining([]));
      });
    });
    describe('removeOtherFields()', () => {
      it('should remove one field', () => {
        iftc.removeOtherFields('field1');
        expect(iftc.getFieldNames()).not.toEqual(expect.arrayContaining(['field2']));
        expect(iftc.getFieldNames()).toEqual(expect.arrayContaining(['field1']));
      });
      it('should remove list of fields', () => {
        iftc.setField('field3', 'String');
        iftc.removeOtherFields(['field1', 'field2']);
        expect(iftc.getFieldNames()).toEqual(expect.arrayContaining(['field1', 'field2']));
        expect(iftc.getFieldNames()).not.toEqual(expect.arrayContaining(['field3']));
      });
    });
    describe('reorderFields()', () => {
      it('should change fields order', () => {
        iftc.setFields({
          f1: 'Int',
          f2: 'Int',
          f3: 'Int'
        });
        expect(iftc.getFieldNames().join(',')).toBe('f1,f2,f3');
        iftc.reorderFields(['f3', 'f2', 'f1']);
        expect(iftc.getFieldNames().join(',')).toBe('f3,f2,f1');
      });
      it('should append not listed fields', () => {
        iftc.setFields({
          f1: 'Int',
          f2: 'Int',
          f3: 'Int'
        });
        expect(iftc.getFieldNames().join(',')).toBe('f1,f2,f3');
        iftc.reorderFields(['f3']);
        expect(iftc.getFieldNames().join(',')).toBe('f3,f1,f2');
      });
      it('should skip non existed fields', () => {
        iftc.setFields({
          f1: 'Int',
          f2: 'Int',
          f3: 'Int'
        });
        expect(iftc.getFieldNames().join(',')).toBe('f1,f2,f3');
        iftc.reorderFields(['f22', 'f3', 'f55', 'f1', 'f2']);
        expect(iftc.getFieldNames().join(',')).toBe('f3,f1,f2');
      });
    });
    describe('field arguments', () => {
      beforeEach(() => {
        iftc.extendField('field1', {
          args: {
            arg1: 'Int',
            arg2: 'String'
          }
        });
      });
      it('getFieldArgs()', () => {
        const args = iftc.getFieldArgs('field1');
        expect(Object.keys(args)).toEqual(['arg1', 'arg2']);
        expect(args.arg1).toBe('Int');
        expect(iftc.getFieldArgType('field1', 'arg1')).toBe(_graphql.GraphQLInt);
        expect(() => iftc.getFieldArgs('unexistedField')).toThrow();
      });
      it('hasFieldArg()', () => {
        expect(iftc.hasFieldArg('field1', 'arg1')).toBeTruthy();
        expect(iftc.hasFieldArg('field1', 'arg222')).toBeFalsy();
        expect(iftc.hasFieldArg('unexistedField', 'arg1')).toBeFalsy();
      });
      it('getFieldArg()', () => {
        expect(iftc.getFieldArg('field1', 'arg1')).toBeTruthy();
        expect(() => iftc.getFieldArg('field1', 'arg222')).toThrow(/Cannot get arg.*Argument does not exist/);
        expect(iftc.hasFieldArg('unexistedField', 'arg1')).toBeFalsy();
      });
      it('getFieldArgTC()', () => {
        iftc.setField('fieldWithArgs', {
          type: 'Int',
          args: {
            scalarArg: '[Int]',
            complexArg: `input SomeInput { a: Int, b: Int }`
          }
        });
        expect(iftc.getFieldArgTC('fieldWithArgs', 'scalarArg')).toBeInstanceOf(_ScalarTypeComposer.ScalarTypeComposer);
        const argTC = iftc.getFieldArgTC('fieldWithArgs', 'complexArg');
        expect(argTC).toBeInstanceOf(_InputTypeComposer.InputTypeComposer); // should return the same TC instance

        expect(iftc.getFieldArgITC('fieldWithArgs', 'complexArg')).toBe(argTC);
        expect(() => iftc.getFieldArgITC('fieldWithArgs', 'scalarArg')).toThrow('must be InputTypeComposer');
      });
    });
    describe('extendField()', () => {
      it('should extend existed fields', () => {
        iftc.setField('field3', {
          type: _graphql.GraphQLString,
          projection: {
            field1: true,
            field2: true
          }
        });
        iftc.extendField('field3', {
          description: 'this is field #3'
        });
        expect(iftc.getFieldConfig('field3').type).toBe(_graphql.GraphQLString);
        expect(iftc.getFieldConfig('field3').description).toBe('this is field #3');
        iftc.extendField('field3', {
          type: 'Int'
        });
        expect(iftc.getFieldType('field3')).toBe(_graphql.GraphQLInt);
      });
      it('should extend field extensions', () => {
        iftc.setField('field3', {
          type: _graphql.GraphQLString,
          extensions: {
            first: true
          }
        });
        iftc.extendField('field3', {
          description: 'this is field #3',
          extensions: {
            second: true
          }
        }); // $FlowFixMe

        expect(iftc.getFieldConfig('field3').extensions).toEqual({
          first: true,
          second: true
        });
      });
      it('should work with fieldConfig as string', () => {
        iftc.setField('field4', 'String');
        iftc.extendField('field4', {
          description: 'this is field #4'
        });
        expect(iftc.getFieldConfig('field4').type).toBe(_graphql.GraphQLString);
        expect(iftc.getFieldConfig('field4').description).toBe('this is field #4');
      });
      it('should throw error if field does not exists', () => {
        expect(() => iftc.extendField('unexisted', {
          description: '123'
        })).toThrow(/Cannot extend field.*Field does not exist/);
      });
    });
    it('isFieldNonNull()', () => {
      iftc.setField('fieldNN', 'String');
      expect(iftc.isFieldNonNull('fieldNN')).toBe(false);
      iftc.setField('fieldNN', 'String!');
      expect(iftc.isFieldNonNull('fieldNN')).toBe(true);
    });
    it('makeFieldNonNull()', () => {
      iftc.setField('fieldNN', 'String');
      expect(iftc.getFieldType('fieldNN')).toBe(_graphql.GraphQLString); // should wrap with GraphQLNonNull

      iftc.makeFieldNonNull('fieldNN');
      expect(iftc.getFieldType('fieldNN')).toBeInstanceOf(_graphql.GraphQLNonNull);
      expect(iftc.getFieldType('fieldNN').ofType).toBe(_graphql.GraphQLString); // should not wrap twice

      iftc.makeFieldNonNull('fieldNN');
      expect(iftc.getFieldType('fieldNN')).toBeInstanceOf(_graphql.GraphQLNonNull);
      expect(iftc.getFieldType('fieldNN').ofType).toBe(_graphql.GraphQLString);
    });
    it('makeFieldNullable()', () => {
      iftc.setField('fieldNN', 'String!');
      expect(iftc.getFieldType('fieldNN')).toBeInstanceOf(_graphql.GraphQLNonNull);
      expect(iftc.getFieldType('fieldNN').ofType).toBe(_graphql.GraphQLString); // should unwrap with GraphQLNonNull

      iftc.makeFieldNullable('fieldNN');
      expect(iftc.getFieldType('fieldNN')).toBe(_graphql.GraphQLString); // should work for already unwrapped type

      iftc.makeFieldNullable('fieldNN');
      expect(iftc.getFieldType('fieldNN')).toBe(_graphql.GraphQLString);
    });
  });
  describe('create() [static method]', () => {
    it('should create Interface by typeName as a string', () => {
      const myIFTC = _.schemaComposer.createInterfaceTC('TypeStub');

      expect(myIFTC).toBeInstanceOf(_InterfaceTypeComposer.InterfaceTypeComposer);
      expect(myIFTC.getType()).toBeInstanceOf(_graphql.GraphQLInterfaceType);
      expect(myIFTC.getFields()).toEqual({});
    });
    it('should create Interface by type template string', () => {
      const myIFTC = _.schemaComposer.createInterfaceTC(`
        interface TestTypeTpl {
          f1: String
          # Description for some required Int field
          f2: Int!
        }
      `);

      expect(myIFTC).toBeInstanceOf(_InterfaceTypeComposer.InterfaceTypeComposer);
      expect(myIFTC.getTypeName()).toBe('TestTypeTpl');
      expect(myIFTC.getFieldType('f1')).toBe(_graphql.GraphQLString);
      expect(myIFTC.getFieldType('f2')).toBeInstanceOf(_graphql.GraphQLNonNull);
      expect(myIFTC.getFieldType('f2').ofType).toBe(_graphql.GraphQLInt);
    });
    it('should create TC by GraphQLInterfaceTypeConfig', () => {
      const myIFTC = _.schemaComposer.createInterfaceTC({
        name: 'TestType',
        fields: {
          f1: {
            type: 'String'
          },
          f2: 'Int!'
        }
      });

      expect(myIFTC).toBeInstanceOf(_InterfaceTypeComposer.InterfaceTypeComposer);
      expect(myIFTC.getFieldType('f1')).toBe(_graphql.GraphQLString);
      expect(myIFTC.getFieldType('f2')).toBeInstanceOf(_graphql.GraphQLNonNull);
      expect(myIFTC.getFieldType('f2').ofType).toBe(_graphql.GraphQLInt);
    });
    it('should create TC by ComposeInterfaceTypeConfig with unexisted types', () => {
      const myIFTC = _.schemaComposer.createInterfaceTC({
        name: 'TestType',
        fields: {
          f1: {
            type: 'Type1'
          },
          f2: 'Type2!'
        }
      });

      expect(myIFTC).toBeInstanceOf(_InterfaceTypeComposer.InterfaceTypeComposer);
      expect(myIFTC.getField('f1')).toEqual({
        type: 'Type1'
      });
      expect(myIFTC.getField('f2')).toEqual({
        type: 'Type2!'
      });
    });
    it('should create TC by GraphQLInterfaceTypeConfig with fields as Thunk', () => {
      const myIFTC = _.schemaComposer.createInterfaceTC({
        name: 'TestType',
        fields: () => ({
          f1: {
            type: 'String'
          },
          f2: 'Int!'
        })
      });

      expect(myIFTC).toBeInstanceOf(_InterfaceTypeComposer.InterfaceTypeComposer);
      expect(myIFTC.getFieldType('f1')).toBe(_graphql.GraphQLString);
      expect(myIFTC.getFieldType('f2')).toBeInstanceOf(_graphql.GraphQLNonNull);
      expect(myIFTC.getFieldType('f2').ofType).toBe(_graphql.GraphQLInt);
    });
    it('should create TC by GraphQLInterfaceType', () => {
      const objType = new _graphql.GraphQLInterfaceType({
        name: 'TestTypeObj',
        fields: {
          f1: {
            type: _graphql.GraphQLString
          }
        }
      });

      const myIFTC = _.schemaComposer.createInterfaceTC(objType);

      expect(myIFTC).toBeInstanceOf(_InterfaceTypeComposer.InterfaceTypeComposer);
      expect(myIFTC.getType()).toBe(objType);
      expect(myIFTC.getFieldType('f1')).toBe(_graphql.GraphQLString);
    });
    it('should create type and store it in schemaComposer', () => {
      const SomeUserTC = _.schemaComposer.createInterfaceTC('SomeUser');

      expect(_.schemaComposer.getIFTC('SomeUser')).toBe(SomeUserTC);
    });
    it('createTemp() should not store type in schemaComposer', () => {
      _InterfaceTypeComposer.InterfaceTypeComposer.createTemp('SomeUser');

      expect(_.schemaComposer.has('SomeUser')).toBeFalsy();
    });
  });
  describe('clone()', () => {
    it('should clone projection for fields', () => {
      iftc.setField('field3', {
        type: _graphql.GraphQLString,
        projection: {
          field1: true,
          field2: true
        }
      });
      const iftc2 = iftc.clone('newObject');
      expect(iftc2.getField('field3')).toEqual(expect.objectContaining({
        type: _graphql.GraphQLString,
        projection: {
          field1: true,
          field2: true
        }
      }));
    });
  });
  describe('get()', () => {
    it('should return type by path', () => {
      const myIFTC = new _InterfaceTypeComposer.InterfaceTypeComposer(new _graphql.GraphQLInterfaceType({
        name: 'Readable',
        fields: {
          field1: {
            type: _graphql.GraphQLString,
            args: {
              arg1: {
                type: _graphql.GraphQLInt
              }
            }
          }
        }
      }), _.schemaComposer);
      expect(myIFTC.get('field1').getType()).toBe(_graphql.GraphQLString);
      expect(myIFTC.get('field1.@arg1').getType()).toBe(_graphql.GraphQLInt);
    });
  });
  describe('get type methods', () => {
    it('getTypePlural() should return wrapped type with GraphQLList', () => {
      expect(iftc.getTypePlural()).toBeInstanceOf(_graphql.GraphQLList);
      expect(iftc.getTypePlural().ofType).toBe(iftc.getType());
    });
    it('getTypeNonNull() should return wrapped type with GraphQLNonNull', () => {
      expect(iftc.getTypeNonNull()).toBeInstanceOf(_graphql.GraphQLNonNull);
      expect(iftc.getTypeNonNull().ofType).toBe(iftc.getType());
    });
  });
  it('should have chainable methods', () => {
    expect(iftc.setFields({})).toBe(iftc);
    expect(iftc.setField('f1', {
      type: 'Int'
    })).toBe(iftc);
    expect(iftc.extendField('f1', {
      description: 'Ok'
    })).toBe(iftc);
    expect(iftc.deprecateFields('f1')).toBe(iftc);
    expect(iftc.addFields({})).toBe(iftc);
    expect(iftc.removeField('f1')).toBe(iftc);
    expect(iftc.removeOtherFields('f1')).toBe(iftc);
    expect(iftc.reorderFields(['f1'])).toBe(iftc);
  });
  describe('deprecateFields()', () => {
    let iftc1;
    beforeEach(() => {
      iftc1 = _.schemaComposer.createInterfaceTC({
        name: 'MyType',
        fields: {
          name: 'String',
          age: 'Int',
          dob: 'Date'
        }
      });
    });
    it('should accept string', () => {
      iftc1.deprecateFields('name');
      expect(iftc1.getFieldConfig('name').deprecationReason).toBe('deprecated');
      expect(iftc1.getFieldConfig('age').deprecationReason).toBeUndefined();
      expect(iftc1.getFieldConfig('dob').deprecationReason).toBeUndefined();
    });
    it('should accept array of string', () => {
      iftc1.deprecateFields(['name', 'age']);
      expect(iftc1.getFieldConfig('name').deprecationReason).toBe('deprecated');
      expect(iftc1.getFieldConfig('age').deprecationReason).toBe('deprecated');
      expect(iftc1.getFieldConfig('dob').deprecationReason).toBeUndefined();
    });
    it('should accept object with fields and reasons', () => {
      iftc1.deprecateFields({
        age: 'dont use',
        dob: 'old field'
      });
      expect(iftc1.getFieldConfig('name').deprecationReason).toBeUndefined();
      expect(iftc1.getFieldConfig('age').deprecationReason).toBe('dont use');
      expect(iftc1.getFieldConfig('dob').deprecationReason).toBe('old field');
    });
    it('should throw error on unexisted field', () => {
      expect(() => {
        iftc1.deprecateFields('unexisted');
      }).toThrowError(/Cannot deprecate unexisted field/);
      expect(() => {
        iftc1.deprecateFields(['unexisted']);
      }).toThrowError(/Cannot deprecate unexisted field/);
      expect(() => {
        iftc1.deprecateFields({
          unexisted: 'Deprecate reason'
        });
      }).toThrowError(/Cannot deprecate unexisted field/);
    });
  });
  describe('getFieldTC()', () => {
    const myIFTC = _ObjectTypeComposer.ObjectTypeComposer.create('MyCustomType', _.schemaComposer);

    myIFTC.addFields({
      scalar: 'String',
      list: '[Int]',
      obj: _ObjectTypeComposer.ObjectTypeComposer.create(`type MyCustomObjType { name: String }`, _.schemaComposer),
      objArr: [_ObjectTypeComposer.ObjectTypeComposer.create(`type MyCustomObjType2 { name: String }`, _.schemaComposer)],
      iface: _InterfaceTypeComposer.InterfaceTypeComposer.create(`interface MyInterfaceType { field: String }`, _.schemaComposer),
      enum: _EnumTypeComposer.EnumTypeComposer.create(`enum MyEnumType { FOO BAR }`, _.schemaComposer),
      union: _UnionTypeComposer.UnionTypeComposer.create(`union MyUnionType = MyCustomObjType | MyCustomObjType2`, _.schemaComposer)
    });
    it('should return TypeComposer for object field', () => {
      const tco = myIFTC.getFieldTC('obj');
      expect(tco).toBeInstanceOf(_ObjectTypeComposer.ObjectTypeComposer);
      expect(tco.getTypeName()).toBe('MyCustomObjType');
    });
    it('should return TypeComposer for wrapped object field', () => {
      const tco = myIFTC.getFieldTC('objArr');
      expect(tco).toBeInstanceOf(_ObjectTypeComposer.ObjectTypeComposer);
      expect(tco.getTypeName()).toBe('MyCustomObjType2');
      const tco2 = myIFTC.getFieldOTC('objArr');
      expect(tco).toBe(tco2);
    });
    it('should return TypeComposer for scalar fields', () => {
      const tco = myIFTC.getFieldTC('scalar');
      expect(tco).toBeInstanceOf(_ScalarTypeComposer.ScalarTypeComposer);
      expect(tco.getTypeName()).toBe('String');
      expect(() => myIFTC.getFieldOTC('scalar')).toThrow('must be ObjectTypeComposer');
    });
    it('should return TypeComposer for scalar list fields', () => {
      const tco = myIFTC.getFieldTC('list');
      expect(tco).toBeInstanceOf(_ScalarTypeComposer.ScalarTypeComposer);
      expect(tco.getTypeName()).toBe('Int');
    });
    it('should return TypeComposer for enum fields', () => {
      const tco = myIFTC.getFieldTC('enum');
      expect(tco).toBeInstanceOf(_EnumTypeComposer.EnumTypeComposer);
      expect(tco.getTypeName()).toBe('MyEnumType');
    });
    it('should return TypeComposer for interface list fields', () => {
      const tco = myIFTC.getFieldTC('iface');
      expect(tco).toBeInstanceOf(_InterfaceTypeComposer.InterfaceTypeComposer);
      expect(tco.getTypeName()).toBe('MyInterfaceType');
    });
    it('should return TypeComposer for union list fields', () => {
      const tco = myIFTC.getFieldTC('union');
      expect(tco).toBeInstanceOf(_UnionTypeComposer.UnionTypeComposer);
      expect(tco.getTypeName()).toBe('MyUnionType');
    });
  });
  describe('typeResolvers methods', () => {
    let PersonTC;
    let KindRedTC;
    let KindBlueTC;
    beforeEach(() => {
      PersonTC = _.schemaComposer.createObjectTC(`
        type Person { age: Int, field1: String, field2: String }
      `);
      PersonTC.addInterface(iftc);
      iftc.addTypeResolver(PersonTC, value => {
        return value.hasOwnProperty('age');
      });
      KindRedTC = _.schemaComposer.createObjectTC(`
        type KindRed { kind: String, field1: String, field2: String, red: String }
      `);
      KindRedTC.addInterface(iftc);
      iftc.addTypeResolver(KindRedTC, value => {
        return value.kind === 'red';
      });
      KindBlueTC = _.schemaComposer.createObjectTC(`
        type KindBlue { kind: String, field1: String, field2: String, blue: String }
      `);
      KindBlueTC.addInterface(iftc);
      iftc.addTypeResolver(KindBlueTC, value => {
        return value.kind === 'blue';
      });
    });
    it('hasTypeResolver()', () => {
      expect(iftc.hasTypeResolver(PersonTC)).toBeTruthy();
      expect(iftc.hasTypeResolver(KindRedTC)).toBeTruthy();
      expect(iftc.hasTypeResolver(KindBlueTC)).toBeTruthy();
      expect(iftc.hasTypeResolver(_.schemaComposer.createObjectTC('NewOne'))).toBeFalsy();
    });
    it('getTypeResolvers()', () => {
      const trm = iftc.getTypeResolvers();
      expect(trm).toBeInstanceOf(Map);
      expect(trm.size).toBe(3);
    });
    it('getTypeResolverCheckFn()', () => {
      const checkFn = iftc.getTypeResolverCheckFn(PersonTC);
      expect(checkFn({
        age: 15
      })).toBeTruthy();
      expect(checkFn({
        nope: 'other type'
      })).toBeFalsy();
    });
    it('getTypeResolverNames()', () => {
      expect(iftc.getTypeResolverNames()).toEqual(expect.arrayContaining(['Person', 'KindRed', 'KindBlue']));
    });
    it('getTypeResolverTypes()', () => {
      expect(iftc.getTypeResolverTypes()).toEqual(expect.arrayContaining([PersonTC.getType(), KindRedTC.getType(), KindBlueTC.getType()]));
    });
    describe('setTypeResolvers()', () => {
      it('async mode',
      /*#__PURE__*/
      _asyncToGenerator(function* () {
        const map = new Map([[PersonTC.getType(),
        /*#__PURE__*/
        _asyncToGenerator(function* () {
          return Promise.resolve(false);
        })], [KindRedTC,
        /*#__PURE__*/
        _asyncToGenerator(function* () {
          return Promise.resolve(true);
        })]]);
        iftc.setTypeResolvers(map);
        const resolveType = iftc.gqType.resolveType;
        expect(resolveType()).toBeInstanceOf(Promise);
        expect((yield resolveType())).toBe(KindRedTC.getType());
      }));
      it('sync mode', () => {
        const map = new Map([[PersonTC.getType(), () => false], [KindRedTC, () => false], [KindBlueTC, () => true]]);
        iftc.setTypeResolvers(map);
        const resolveType = iftc.gqType.resolveType;
        expect(resolveType()).toBe(KindBlueTC.getType());
      });
      it('throw error on wrong type', () => {
        expect(() => {
          const map = new Map([[false, () => true]]);
          iftc.setTypeResolvers(map);
        }).toThrowError();
      });
      it('throw error on wrong checkFn', () => {
        expect(() => {
          const map = new Map([[PersonTC, true]]);
          iftc.setTypeResolvers(map);
        }).toThrowError();
      });
    });
    it('addTypeResolver()', () => {
      const fn = () => false;

      iftc.addTypeResolver(PersonTC, fn);
      expect(iftc.getTypeResolverCheckFn(PersonTC)).toBe(fn);
      expect(() => {
        iftc.addTypeResolver(PersonTC);
      }).toThrowError();
    });
    it('removeTypeResolver()', () => {
      expect(iftc.hasTypeResolver(PersonTC)).toBeTruthy();
      iftc.removeTypeResolver(PersonTC);
      expect(iftc.hasTypeResolver(PersonTC)).toBeFalsy();
    });
    describe('check native resolveType methods', () => {
      it('check methods setResolveType() getResolveType()', () => {
        const iftc1 = _.schemaComposer.createInterfaceTC(`interface F { f: Int }`);

        const resolveType = () => 'A';

        expect(iftc1.getResolveType()).toBeUndefined();
        iftc1.setResolveType(resolveType);
        expect(iftc1.getResolveType()).toBe(resolveType);
      });
      it('integration test',
      /*#__PURE__*/
      _asyncToGenerator(function* () {
        const iftc1 = _.schemaComposer.createInterfaceTC(`interface F { f: Int }`);

        const aTC = _.schemaComposer.createObjectTC('type A implements F { a: Int, f: Int }');

        const bTC = _.schemaComposer.createObjectTC('type B implements F { b: Int, f: Int }');

        const resolveType = value => {
          if (value) {
            if (value.a) return 'A';else if (value.b) return 'B';
          }

          return null;
        };

        iftc1.setResolveType(resolveType);

        _.schemaComposer.addSchemaMustHaveType(aTC);

        _.schemaComposer.addSchemaMustHaveType(bTC);

        _.schemaComposer.Query.addFields({
          check: {
            type: '[F]',
            resolve: () => [{
              f: 'A',
              a: 1
            }, {
              f: 'B',
              b: 2
            }, {
              f: 'C',
              c: 3
            }]
          }
        });

        const res = yield (0, _graphql.graphql)(_.schemaComposer.buildSchema(), `
            query {
              check {
                __typename
                ... on A {
                  a
                }
                ... on B {
                  b
                }
              }
            }
          `);
        expect(res.data).toEqual({
          check: [{
            __typename: 'A',
            a: 1
          }, {
            __typename: 'B',
            b: 2
          }, null]
        });
      }));
    });
  });
  describe('InputType convert methods', () => {
    it('getInputType()', () => {
      const input = iftc.getInputType();
      expect(input).toBeInstanceOf(_graphql.GraphQLInputObjectType); // must return the same instance!

      expect(input).toBe(iftc.getInputType());
    });
    it('hasInputTypeComposer()', () => {
      expect(iftc.hasInputTypeComposer()).toBeFalsy();
      const input = iftc.getInputType();
      expect(input).toBeInstanceOf(_graphql.GraphQLInputObjectType);
      expect(iftc.hasInputTypeComposer()).toBeTruthy();
    });
    it('setInputTypeComposer()', () => {
      const itc1 = _InputTypeComposer.InputTypeComposer.createTemp(`Input`);

      iftc.setInputTypeComposer(itc1);
      const itc2 = iftc.getInputTypeComposer();
      expect(itc1).toBe(itc2);
    });
    it('getInputTypeComposer()', () => {
      const itc = iftc.getInputTypeComposer();
      expect(itc).toBeInstanceOf(_InputTypeComposer.InputTypeComposer); // must return the same instance!

      expect(itc).toBe(iftc.getInputTypeComposer());
    });
    it('getITC()', () => {
      expect(iftc.getITC()).toBe(iftc.getInputTypeComposer());
    });
    it('removeInputTypeComposer()', () => {
      const itc1 = iftc.getInputTypeComposer();
      iftc.removeInputTypeComposer();
      const itc2 = iftc.getInputTypeComposer();
      expect(itc1).not.toBe(itc2);
    });
  });
  describe('directive methods', () => {
    it('type level directive methods', () => {
      const tc1 = _.schemaComposer.createInterfaceTC(`
        interface My1 @d0(a: false) @d1(b: "3") @d0(a: true) { 
          field: Int
        }`);

      expect(tc1.getDirectives()).toEqual([{
        args: {
          a: false
        },
        name: 'd0'
      }, {
        args: {
          b: '3'
        },
        name: 'd1'
      }, {
        args: {
          a: true
        },
        name: 'd0'
      }]);
      expect(tc1.getDirectiveNames()).toEqual(['d0', 'd1', 'd0']);
      expect(tc1.getDirectiveByName('d0')).toEqual({
        a: false
      });
      expect(tc1.getDirectiveById(0)).toEqual({
        a: false
      });
      expect(tc1.getDirectiveByName('d1')).toEqual({
        b: '3'
      });
      expect(tc1.getDirectiveById(1)).toEqual({
        b: '3'
      });
      expect(tc1.getDirectiveByName('d2')).toEqual(undefined);
      expect(tc1.getDirectiveById(333)).toEqual(undefined);
    });
    it('field level directive methods', () => {
      const tc1 = _.schemaComposer.createInterfaceTC(`
        interface My1 { 
          field: Int @f0(a: false) @f1(b: "3") @f0(a: true)
        }`);

      expect(tc1.getFieldDirectives('field')).toEqual([{
        args: {
          a: false
        },
        name: 'f0'
      }, {
        args: {
          b: '3'
        },
        name: 'f1'
      }, {
        args: {
          a: true
        },
        name: 'f0'
      }]);
      expect(tc1.getFieldDirectiveNames('field')).toEqual(['f0', 'f1', 'f0']);
      expect(tc1.getFieldDirectiveByName('field', 'f0')).toEqual({
        a: false
      });
      expect(tc1.getFieldDirectiveById('field', 0)).toEqual({
        a: false
      });
      expect(tc1.getFieldDirectiveByName('field', 'f1')).toEqual({
        b: '3'
      });
      expect(tc1.getFieldDirectiveById('field', 1)).toEqual({
        b: '3'
      });
      expect(tc1.getFieldDirectiveByName('field', 'f2')).toEqual(undefined);
      expect(tc1.getFieldDirectiveById('field', 333)).toEqual(undefined);
    });
    it('arg level directive methods', () => {
      const tc1 = _.schemaComposer.createInterfaceTC(`
        interface My1 { 
          field(
            arg: Int @a0(a: false) @a1(b: "3") @a0(a: true)
          ): Int
        }`);

      expect(tc1.getFieldArgDirectives('field', 'arg')).toEqual([{
        args: {
          a: false
        },
        name: 'a0'
      }, {
        args: {
          b: '3'
        },
        name: 'a1'
      }, {
        args: {
          a: true
        },
        name: 'a0'
      }]);
      expect(tc1.getFieldArgDirectiveNames('field', 'arg')).toEqual(['a0', 'a1', 'a0']);
      expect(tc1.getFieldArgDirectiveByName('field', 'arg', 'a0')).toEqual({
        a: false
      });
      expect(tc1.getFieldArgDirectiveById('field', 'arg', 0)).toEqual({
        a: false
      });
      expect(tc1.getFieldArgDirectiveByName('field', 'arg', 'a1')).toEqual({
        b: '3'
      });
      expect(tc1.getFieldArgDirectiveById('field', 'arg', 1)).toEqual({
        b: '3'
      });
      expect(tc1.getFieldArgDirectiveByName('field', 'arg', 'a2')).toEqual(undefined);
      expect(tc1.getFieldArgDirectiveById('field', 'arg', 333)).toEqual(undefined);
    });
  });
  describe('merge()', () => {
    it('should merge with GraphQLInterfaceType', () => {
      const iface = _.schemaComposer.createInterfaceTC(`interface IFace { name: String }`);

      const iface2 = new _graphql.GraphQLInterfaceType({
        name: 'WithAge',
        fields: {
          age: {
            type: _graphql.GraphQLInt
          }
        }
      });
      iface.merge(iface2);
      expect(iface.getFieldNames()).toEqual(['name', 'age']);
    });
    it('should merge with InterfaceTypeComposer', () => {
      const iface = _.schemaComposer.createInterfaceTC(`interface IFace { name: String }`);

      const sc2 = new _.SchemaComposer();
      const iface2 = sc2.createInterfaceTC(`interface WithAge { age: Int }`);
      iface.merge(iface2);
      expect(iface.getFieldNames()).toEqual(['name', 'age']);
    });
    it('should merge with GraphQLObjectType', () => {
      const iface = _.schemaComposer.createInterfaceTC(`interface IFace { name: String }`);

      const person = new _graphql.GraphQLObjectType({
        name: 'Person',
        fields: {
          age: {
            type: _graphql.GraphQLInt
          }
        }
      });
      iface.merge(person);
      expect(iface.getFieldNames()).toEqual(['name', 'age']);
    });
    it('should merge with ObjectTypeComposer', () => {
      const iface = _.schemaComposer.createInterfaceTC(`interface IFace { name: String }`);

      const sc2 = new _.SchemaComposer();
      const person = sc2.createObjectTC(`type Person { age: Int }`);
      iface.merge(person);
      expect(iface.getFieldNames()).toEqual(['name', 'age']);
    });
    it('should throw error on wrong type', () => {
      const iface = _.schemaComposer.createInterfaceTC(`interface IFace { name: String }`);

      expect(() => iface.merge(_.schemaComposer.createScalarTC('Scalar'))).toThrow('Cannot merge ScalarTypeComposer');
    });
  });
});