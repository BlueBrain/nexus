function _extends() {
  return (_extends = Object.assign || function(target) {
    var i, source, key;
    for (i = 1; i < arguments.length; i++) {
      source = arguments[i];
      for (key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }).apply(this, arguments);
}

function useMutation(query) {
  function _ref(result) {
    if (isMounted.current) {
      setState({
        fetching: !1,
        stale: !!result.stale,
        data: result.data,
        error: result.error,
        extensions: result.extensions,
        operation: result.operation
      });
    }
    return result;
  }
  function _ref2() {
    isMounted.current = !1;
  }
  var isMounted = useRef(!0), client = useClient(), ref = useState(initialState), state = ref[0], setState = ref[1], executeMutation = useCallback((function(variables, context) {
    setState(_extends({}, initialState, {
      fetching: !0
    }));
    return toPromise(client.executeMutation(createRequest(query, variables), context || {})).then(_ref);
  }), [ client, query, setState ]);
  useEffect((function() {
    return _ref2;
  }), []);
  return [ state, executeMutation ];
}

function useSource(source, init) {
  function _ref() {
    isMounted.current = !1;
  }
  function _ref2(value) {
    if (!currentInit && isMounted.current) {
      setState(value);
    }
  }
  var isMounted = useRef(!0), ref = useState((function() {
    currentInit = !0;
    var initialValue = init;
    publish(onPush((function(value) {
      initialValue = value;
    }))(source)).unsubscribe();
    currentInit = !1;
    return initialValue;
  })), state = ref[0], setState = ref[1];
  useEffect((function() {
    return _ref;
  }), []);
  useEffect((function() {
    return subscribe(_ref2)(source).unsubscribe;
  }), [ source ]);
  return state;
}

function useBehaviourSubject(value) {
  var client = useClient(), state = useMemo((function() {
    var prevValue = value, subject = makeSubject(), prevValue$ = map((function() {
      return prevValue;
    }))(fromValue(value)), source = concat([ prevValue$, subject.source ]), next = function(value) {
      if (value !== prevValue) {
        subject.next(prevValue = value);
      }
    };
    return [ source, next ];
  }), []);
  useEffect((function() {
    if (!client.suspense) {
      state[1](value);
    }
  }), [ state, value ]);
  if (client.suspense) {
    state[1](value);
  }
  return state;
}

function useRequest(query, variables) {
  var prev = useRef(void 0);
  return useMemo((function() {
    var request = createRequest(query, variables);
    if (void 0 !== prev.current && prev.current.key === request.key) {
      return prev.current;
    } else {
      prev.current = request;
      return request;
    }
  }), [ query, variables ]);
}

function _ref(result, partial) {
  return _extends({}, result, partial);
}

function _ref2(ref) {
  var stale = ref.stale, data = ref.data, error = ref.error, extensions = ref.extensions, operation = ref.operation;
  return {
    fetching: !1,
    stale: !!stale,
    data: data,
    error: error,
    operation: operation,
    extensions: extensions
  };
}

function _ref3(query$) {
  if (!query$) {
    return fromValue({
      fetching: !1,
      stale: !1
    });
  }
  return concat([ fromValue({
    fetching: !0,
    stale: !1
  }), map(_ref2)(query$), fromValue({
    fetching: !1,
    stale: !1
  }) ]);
}

function useQuery(args) {
  var client = useClient(), request = useRequest(args.query, args.variables), makeQuery$ = useCallback((function(opts) {
    return client.executeQuery(request, _extends({}, {
      requestPolicy: args.requestPolicy,
      pollInterval: args.pollInterval
    }, args.context, opts));
  }), [ client, request, args.requestPolicy, args.pollInterval, args.context ]), ref = useBehaviourSubject(useMemo((function() {
    return args.pause ? null : makeQuery$();
  }), [ args.pause, makeQuery$ ])), query$$ = ref[0], update = ref[1], state = useSource(useMemo((function() {
    return scan(_ref, initialState)(switchMap(_ref3)(query$$));
  }), [ query$$ ]), initialState), executeQuery = useCallback((function(opts) {
    return update(makeQuery$(opts));
  }), [ update, makeQuery$ ]);
  return [ state, executeQuery ];
}

function _ref2$1(ref) {
  var stale = ref.stale, data = ref.data, error = ref.error, extensions = ref.extensions, operation = ref.operation;
  return {
    fetching: !0,
    stale: !!stale,
    data: data,
    error: error,
    extensions: extensions,
    operation: operation
  };
}

function _ref3$1(subscription$) {
  if (!subscription$) {
    return fromValue({
      fetching: !1
    });
  }
  return concat([ fromValue({
    fetching: !0,
    stale: !1
  }), map(_ref2$1)(subscription$), fromValue({
    fetching: !1,
    stale: !1
  }) ]);
}

function useSubscription(args, handler) {
  function _ref(result, partial) {
    var handler = handlerRef.current, data = void 0 !== partial.data ? "function" == typeof handler ? handler(result.data, partial.data) : partial.data : result.data;
    return _extends({}, result, partial, {
      data: data
    });
  }
  var request, makeSubscription$, ref, subscription$$, update, client = useClient(), handlerRef = useRef(handler);
  handlerRef.current = handler;
  request = useRequest(args.query, args.variables);
  makeSubscription$ = useCallback((function(opts) {
    return client.executeSubscription(request, _extends({}, args.context, opts));
  }), [ client, request, args.context ]);
  ref = useBehaviourSubject(useMemo((function() {
    return args.pause ? null : makeSubscription$();
  }), [ args.pause, makeSubscription$ ]));
  update = ref[1];
  return [ useSource(useMemo((function() {
    return scan(_ref, initialState)(switchMap(_ref3$1)(subscription$$));
  }), [ subscription$$ = ref[0] ]), initialState), useCallback((function(opts) {
    return update(makeSubscription$(opts));
  }), [ update, makeSubscription$ ]) ];
}

function Mutation(props) {
  var ref = useMutation(props.query), state = ref[0], executeMutation = ref[1];
  return props.children(_extends({}, state, {
    executeMutation: executeMutation
  }));
}

function Query(props) {
  var ref = useQuery(props), state = ref[0], executeQuery = ref[1];
  return props.children(_extends({}, state, {
    executeQuery: executeQuery
  }));
}

function Subscription(props) {
  var ref = useSubscription(props, props.handler), state = ref[0], executeSubscription = ref[1];
  return props.children(_extends({}, state, {
    executeSubscription: executeSubscription
  }));
}

var defaultClient, Context, Provider, Consumer, hasWarnedAboutDefault, useClient, initialState, currentInit;

import { createClient, createRequest } from "@urql/core";

export * from "@urql/core";

import { createContext, useContext, useRef, useState, useCallback, useEffect, useMemo } from "react";

import { toPromise, publish, onPush, subscribe, makeSubject, map, fromValue, concat, scan, switchMap } from "wonka";

defaultClient = createClient({
  url: "/graphql"
});

Provider = (Context = createContext(defaultClient)).Provider;

Consumer = Context.Consumer;

hasWarnedAboutDefault = !1;

useClient = function() {
  var client = useContext(Context);
  if ("production" !== process.env.NODE_ENV && client === defaultClient && !hasWarnedAboutDefault) {
    hasWarnedAboutDefault = !0;
    console.warn("Default Client: No client has been specified using urql's Provider.This means that urql will be falling back to defaults including making requests to `/graphql`.\nIf that's not what you want, please create a client and add a Provider.");
  }
  return client;
};

initialState = {
  fetching: !1,
  stale: !1,
  error: void 0,
  data: void 0,
  extensions: void 0,
  operation: void 0
};

currentInit = !1;

export { Consumer, Context, Mutation, Provider, Query, Subscription, useClient, useMutation, useQuery, useSubscription };
//# sourceMappingURL=urql.es.js.map
