'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var core = require('@emotion/core');
var React = require('react');
var React__default = _interopDefault(React);
var _pt = require('prop-types');
var _pt__default = _interopDefault(_pt);
var md = require('react-icons/md');
var gatsby = require('gatsby');
var package_json = require('@emotion/core/package.json');
var reactDom = require('react-dom');
var styled$1 = _interopDefault(require('@emotion/styled'));
var formik = require('formik');

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function secureTargetBlankLink(_ref) {
  var _ref$rel = _ref.rel,
      rel = _ref$rel === void 0 ? "" : _ref$rel,
      target = _ref.target;
  var NOOPENER_NOREFERRER = "noopener noreferrer";

  if (target && target.includes("_blank") && !rel.includes(NOOPENER_NOREFERRER)) {
    return "".concat(rel).concat(rel ? " " : "").concat(NOOPENER_NOREFERRER);
  }

  return rel;
}

var BaseAnchor = React__default.forwardRef(function (_ref, ref) {
  var role = _ref.role,
      _ref$target = _ref.target,
      target = _ref$target === void 0 ? "_blank" : _ref$target,
      rel = _ref.rel,
      children = _ref.children,
      rest = _objectWithoutProperties(_ref, ["role", "target", "rel", "children"]);

  return /*#__PURE__*/React__default.createElement("a", _extends({
    target: target,
    role: role,
    rel: secureTargetBlankLink({
      rel: rel,
      target: target
    })
  }, rest, {
    ref: ref
  }), children);
});
BaseAnchor.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BaseAnchor",
  "props": {
    "target": {
      "defaultValue": {
        "value": "`_blank`",
        "computed": false
      },
      "required": false
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BaseAnchor/BaseAnchor.tsx"] = {
    name: "BaseAnchor",
    docgenInfo: BaseAnchor.__docgenInfo,
    path: "src/components/BaseAnchor/BaseAnchor.tsx"
  };
}

var BaseButton = React__default.forwardRef(function (props, ref) {
  var children = props.children,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      _props$loading = props.loading,
      loading = _props$loading === void 0 ? false : _props$loading,
      _props$loadingLabel = props.loadingLabel,
      loadingLabel = _props$loadingLabel === void 0 ? "Loading" : _props$loadingLabel,
      LoadingIcon = props.LoadingIcon,
      _props$type = props.type,
      type = _props$type === void 0 ? "button" : _props$type,
      _props$ButtonComponen = props.ButtonComponent,
      ButtonComponent = _props$ButtonComponen === void 0 ? "button" : _props$ButtonComponen,
      rest = _objectWithoutProperties(props, ["children", "disabled", "loading", "loadingLabel", "LoadingIcon", "type", "ButtonComponent"]);

  return /*#__PURE__*/React__default.createElement(ButtonComponent, _extends({
    disabled: loading ? true : disabled,
    type: type
  }, rest, {
    ref: ref
  }), loading ? /*#__PURE__*/React__default.createElement(React__default.Fragment, null, loadingLabel && /*#__PURE__*/React__default.createElement("span", null, loadingLabel), " ", LoadingIcon && /*#__PURE__*/React__default.createElement(LoadingIcon, null)) : children);
});
BaseButton.propTypes = {
  loading: _pt__default.bool,
  loadingLabel: _pt__default.node,
  LoadingIcon: _pt__default.elementType,
  ButtonComponent: _pt__default.elementType
};
BaseButton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BaseButton"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BaseButton/BaseButton.tsx"] = {
    name: "BaseButton",
    docgenInfo: BaseButton.__docgenInfo,
    path: "src/components/BaseButton/BaseButton.tsx"
  };
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n  33% {\n    transform:  scale(1);\n    }\n  66% {\n    transform: scale(0.8);\n  }\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  0% {\n    transform: rotate(0);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}
function getButtonCss(_ref) {
  var _ref$size = _ref.size,
      size = _ref$size === void 0 ? "L" : _ref$size,
      _ref$tone = _ref.tone,
      tone = _ref$tone === void 0 ? "BRAND" : _ref$tone,
      _ref$variant = _ref.variant,
      variant = _ref$variant === void 0 ? "PRIMARY" : _ref$variant,
      leftIcon = _ref.leftIcon,
      rightIcon = _ref.rightIcon,
      loading = _ref.loading,
      _ref$textVariant = _ref.textVariant,
      textVariant = _ref$textVariant === void 0 ? "DEFAULT" : _ref$textVariant;
  return function (theme) {
    return [getButtonBaseCss(textVariant)(theme), getButtonIconsCss({
      hasLeftIcon: !!leftIcon,
      hasRightIcon: !!rightIcon || loading
    })(theme), getButtonLoadingCss({
      loading: loading
    })(theme), getButtonVariantCss(variant, tone)(theme), getButtonSizeCss(size, textVariant)(theme)];
  };
}

function getButtonBaseCss(textVariant) {
  return function (theme) {
    return {
      alignItems: "center",
      border: theme.colors.grey[60],
      borderRadius: theme.radii[2],
      boxSizing: "border-box",
      cursor: "pointer",
      display: "inline-flex",
      fontFamily: textVariant === "BRAND" ? theme.fonts.heading : theme.fonts.body,
      justifyContent: "center",
      transition: "background ".concat(theme.transitions.speed["default"], ", border ").concat(theme.transitions.speed["default"], ", color ").concat(theme.transitions.speed["default"]),
      lineHeight: theme.lineHeights.solid,
      textDecoration: "none",
      "&[disabled], &[disabled]:hover": {
        cursor: "not-allowed",
        opacity: 0.5
      }
    };
  };
}

var animations = {
  iconLoadingAnim: core.keyframes(_templateObject()),
  iconHoverAnim: core.keyframes(_templateObject2())
};

function getButtonIconsCss(_ref2) {
  var hasLeftIcon = _ref2.hasLeftIcon,
      hasRightIcon = _ref2.hasRightIcon;
  return function (theme) {
    return {
      svg: {
        flexShrink: 0,
        margin: "0 ".concat(theme.space[2]),
        transform: "scale(1)",
        marginRight: hasRightIcon ? "-".concat(theme.space[2]) : undefined,
        marginLeft: hasLeftIcon ? "-0.30em" : undefined
      },
      "&:hover:not([disabled]), &:focus:not([disabled])": {
        svg: {
          animation: "".concat(animations.iconHoverAnim, " 1s linear infinite")
        }
      }
    };
  };
}

function getButtonLoadingCss(_ref3) {
  var loading = _ref3.loading;
  return function (_theme) {
    return loading ? {
      "&[disabled], &[disabled]:hover": {
        opacity: 0.9
      },
      svg: {
        animation: "".concat(animations.iconLoadingAnim, " 1s linear infinite")
      },
      "&:hover:not([disabled]), &:focus:not([disabled])": {
        svg: {
          animation: "none"
        }
      }
    } : {};
  };
}

function getButtonSizeCss(size, textVariant) {
  return function (theme) {
    if (size === "S") {
      return {
        fontSize: textVariant === "BRAND" ? theme.fontSizes[1] : theme.fontSizes[0],
        minHeight: "calc(".concat(theme.space[2], " * 7)"),
        padding: "".concat(theme.space[2], " ").concat(theme.space[3])
      };
    }

    if (size === "M") {
      return {
        fontSize: textVariant === "BRAND" ? theme.fontSizes[2] : theme.fontSizes[1],
        minHeight: "calc(".concat(theme.space[2], " * 9)"),
        padding: "".concat(theme.space[2], " ").concat(theme.space[4])
      };
    }

    if (size === "L") {
      return {
        fontSize: textVariant === "BRAND" ? theme.fontSizes[3] : theme.fontSizes[2],
        minHeight: theme.space[9],
        padding: "".concat(theme.space[2], " ").concat(theme.space[5])
      };
    }

    if (size === "XL") {
      return {
        fontSize: textVariant === "BRAND" ? theme.fontSizes[5] : theme.fontSizes[4],
        minHeight: theme.space[10],
        padding: "".concat(theme.space[3], " ").concat(theme.space[6])
      };
    }
  };
}

function getButtonVariantCss(variant, tone) {
  return function (theme) {
    if (variant === "PRIMARY") {
      return {
        background: theme.tones[tone].dark,
        border: "1px solid ".concat(theme.tones[tone].dark),
        color: theme.colors.white,
        fontWeight: theme.fontWeights.semiBold,
        ":hover": {
          background: theme.tones[tone].darker,
          border: "1px solid ".concat(theme.tones[tone].darker)
        }
      };
    }

    if (variant === "SECONDARY") {
      return {
        background: "transparent",
        border: "1px solid ".concat(theme.tones[tone].light),
        color: theme.tones[tone].text,
        ":hover": {
          borderColor: theme.tones[tone].dark,
          color: theme.tones[tone].superDark
        }
      };
    }

    if (variant === "GHOST") {
      return {
        background: "transparent",
        border: "1px solid transparent",
        color: theme.tones[tone].text,
        ":hover": {
          background: theme.tones[tone].superLight,
          color: theme.tones[tone].superDark
        }
      };
    }

    return {};
  };
}

function getButtonStyles(_ref) {
  var children = _ref.children,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? "L" : _ref$size,
      _ref$tone = _ref.tone,
      tone = _ref$tone === void 0 ? "BRAND" : _ref$tone,
      _ref$variant = _ref.variant,
      variant = _ref$variant === void 0 ? "PRIMARY" : _ref$variant,
      loading = _ref.loading,
      leftIcon = _ref.leftIcon,
      rightIcon = _ref.rightIcon,
      _ref$textVariant = _ref.textVariant,
      textVariant = _ref$textVariant === void 0 ? "DEFAULT" : _ref$textVariant;
  return {
    css: getButtonCss({
      size: size,
      variant: variant,
      tone: tone,
      loading: loading,
      leftIcon: leftIcon,
      rightIcon: rightIcon,
      textVariant: textVariant
    }),
    children: leftIcon || rightIcon ? core.jsx(React__default.Fragment, null, leftIcon, children, rightIcon) : children
  };
}
var Button = React__default.forwardRef(function (props, ref) {
  var children = props.children,
      loading = props.loading,
      _props$LoadingIcon = props.LoadingIcon,
      LoadingIcon = _props$LoadingIcon === void 0 ? md.MdRefresh : _props$LoadingIcon,
      size = props.size,
      tone = props.tone,
      variant = props.variant,
      leftIcon = props.leftIcon,
      rightIcon = props.rightIcon,
      textVariant = props.textVariant,
      rest = _objectWithoutProperties(props, ["children", "loading", "LoadingIcon", "size", "tone", "variant", "leftIcon", "rightIcon", "textVariant"]);

  return core.jsx(BaseButton, _extends({}, getButtonStyles({
    children: children,
    loading: loading,
    size: size,
    tone: tone,
    variant: variant,
    leftIcon: leftIcon,
    rightIcon: rightIcon,
    textVariant: textVariant
  }), {
    loading: loading,
    LoadingIcon: LoadingIcon
  }, rest, {
    ref: ref
  }));
});
Button.propTypes = {
  leftIcon: _pt__default.node,
  rightIcon: _pt__default.node
};
Button.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "Button"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Button/Button.tsx"] = {
    name: "Button",
    docgenInfo: Button.__docgenInfo,
    path: "src/components/Button/Button.tsx"
  };
}

var AnchorButton = React__default.forwardRef(function (props, ref) {
  var children = props.children,
      size = props.size,
      tone = props.tone,
      variant = props.variant,
      leftIcon = props.leftIcon,
      rightIcon = props.rightIcon,
      textVariant = props.textVariant,
      rest = _objectWithoutProperties(props, ["children", "size", "tone", "variant", "leftIcon", "rightIcon", "textVariant"]);

  return core.jsx(BaseAnchor, _extends({}, getButtonStyles({
    children: children,
    size: size,
    tone: tone,
    variant: variant,
    leftIcon: leftIcon,
    rightIcon: rightIcon,
    textVariant: textVariant
  }), rest, {
    ref: ref
  }));
});
AnchorButton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "AnchorButton"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/AnchorButton/AnchorButton.tsx"] = {
    name: "AnchorButton",
    docgenInfo: AnchorButton.__docgenInfo,
    path: "src/components/AnchorButton/AnchorButton.tsx"
  };
}

var baseCss = function baseCss(theme) {
  return _defineProperty({
    display: "flex",
    alignItems: "center",
    background: theme.colors.teal[5],
    color: theme.colors.blackFade[70],
    fontSize: theme.fontSizes[1],
    fontFamily: theme.fonts.system
  }, "&:not(:first-child)", {
    borderTop: "1px solid ".concat(theme.colors.teal[10])
  });
};

var contentCss = function contentCss(theme) {
  return {
    paddingTop: theme.space[5],
    paddingBottom: theme.space[5],
    paddingLeft: theme.space[9],
    paddingRight: 0
  };
};

function Announcement(props) {
  return core.jsx("div", _extends({
    css: baseCss
  }, props), core.jsx("div", {
    css: contentCss
  }, props.children), core.jsx(AnnouncementDecoration, null));
}

function AnnouncementDecoration() {
  return core.jsx("svg", {
    width: "104",
    height: "60",
    "view-box": "0 0 104 60",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, core.jsx("g", {
    opacity: "0.75"
  }, core.jsx("circle", {
    opacity: "0.5",
    cx: "47.4997",
    cy: "29.5",
    r: "5.50048",
    fill: "#FFDF37"
  }), core.jsx("ellipse", {
    opacity: "0.25",
    cx: "61.5005",
    cy: "15.5002",
    rx: "5.50048",
    ry: "5.50048",
    fill: "#BC027F"
  }), core.jsx("circle", {
    opacity: "0.15",
    cx: "5.49991",
    cy: "15.4997",
    r: "5.49991",
    fill: "#159BF3"
  }), core.jsx("ellipse", {
    opacity: "0.15",
    cx: "47.4992",
    cy: "1.49991",
    rx: "5.49991",
    ry: "5.49991",
    fill: "#B17ACC"
  }), core.jsx("ellipse", {
    opacity: "0.5",
    cx: "61.4995",
    cy: "57.5005",
    rx: "5.50048",
    ry: "5.50048",
    fill: "#59C156"
  }), core.jsx("ellipse", {
    opacity: "0.25",
    cx: "47.4997",
    cy: "43.4997",
    rx: "5.50048",
    ry: "5.50048",
    fill: "#FB8400"
  }), core.jsx("circle", {
    opacity: "0.15",
    cx: "61.4995",
    cy: "43.4997",
    r: "5.50048",
    fill: "#663399"
  }), core.jsx("ellipse", {
    opacity: "0.25",
    cx: "19.4997",
    cy: "43.4992",
    rx: "5.49991",
    ry: "5.4999",
    fill: "#05F7F4"
  }), core.jsx("circle", {
    opacity: "0.25",
    cx: "34",
    cy: "29.5005",
    r: "5.50048",
    fill: "#FFD280"
  }), core.jsx("ellipse", {
    opacity: "0.15",
    rx: "5.49991",
    ry: "5.49991",
    transform: "matrix(1 -8.74227e-08 -8.74228e-08 -1 75.4999 57.5003)",
    fill: "#159BF3"
  }), core.jsx("ellipse", {
    opacity: "0.15",
    rx: "5.50048",
    ry: "5.50048",
    transform: "matrix(1 -8.74229e-08 -8.74227e-08 -1 103.5 29.5002)",
    fill: "#A1DA9E"
  }), core.jsx("ellipse", {
    opacity: "0.25",
    rx: "5.4999",
    ry: "5.49991",
    transform: "matrix(1 -8.74229e-08 -8.74227e-08 -1 89.4997 29.5008)",
    fill: "#159BF3"
  }), core.jsx("ellipse", {
    opacity: "0.25",
    rx: "5.50048",
    ry: "5.50048",
    transform: "matrix(1 -8.74229e-08 -8.74227e-08 -1 103.5 43.5)",
    fill: "#FB8400"
  })));
}

Announcement.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "Announcement"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Announcement/Announcement.tsx"] = {
    name: "Announcement",
    docgenInfo: Announcement.__docgenInfo,
    path: "src/components/Announcement/Announcement.tsx"
  };
}

var l={purple:{5:"#fcfaff",10:"#f6edfa",20:"#f1defa",30:"#d9bae8",40:"#b17acc",50:"#8a4baf",60:"#663399",70:"#542c85",80:"#452475",90:"#362066"},orange:{5:"#fffcf7",10:"#fff4db",20:"#ffedbf",30:"#ffe4a1",40:"#ffd280",50:"#ffb238",60:"#fb8400",70:"#f67300",80:"#e65800",90:"#db3a00"},yellow:{5:"#fffdf7",10:"#fff5bf",20:"#fff2a8",30:"#ffeb99",40:"#ffdf37",50:"#fed038",60:"#fec21e",70:"#e3a617",80:"#bf9141",90:"#8a6534"},red:{5:"#fffafa",10:"#fde7e7",20:"#ffbab8",30:"#ff8885",40:"#ff5a54",50:"#fa2915",60:"#ec1818",70:"#da0013",80:"#ce0009",90:"#b80000"},magenta:{5:"#fffafd",10:"#ffe6f6",20:"#f2c4e3",30:"#e899ce",40:"#d459ab",50:"#bc027f",60:"#a6026a",70:"#940159",80:"#7d0e59",90:"#690147"},blue:{5:"#f5fcff",10:"#dbf0ff",20:"#90cdf9",30:"#63b8f6",40:"#3fa9f5",50:"#0d96f2",60:"#0e8de6",70:"#047bd3",80:"#006ac1",90:"#004ca3"},teal:{5:"#f7ffff",10:"#dcfffd",20:"#ccfffc",30:"#a6fffa",40:"#73fff7",50:"#05f7f4",60:"#2de3da",70:"#00bdb6",80:"#10a39e",90:"#008577"},green:{5:"#f7fdf7",10:"#def5dc",20:"#a1da9e",30:"#79cd75",40:"#59c156",50:"#37b635",60:"#2ca72c",70:"#1d9520",80:"#088413",90:"#006500"},grey:{5:"#fbfbfb",10:"#f5f5f5",20:"#f0f0f2",30:"#d9d7e0",40:"#b7b5bd",50:"#78757a",60:"#635e69",70:"#48434f",80:"#36313d",90:"#232129"},white:"#ffffff",black:"#000000",gatsby:"#663399",lilac:"#8a4baf",lavender:"#f1defa",accent:"#ffb238",warning:"#da0013",blackFade:{5:"rgba(35, 33, 41, 0.05)",10:"rgba(35, 33, 41, 0.1)",20:"rgba(35, 33, 41, 0.2)",30:"rgba(35, 33, 41, 0.3)",40:"rgba(35, 33, 41, 0.4)",50:"rgba(35, 33, 41, 0.5)",60:"rgba(35, 33, 41, 0.6)",70:"rgba(35, 33, 41, 0.7)",80:"rgba(35, 33, 41, 0.8)",90:"rgba(35, 33, 41, 0.9)"},whiteFade:{5:"rgba(255, 255, 255, 0.05)",10:"rgba(255, 255, 255, 0.1)",20:"rgba(255, 255, 255, 0.2)",30:"rgba(255, 255, 255, 0.3)",40:"rgba(255, 255, 255, 0.4)",50:"rgba(255, 255, 255, 0.5)",60:"rgba(255, 255, 255, 0.6)",70:"rgba(255, 255, 255, 0.7)",80:"rgba(255, 255, 255, 0.8)",90:"rgba(255, 255, 255, 0.9)"},ui:{background:"#fbfbfb",hover:"#fcfaff",border:{subtle:"#f0f0f2"}},link:{color:"#8a4baf",border:"#d9bae8",hoverBorder:"#8a4baf"},text:{header:"#000000",primary:"#36313d",secondary:"#78757a",placeholder:"#b7b5bd"},input:{border:"#d9d7e0",focusBorder:"#ffd280",focusBoxShadow:"#ffedbf"},code:{bgInline:"#fbf2e9",bg:"#fdfaf6",border:"#faede5",text:"#866c5b",remove:"#da0013",add:"#088413",selector:"#b94185",tag:"#137886",keyword:"#096fb3",comment:"#527713",punctuation:"#53450e",regex:"#dc0437",cssString:"#a2466c",invisibles:"#e0d7d1",scrollbarThumb:"#f4d1c6",lineHighlightBorder:"#f1beb6",copyButton:"#635e69",lineHighlightBackground:"#fbf0ea",scrollbarTrack:"#faede5"}},i={body:"-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial, Noto Sans, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji",system:"-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial, Noto Sans, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji",sans:"Inter, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial, Noto Sans, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji",heading:"Futura PT, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial, Noto Sans, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji",brand:"Futura PT, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial, Noto Sans, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji",monospace:"SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",serif:"Georgia, Times New Roman, Times, serif"},b=["0.75rem","0.875rem","1rem","1.125rem","1.25rem","1.5rem","1.75rem","2rem","2.25rem","2.625rem","3rem","3.375rem","3.75rem","4.25rem","4.75rem","5.25rem","5.75rem"],t={body:400,semiBold:600,bold:700,extraBold:800,heading:700},d={normal:"normal",tracked:"0.075em",tight:"-0.015em"},n={solid:1,dense:1.25,heading:1.25,default:1.5,body:1.5,loose:1.75};var S=[0,"2px","4px","8px","16px","9999px","100%"],u={raised:"0px 1px 2px rgba(46, 41, 51, 0.08), 0px 2px 4px rgba(71, 63, 79, 0.08)",floating:"0px 2px 4px rgba(46, 41, 51, 0.08), 0px 4px 8px rgba(71, 63, 79, 0.16)",overlay:"0px 4px 8px rgba(46, 41, 51, 0.08), 0px 8px 16px rgba(71, 63, 79, 0.16)",dialog:"0px 4px 16px rgba(46, 41, 51, 0.08), 0px 8px 24px rgba(71, 63, 79, 0.16)"},y=["0rem","0.25rem","0.5rem","0.75rem","1rem","1.25rem","1.5rem","2rem","2.5rem","3rem","3.5rem","4rem","4.5rem"],j={default:"250ms cubic-bezier(0.4, 0, 0.2, 1)",curve:{default:"cubic-bezier(0.4, 0, 0.2, 1)",fastOutLinearIn:"cubic-bezier(0.4, 0, 1, 1)"},speed:{faster:"50ms",fast:"100ms",default:"250ms",slow:"500ms",slower:"1000ms"}};

var defaultColors = {
  primaryBackground: l.white,
  secondaryBackground: l.grey[5],
  standardLine: l.grey[20]
};

var colors = _objectSpread2({}, l, {}, defaultColors);

var DEFAULT_SIZE = "M";
var avatarSizeValues = {
  XS: "20px",
  S: "24px",
  M: "32px",
  L: "48px",
  XL: "64px",
  XXL: "128px"
};
var borderSizeValues = {
  XS: 0.5,
  S: 1,
  M: 2,
  L: 3,
  XL: 4,
  XXL: 8
};
var placeholderFontSizes = {
  XS: "0.5rem",
  S: b[0],
  M: b[1],
  L: b[4],
  XL: b[6],
  XXL: b[12]
};

var baseCss$1 = core.css({
  background: colors.grey[20],
  borderRadius: "50%",
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "space-around",
  flexShrink: 0,
  overflow: "hidden",
  color: colors.grey[60]
});
// TODO fit placeholder text to its avatar size for cases like +99
function AvatarSkeleton(_ref) {
  var size = _ref.size,
      borderColor = _ref.borderColor,
      rest = _objectWithoutProperties(_ref, ["size", "borderColor"]);

  return core.jsx("span", _extends({
    css: [baseCss$1, core.css({
      width: avatarSizeValues[size],
      height: avatarSizeValues[size],
      fontSize: placeholderFontSizes[size],
      border: borderColor ? "".concat(borderSizeValues[size], "px solid ").concat(borderColor) : undefined
    })]
  }, rest));
}
AvatarSkeleton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "AvatarSkeleton",
  "props": {
    "size": {
      "required": true,
      "tsType": {
        "name": "AvatarSize"
      },
      "description": ""
    },
    "borderColor": {
      "required": false,
      "tsType": {
        "name": "union",
        "raw": "string | null",
        "elements": [{
          "name": "string"
        }, {
          "name": "null"
        }]
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Avatar/AvatarSkeleton.tsx"] = {
    name: "AvatarSkeleton",
    docgenInfo: AvatarSkeleton.__docgenInfo,
    path: "src/components/Avatar/AvatarSkeleton.tsx"
  };
}

// The following is based on textFit library https://github.com/STRML/textFit
function fitText(_ref) {
  var _ref$maxWidth = _ref.maxWidth,
      maxTextWidth = _ref$maxWidth === void 0 ? 1 : _ref$maxWidth,
      minFontSizeInRem = _ref.minFontSizeInRem,
      maxFontSizeInRem = _ref.maxFontSizeInRem;
  return function (element) {
    if (!element) {
      return;
    }

    var parent = element.parentElement;

    if (!parent) {
      return;
    } // Get base font size so that we can parse rem into px


    var baseFontSize = parseFloat(window.getComputedStyle(document.documentElement).fontSize);
    var low = baseFontSize * minFontSizeInRem;
    var high = baseFontSize * maxFontSizeInRem;
    var maxWidth = parent.clientWidth * maxTextWidth;
    var maxHeight = parent.clientHeight * maxWidth;
    var fontSize = low;
    var mid; // Binary search to find the most fitting font size

    while (low <= high) {
      mid = (high + low) / 2;
      element.style.fontSize = mid + "px";

      if (element.scrollWidth <= maxWidth && element.scrollHeight <= maxHeight) {
        fontSize = mid;
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }

    element.style.fontSize = "".concat(fontSize, "px");
  };
}

var imageCss = core.css({
  objectFit: "cover",
  width: "100%",
  height: "100%",
  padding: 0,
  margin: 0
});
var maxFallbackTextWidth = {
  XS: 0.9,
  S: 0.9,
  M: 0.9,
  L: 0.8,
  XL: 0.8,
  XXL: 0.8
};
function Avatar(_ref) {
  var src = _ref.src,
      fallback = _ref.fallback,
      label = _ref.label,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? DEFAULT_SIZE : _ref$size,
      _ref$borderColor = _ref.borderColor,
      borderColor = _ref$borderColor === void 0 ? null : _ref$borderColor,
      className = _ref.className,
      style = _ref.style;
  var textFitter = fitText({
    maxWidth: maxFallbackTextWidth[size],
    minFontSizeInRem: parseFloat(placeholderFontSizes.XS),
    maxFontSizeInRem: parseFloat(placeholderFontSizes[size])
  });
  return core.jsx(AvatarSkeleton, {
    size: size,
    borderColor: borderColor,
    className: className,
    style: style,
    title: label
  }, src ? core.jsx("img", {
    css: imageCss,
    src: src,
    alt: label
  }) : core.jsx("span", {
    "aria-label": label,
    ref: textFitter
  }, fallback));
}
Avatar.propTypes = {
  src: _pt__default.string.isRequired,
  label: _pt__default.string.isRequired,
  fallback: _pt__default.node,
  borderColor: _pt__default.oneOfType([_pt__default.string, _pt__default.oneOf([null])]),
  fitTextFallback: _pt__default.bool,
  className: _pt__default.string
};
Avatar.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "Avatar",
  "props": {
    "size": {
      "defaultValue": {
        "value": "DEFAULT_SIZE",
        "computed": true
      },
      "required": false,
      "tsType": {
        "name": "AvatarSize"
      },
      "description": ""
    },
    "borderColor": {
      "defaultValue": {
        "value": "null",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "union",
        "raw": "string | null",
        "elements": [{
          "name": "string"
        }, {
          "name": "null"
        }]
      },
      "description": ""
    },
    "src": {
      "required": true,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "label": {
      "required": true,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "fallback": {
      "required": false,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    },
    "fitTextFallback": {
      "required": false,
      "tsType": {
        "name": "boolean"
      },
      "description": ""
    },
    "className": {
      "required": false,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "style": {
      "required": false,
      "tsType": {
        "name": "ReactCSSProperties",
        "raw": "React.CSSProperties"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Avatar/Avatar.tsx"] = {
    name: "Avatar",
    docgenInfo: Avatar.__docgenInfo,
    path: "src/components/Avatar/Avatar.tsx"
  };
}

var groupBaseCss = core.css({
  display: "flex",
  alignItems: "center"
});
function AvatarsGroup(_ref) {
  var avatars = _ref.avatars,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? DEFAULT_SIZE : _ref$size,
      _ref$borderColor = _ref.borderColor,
      borderColor = _ref$borderColor === void 0 ? "#fff" : _ref$borderColor,
      _ref$omittedAvatarsCo = _ref.omittedAvatarsCount,
      omittedAvatarsCount = _ref$omittedAvatarsCo === void 0 ? 0 : _ref$omittedAvatarsCo,
      _ref$omittedAvatarsLa = _ref.omittedAvatarsLabel,
      omittedAvatarsLabel = _ref$omittedAvatarsLa === void 0 ? "".concat(omittedAvatarsCount, " more") : _ref$omittedAvatarsLa,
      className = _ref.className,
      style = _ref.style;
  var commonAvatarProps = {
    size: size,
    borderColor: borderColor
  };
  var overlapCss = {
    marginLeft: "-".concat(borderSizeValues[size] * 2, "px")
  };
  var avatarsShown = avatars.length;
  return core.jsx("div", {
    css: groupBaseCss,
    className: className,
    style: style
  }, avatars.map(function (_ref2, idx) {
    var src = _ref2.src,
        label = _ref2.label,
        avatar = _objectWithoutProperties(_ref2, ["src", "label"]);

    return core.jsx(Avatar // Using both src and label as key because src might not be unique
    , _extends({
      key: "".concat(src, "_").concat(label, "_").concat(idx),
      src: src,
      label: label
    }, commonAvatarProps, avatar, {
      css: idx !== 0 && overlapCss,
      style: {
        zIndex: avatarsShown - idx
      }
    }));
  }), omittedAvatarsCount > 0 && core.jsx(Avatar, _extends({
    src: "" // this is an avatar "lookalike" that indicates how many avatars were left out
    ,
    label: omittedAvatarsLabel,
    css: overlapCss
  }, commonAvatarProps, {
    fallback: "+".concat(omittedAvatarsCount)
  })));
}
AvatarsGroup.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "AvatarsGroup",
  "props": {
    "size": {
      "defaultValue": {
        "value": "DEFAULT_SIZE",
        "computed": true
      },
      "required": false,
      "tsType": {
        "name": "AvatarSize"
      },
      "description": ""
    },
    "borderColor": {
      "defaultValue": {
        "value": "\"#fff\"",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "omittedAvatarsCount": {
      "defaultValue": {
        "value": "0",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "number"
      },
      "description": ""
    },
    "omittedAvatarsLabel": {
      "defaultValue": {
        "value": "`${omittedAvatarsCount} more`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "avatars": {
      "required": true,
      "tsType": {
        "name": "Array",
        "elements": [{
          "name": "Pick",
          "elements": [{
            "name": "AvatarProps"
          }, {
            "name": "union",
            "raw": "\"src\" | \"label\" | \"fallback\"",
            "elements": [{
              "name": "literal",
              "value": "\"src\""
            }, {
              "name": "literal",
              "value": "\"label\""
            }, {
              "name": "literal",
              "value": "\"fallback\""
            }]
          }],
          "raw": "Pick<AvatarProps, \"src\" | \"label\" | \"fallback\">"
        }],
        "raw": "AvatarDescriptor[]"
      },
      "description": ""
    },
    "className": {
      "required": false,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "style": {
      "required": false,
      "tsType": {
        "name": "ReactCSSProperties",
        "raw": "React.CSSProperties"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Avatar/AvatarsGroup.tsx"] = {
    name: "AvatarsGroup",
    docgenInfo: AvatarsGroup.__docgenInfo,
    path: "src/components/Avatar/AvatarsGroup.tsx"
  };
}

function BaseLink(_ref) {
  var to = _ref.to,
      role = _ref.role,
      children = _ref.children,
      rest = _objectWithoutProperties(_ref, ["to", "role", "children"]);

  return /*#__PURE__*/React__default.createElement(gatsby.Link, _extends({
    to: to,
    role: role
  }, rest), children);
}
BaseLink.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BaseLink"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BaseLink/BaseLink.tsx"] = {
    name: "BaseLink",
    docgenInfo: BaseLink.__docgenInfo,
    path: "src/components/BaseLink/BaseLink.tsx"
  };
}

function LinkButton(props) {
  var children = props.children,
      size = props.size,
      tone = props.tone,
      variant = props.variant,
      leftIcon = props.leftIcon,
      rightIcon = props.rightIcon,
      rest = _objectWithoutProperties(props, ["children", "size", "tone", "variant", "leftIcon", "rightIcon"]);

  return core.jsx(BaseLink, _extends({}, getButtonStyles({
    children: children,
    size: size,
    tone: tone,
    variant: variant,
    leftIcon: leftIcon,
    rightIcon: rightIcon
  }), rest));
}
LinkButton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "LinkButton"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/LinkButton/LinkButton.tsx"] = {
    name: "LinkButton",
    docgenInfo: LinkButton.__docgenInfo,
    path: "src/components/LinkButton/LinkButton.tsx"
  };
}

function useOnClickOutside(ref, handler) {
  React__default.useEffect(function () {
    var listener = function listener(event) {
      // Do nothing if clicking ref's element or descendent elements
      if (!ref.current || ref.current.contains(event.target)) {
        return;
      }

      handler(event);
    };

    if (document) {
      document.addEventListener("mousedown", listener);
      document.addEventListener("touchstart", listener);
      return function () {
        document.removeEventListener("mousedown", listener);
        document.removeEventListener("touchstart", listener);
      };
    }
  }, [ref, handler]);
}

var hamburgerIconStylesShared = function hamburgerIconStylesShared(theme) {
  return {
    width: 24,
    height: "3px",
    borderRadius: theme.radii[1],
    background: theme.colors.black,
    margin: "10px 0",
    position: "relative",
    zIndex: 1000,
    "&:before, &:after": {
      borderRadius: theme.radii[1],
      height: "3px",
      background: theme.colors.black,
      content: "\" \"",
      position: "absolute",
      right: 0,
      transition: "transform 250ms cubic-bezier(.68,-.55,.265,1.55)"
    },
    ":before": {
      top: -7,
      width: 20
    },
    ":after": {
      top: 7,
      width: 16
    },
    "&.active": {
      background: "0 0",
      "&:before, &:after": {
        top: 0,
        width: 24
      },
      "&:before": {
        transform: "rotate(45deg)"
      },
      "&:after": {
        transform: "rotate(-45deg)"
      },
      "&:hover": {
        transform: "scale(1.2)"
      }
    }
  };
};

var hamburgerIconStylesSharedInverted = function hamburgerIconStylesSharedInverted(theme) {
  var background = theme.colors.white;
  return {
    background: background,
    "&:before, &:after": {
      background: background
    },
    "&.active": {
      "&:before, &:after": {
        background: background
      }
    }
  };
};

var baseNavigationItemCss = function baseNavigationItemCss(theme) {
  return {
    display: "inline-flex",
    position: "relative",
    color: theme.colors.black,
    // Show dropdown menu on hover, if exists
    "&:hover > div": baseNavigationDropdownOpenStyles()
  };
};

var baseNavigationItemInvertedCss = function baseNavigationItemInvertedCss(theme) {
  return {
    color: theme.colors.white
  };
};

var baseNavigationDropdownStyles = function baseNavigationDropdownStyles(_theme, mobileNavMediaQuery) {
  return _defineProperty({
    display: "none",
    position: "absolute",
    top: "100%",
    left: "50%",
    transform: "translateX(-50%)"
  }, mobileNavMediaQuery, {
    position: "relative",
    left: "auto",
    transform: "none",
    top: "auto"
  });
};

var baseNavigationDropdownMeasureStyles = function baseNavigationDropdownMeasureStyles(_theme) {
  return {
    visibility: "hidden",
    display: "block"
  };
};

var baseNavigationDropdownOpenStyles = function baseNavigationDropdownOpenStyles(_theme) {
  return {
    display: "block"
  };
};

var baseNavigationDropdownListStyles = function baseNavigationDropdownListStyles(theme) {
  return {
    margin: 0,
    padding: "".concat(theme.space[4], " 0"),
    listStyle: "none"
  };
};

var baseNavigationDropdownToggleCss = function baseNavigationDropdownToggleCss(theme) {
  return {
    color: theme.colors.black,
    background: "inherit"
  };
};

var baseNavigationDropdownToggleInvertedCss = function baseNavigationDropdownToggleInvertedCss(theme) {
  return {
    color: theme.colors.white,
    background: 0
  };
};

var baseNavigationButtonCss = function baseNavigationButtonCss(theme) {
  return {
    fontSize: theme.fontSizes[2],
    fontWeight: "bold",
    background: theme.colors.gatsby,
    border: 0,
    color: theme.colors.white,
    ":focus, &:hover:not([disabled])": {
      background: theme.colors.purple[70],
      border: 0,
      color: theme.colors.white
    }
  };
};
var baseNavigationButtonInvertedCss = function baseNavigationButtonInvertedCss(theme) {
  return {
    background: theme.colors.white,
    border: "1px solid ".concat(theme.colors.purple[20]),
    color: theme.colors.purple[50],
    ":focus, &:hover:not([disabled])": {
      background: theme.colors.white,
      border: "1px solid ".concat(theme.colors.purple[60]),
      color: theme.colors.purple[60]
    }
  };
};
var baseStyles = {
  navigation: {
    "default": {
      width: "100%"
    }
  },
  hamburger: {
    "default": {
      display: "none"
    },
    mobile: {
      background: "none",
      border: 0,
      display: "block",
      marginLeft: "auto",
      marginTop: -6,
      padding: 0,
      position: "relative",
      zIndex: 22,
      cursor: "pointer",
      transition: "all 250ms cubic-bezier(0.4, 0, 0.2, 1)"
    }
  },
  hamburgerIcon: function hamburgerIcon(isInverted) {
    return function (theme) {
      return [hamburgerIconStylesShared(theme), isInverted && hamburgerIconStylesSharedInverted(theme)];
    };
  },
  nav: {
    "default": {},
    mobile: function mobile(isMobileNavOpen) {
      return function (_theme) {
        return {
          display: isMobileNavOpen ? "block " : "none"
        };
      };
    }
  },
  list: {
    wrapper: {
      width: "100%",
      display: "flex",
      justifyContent: "space-between"
    },
    spacer: {
      flex: 1
    },
    side: {
      listStyle: "none",
      margin: 0,
      padding: 0
    },
    leftSide: {
      display: "flex",
      justifyContent: "flex-start",
      flex: 1
    },
    rightSide: {
      display: "flex",
      justifyContent: "flex-end"
    }
  },
  item: function item(isInverted) {
    return function (theme) {
      return [baseNavigationItemCss(theme), isInverted && baseNavigationItemInvertedCss(theme)];
    };
  },
  dropdown: function dropdown(isDropdownOpen, isMeasured, mobileNavMediaQuery) {
    return function (theme) {
      return [baseNavigationDropdownStyles(theme, mobileNavMediaQuery), isMeasured && baseNavigationDropdownMeasureStyles(), isDropdownOpen && baseNavigationDropdownOpenStyles()];
    };
  },
  dropdownList: function dropdownList() {
    return function (theme) {
      return baseNavigationDropdownListStyles(theme);
    };
  },
  dropdownToggle: function dropdownToggle(isInverted) {
    return function (theme) {
      return [baseNavigationDropdownToggleCss(theme), isInverted && baseNavigationDropdownToggleInvertedCss(theme)];
    };
  },
  button: function button(isInverted) {
    return function (theme) {
      return [baseNavigationButtonCss(theme), isInverted && baseNavigationButtonInvertedCss(theme)];
    };
  }
};

var visuallyHiddenCss = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  width: "1px",
  margin: "-1px",
  padding: 0,
  overflow: "hidden",
  position: "absolute"
};

var BaseNavigationContext = React__default.createContext({});
var BaseNavigation = function BaseNavigation(_ref) {
  var _ref$items = _ref.items,
      items = _ref$items === void 0 ? [] : _ref$items,
      _ref$secondaryItems = _ref.secondaryItems,
      secondaryItems = _ref$secondaryItems === void 0 ? [] : _ref$secondaryItems,
      children = _ref.children,
      _ref$isInverted = _ref.isInverted,
      isInverted = _ref$isInverted === void 0 ? false : _ref$isInverted,
      _ref$mobileNavMediaQu = _ref.mobileNavMediaQuery,
      mobileNavMediaQuery = _ref$mobileNavMediaQu === void 0 ? "@media (max-width: 1065px)" : _ref$mobileNavMediaQu,
      customIsMobileNavOpen = _ref.isMobileNavOpen,
      customSetIsMobileNavOpen = _ref.setIsMobileNavOpen,
      _ref$Hamburger = _ref.Hamburger,
      Hamburger = _ref$Hamburger === void 0 ? BaseNavigationHamburger : _ref$Hamburger,
      _ref$HamburgerIcon = _ref.HamburgerIcon,
      HamburgerIcon = _ref$HamburgerIcon === void 0 ? BaseNavigationHamburgerIcon : _ref$HamburgerIcon,
      _ref$Nav = _ref.Nav,
      Nav = _ref$Nav === void 0 ? BaseNavigationNav : _ref$Nav,
      _ref$List = _ref.List,
      List = _ref$List === void 0 ? BaseNavigationList : _ref$List,
      _ref$Item = _ref.Item,
      Item = _ref$Item === void 0 ? BaseNavigationListItem : _ref$Item,
      _ref$ItemLink = _ref.ItemLink,
      ItemLink = _ref$ItemLink === void 0 ? BaseNavigationItemLink : _ref$ItemLink,
      _ref$ItemAnchor = _ref.ItemAnchor,
      ItemAnchor = _ref$ItemAnchor === void 0 ? BaseNavigationItemAnchor : _ref$ItemAnchor,
      _ref$Dropdown = _ref.Dropdown,
      Dropdown = _ref$Dropdown === void 0 ? BaseNavigationDropdown : _ref$Dropdown,
      _ref$DropdownItem = _ref.DropdownItem,
      DropdownItem = _ref$DropdownItem === void 0 ? BaseNavigationDropdownItem : _ref$DropdownItem,
      _ref$DropdownToggle = _ref.DropdownToggle,
      DropdownToggle = _ref$DropdownToggle === void 0 ? BaseNavigationDropdownToggle : _ref$DropdownToggle,
      _ref$LinkButton = _ref.LinkButton,
      LinkButton = _ref$LinkButton === void 0 ? BaseNavigationLinkButton : _ref$LinkButton,
      _ref$AnchorButton = _ref.AnchorButton,
      AnchorButton = _ref$AnchorButton === void 0 ? BaseNavigationAnchorButton : _ref$AnchorButton,
      rest = _objectWithoutProperties(_ref, ["items", "secondaryItems", "children", "isInverted", "mobileNavMediaQuery", "isMobileNavOpen", "setIsMobileNavOpen", "Hamburger", "HamburgerIcon", "Nav", "List", "Item", "ItemLink", "ItemAnchor", "Dropdown", "DropdownItem", "DropdownToggle", "LinkButton", "AnchorButton"]);

  var _React$useState = React__default.useState(false),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      internalIsMobileNavOpen = _React$useState2[0],
      internalSetIsMobileNavOpen = _React$useState2[1];

  var _React$useState3 = React__default.useState({}),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      dropdownOffsets = _React$useState4[0],
      setDropdownOffsets = _React$useState4[1];

  var isMobileNavOpen = internalIsMobileNavOpen;
  var setIsMobileNavOpen = internalSetIsMobileNavOpen;

  if (customIsMobileNavOpen !== undefined && customSetIsMobileNavOpen !== undefined) {
    isMobileNavOpen = customIsMobileNavOpen;
    setIsMobileNavOpen = customSetIsMobileNavOpen;
  }

  var value = {
    items: items,
    secondaryItems: secondaryItems,
    rootChildren: children,
    isInverted: isInverted,
    mobileNavMediaQuery: mobileNavMediaQuery,
    isMobileNavOpen: isMobileNavOpen,
    setIsMobileNavOpen: setIsMobileNavOpen,
    dropdownOffsets: dropdownOffsets,
    setDropdownOffsets: setDropdownOffsets,
    components: {
      Hamburger: Hamburger,
      HamburgerIcon: HamburgerIcon,
      Nav: Nav,
      List: List,
      Item: Item,
      ItemLink: ItemLink,
      ItemAnchor: ItemAnchor,
      Dropdown: Dropdown,
      DropdownItem: DropdownItem,
      DropdownToggle: DropdownToggle,
      LinkButton: LinkButton,
      AnchorButton: AnchorButton
    }
  };
  return core.jsx(BaseNavigationContext.Provider, {
    value: value
  }, core.jsx("div", _extends({
    css: baseStyles.navigation["default"]
  }, rest), core.jsx(Hamburger, null), core.jsx(Nav, null)));
};
BaseNavigation.propTypes = {
  items: _pt__default.arrayOf(_pt__default.oneOfType([_pt__default.shape({
    name: _pt__default.string.isRequired,
    linkTo: _pt__default.string.isRequired
  }), _pt__default.shape({
    items: _pt__default.arrayOf(_pt__default.shape({
      name: _pt__default.string.isRequired,
      linkTo: _pt__default.string.isRequired
    }))
  })])),
  secondaryItems: _pt__default.arrayOf(_pt__default.oneOfType([_pt__default.shape({
    name: _pt__default.string.isRequired,
    linkTo: _pt__default.string.isRequired
  }), _pt__default.shape({
    items: _pt__default.arrayOf(_pt__default.shape({
      name: _pt__default.string.isRequired,
      linkTo: _pt__default.string.isRequired
    }))
  })])),
  isInverted: _pt__default.bool,
  mobileNavMediaQuery: _pt__default.string,
  isMobileNavOpen: _pt__default.bool,
  setIsMobileNavOpen: _pt__default.func
};
var BaseNavigationHamburger = React__default.forwardRef(function BaseNavigationHamburger(props, ref) {
  var _BaseNavigation$useNa = BaseNavigation.useNavigationContext(),
      mobileNavMediaQuery = _BaseNavigation$useNa.mobileNavMediaQuery,
      isMobileNavOpen = _BaseNavigation$useNa.isMobileNavOpen,
      setIsMobileNavOpen = _BaseNavigation$useNa.setIsMobileNavOpen,
      HamburgerIcon = _BaseNavigation$useNa.components.HamburgerIcon;

  return core.jsx("button", _extends({
    onClick: function onClick() {
      setIsMobileNavOpen(!isMobileNavOpen);
    },
    "aria-expanded": isMobileNavOpen,
    css: _objectSpread2({}, baseStyles.hamburger["default"], _defineProperty({}, mobileNavMediaQuery, baseStyles.hamburger.mobile))
  }, props, {
    "aria-label": "".concat(isMobileNavOpen ? "Close" : "Open", " the menu"),
    ref: ref
  }), core.jsx(HamburgerIcon, null));
});
BaseNavigation.Hamburger = BaseNavigationHamburger;
function BaseNavigationHamburgerIcon(props) {
  var _BaseNavigation$useNa2 = BaseNavigation.useNavigationContext(),
      isInverted = _BaseNavigation$useNa2.isInverted,
      isMobileNavOpen = _BaseNavigation$useNa2.isMobileNavOpen;

  return core.jsx("div", _extends({
    className: isMobileNavOpen ? "active" : "",
    css: baseStyles.hamburgerIcon(isInverted)
  }, props));
}
BaseNavigation.HamburgerIcon = BaseNavigationHamburgerIcon;
function BaseNavigationNav(props) {
  var _BaseNavigation$useNa3 = BaseNavigation.useNavigationContext(),
      mobileNavMediaQuery = _BaseNavigation$useNa3.mobileNavMediaQuery,
      isMobileNavOpen = _BaseNavigation$useNa3.isMobileNavOpen,
      List = _BaseNavigation$useNa3.components.List;

  return core.jsx("nav", _extends({
    css: function css(theme) {
      return _defineProperty({}, mobileNavMediaQuery, baseStyles.nav.mobile(isMobileNavOpen)(theme));
    }
  }, props), core.jsx(List, null));
}
BaseNavigation.Nav = BaseNavigationNav;
function BaseNavigationList(props) {
  var _useBaseNavigationCon = useBaseNavigationContext(),
      items = _useBaseNavigationCon.items,
      secondaryItems = _useBaseNavigationCon.secondaryItems,
      rootChildren = _useBaseNavigationCon.rootChildren,
      Item = _useBaseNavigationCon.components.Item;

  return core.jsx("div", {
    css: baseStyles.list.wrapper
  }, core.jsx("ul", _extends({
    css: [baseStyles.list.side, baseStyles.list.leftSide]
  }, props), items.length > 0 && items.map(function (item) {
    return core.jsx(Item, {
      key: item.name,
      item: item
    });
  }), core.jsx("li", {
    role: "separator",
    css: baseStyles.list.spacer
  }), secondaryItems.length > 0 && secondaryItems.map(function (item) {
    return core.jsx(Item, {
      key: item.name,
      item: item
    });
  }), rootChildren && rootChildren));
}
BaseNavigation.List = BaseNavigationList;
function BaseNavigationListItem(_ref3) {
  var item = _ref3.item,
      children = _ref3.children,
      rest = _objectWithoutProperties(_ref3, ["item", "children"]);

  var _React$useState5 = React__default.useState(false),
      _React$useState6 = _slicedToArray(_React$useState5, 2),
      isDropdownOpen = _React$useState6[0],
      toggleDropdown = _React$useState6[1];

  var dropdownItems = item.items || [];
  var dropdownChildren = children || false;
  var itemHasDropdown = dropdownItems.length > 0 || dropdownChildren;
  var ref = React__default.useRef(null); // Call hook passing in the ref and a function to call on outside click

  useOnClickOutside(ref, function () {
    if (itemHasDropdown) {
      toggleDropdown(false);
    }
  });

  var _BaseNavigation$useNa4 = BaseNavigation.useNavigationContext(),
      isInverted = _BaseNavigation$useNa4.isInverted,
      _BaseNavigation$useNa5 = _BaseNavigation$useNa4.components,
      ItemLink = _BaseNavigation$useNa5.ItemLink,
      DropdownToggle = _BaseNavigation$useNa5.DropdownToggle,
      Dropdown = _BaseNavigation$useNa5.Dropdown;

  return core.jsx("li", _extends({
    ref: ref,
    css: baseStyles.item(isInverted)
  }, rest), core.jsx(ItemLink, {
    item: item
  }), itemHasDropdown && core.jsx(React__default.Fragment, null, core.jsx(DropdownToggle, {
    item: item,
    isDropdownOpen: isDropdownOpen,
    toggleDropdown: toggleDropdown
  }), core.jsx(Dropdown, {
    item: item,
    isDropdownOpen: isDropdownOpen,
    toggleDropdown: toggleDropdown,
    dropdownItems: item.items,
    dropdownChildren: dropdownChildren
  })));
}
BaseNavigationListItem.propTypes = {
  item: _pt__default.oneOfType([_pt__default.shape({
    name: _pt__default.string.isRequired,
    linkTo: _pt__default.string.isRequired
  }), _pt__default.shape({
    items: _pt__default.arrayOf(_pt__default.shape({
      name: _pt__default.string.isRequired,
      linkTo: _pt__default.string.isRequired
    }))
  })]).isRequired
};
BaseNavigation.Item = BaseNavigationListItem;
function BaseNavigationItemAnchor(_ref4) {
  var item = _ref4.item,
      rest = _objectWithoutProperties(_ref4, ["item"]);

  return core.jsx(BaseAnchor, _extends({
    href: item.linkTo
  }, rest), core.jsx("span", null, item.name));
}
BaseNavigationItemAnchor.propTypes = {
  item: _pt__default.shape({
    name: _pt__default.string.isRequired,
    linkTo: _pt__default.string.isRequired
  }).isRequired
};
BaseNavigation.ItemAnchor = BaseNavigationItemAnchor;
function BaseNavigationItemLink(_ref5) {
  var item = _ref5.item,
      rest = _objectWithoutProperties(_ref5, ["item"]);

  var _BaseNavigation$useNa6 = BaseNavigation.useNavigationContext(),
      setIsMobileNavOpen = _BaseNavigation$useNa6.setIsMobileNavOpen;

  return core.jsx(gatsby.Link, _extends({
    activeClassName: "nav-item-active",
    to: item.linkTo,
    onClick: function onClick() {
      return setIsMobileNavOpen(false);
    }
  }, rest), core.jsx("span", null, item.name));
}
BaseNavigationItemLink.propTypes = {
  item: _pt__default.shape({
    name: _pt__default.string.isRequired,
    linkTo: _pt__default.string.isRequired
  }).isRequired
};
BaseNavigation.ItemLink = BaseNavigationItemLink;
var BaseNavigationDropdownToggle = React__default.forwardRef(function BaseNavigationDropdownToggle(_ref6, ref) {
  var item = _ref6.item,
      isDropdownOpen = _ref6.isDropdownOpen,
      toggleDropdown = _ref6.toggleDropdown,
      rest = _objectWithoutProperties(_ref6, ["item", "isDropdownOpen", "toggleDropdown"]);

  var _BaseNavigation$useNa7 = BaseNavigation.useNavigationContext(),
      isInverted = _BaseNavigation$useNa7.isInverted;

  return core.jsx("button", _extends({
    ref: ref,
    "aria-expanded": !!isDropdownOpen,
    "aria-controls": getDropdownId(item.name),
    onClick: function onClick() {
      toggleDropdown(!isDropdownOpen);
    },
    css: baseStyles.dropdownToggle(isInverted)
  }, rest), core.jsx("span", {
    "aria-hidden": "true"
  }, "\u2228"), core.jsx("span", {
    css: visuallyHiddenCss
  }, "".concat(item.name, " Menu")));
});
BaseNavigationDropdownToggle.propTypes = {
  item: _pt__default.shape({
    name: _pt__default.string.isRequired,
    linkTo: _pt__default.string.isRequired
  }).isRequired,
  isDropdownOpen: _pt__default.bool.isRequired,
  toggleDropdown: _pt__default.func.isRequired
};
BaseNavigation.DropdownToggle = BaseNavigationDropdownToggle;
function BaseNavigationDropdown(_ref7) {
  var item = _ref7.item,
      isDropdownOpen = _ref7.isDropdownOpen,
      toggleDropdown = _ref7.toggleDropdown,
      _ref7$dropdownItems = _ref7.dropdownItems,
      dropdownItems = _ref7$dropdownItems === void 0 ? [] : _ref7$dropdownItems,
      _ref7$dropdownChildre = _ref7.dropdownChildren,
      dropdownChildren = _ref7$dropdownChildre === void 0 ? false : _ref7$dropdownChildre,
      dropdownListClassName = _ref7.dropdownListClassName,
      rest = _objectWithoutProperties(_ref7, ["item", "isDropdownOpen", "toggleDropdown", "dropdownItems", "dropdownChildren", "dropdownListClassName"]);

  var dropdownRef = React__default.useRef(null);

  var _BaseNavigation$useNa8 = BaseNavigation.useNavigationContext(),
      DropdownItem = _BaseNavigation$useNa8.components.DropdownItem,
      setDropdownOffsets = _BaseNavigation$useNa8.setDropdownOffsets,
      mobileNavMediaQuery = _BaseNavigation$useNa8.mobileNavMediaQuery;

  var _React$useState7 = React__default.useState(false),
      _React$useState8 = _slicedToArray(_React$useState7, 2),
      isMeasured = _React$useState8[0],
      setIsMeasured = _React$useState8[1];

  var _React$useState9 = React__default.useState(0),
      _React$useState10 = _slicedToArray(_React$useState9, 2),
      windowWidth = _React$useState10[0],
      setWindowWidth = _React$useState10[1];

  var VIEWPORT_FIT_MARGIN = 20;
  React__default.useEffect(function () {
    setIsMeasured(true);
    setWindowWidth(window.innerWidth || document.documentElement.clientWidth);
  }, []);
  React__default.useEffect(function () {
    if (dropdownRef.current && isMeasured) {
      var _dropdownRef$current$ = dropdownRef.current.getBoundingClientRect(),
          left = _dropdownRef$current$.left,
          right = _dropdownRef$current$.right;

      setIsMeasured(false);
      var leftFit = left >= VIEWPORT_FIT_MARGIN;
      var rightFit = right <= windowWidth - VIEWPORT_FIT_MARGIN;
      var offset = !leftFit ? (left - VIEWPORT_FIT_MARGIN) * -1 : !rightFit ? windowWidth - (right + VIEWPORT_FIT_MARGIN) : 0;
      setDropdownOffsets(function (state) {
        return _objectSpread2({}, state, _defineProperty({}, item.name, offset));
      });
    }
  }, [isMeasured]);
  return core.jsx("div", _extends({
    ref: dropdownRef,
    css: baseStyles.dropdown(isDropdownOpen, isMeasured, mobileNavMediaQuery) // id to associate with aria-controls on BaseNavigation.Item
    ,
    id: getDropdownId(item.name),
    onKeyDown: function onKeyDown(e) {
      // handle closing dropdown on `esc`
      if (e.keyCode === 27) {
        toggleDropdown(false);
      }

      return;
    }
  }, rest), core.jsx("ul", {
    css: baseStyles.dropdownList(),
    className: dropdownListClassName
  }, dropdownItems.length > 0 && dropdownItems.map(function (item, index) {
    return core.jsx(DropdownItem, {
      key: "".concat(index, "-").concat(item.name),
      item: item
    });
  }), dropdownChildren && dropdownChildren));
}
BaseNavigationDropdown.propTypes = {
  item: _pt__default.shape({
    name: _pt__default.string.isRequired,
    linkTo: _pt__default.string.isRequired
  }).isRequired,
  isDropdownOpen: _pt__default.bool.isRequired,
  toggleDropdown: _pt__default.func.isRequired,
  dropdownItems: _pt__default.arrayOf(_pt__default.shape({
    name: _pt__default.string.isRequired,
    linkTo: _pt__default.string.isRequired
  })),
  dropdownChildren: _pt__default.node,
  dropdownListClassName: _pt__default.string
};
BaseNavigation.Dropdown = BaseNavigationDropdown;
function BaseNavigationDropdownItem(_ref8) {
  var _ref8$item = _ref8.item,
      name = _ref8$item.name,
      linkTo = _ref8$item.linkTo,
      rest = _objectWithoutProperties(_ref8, ["item"]);

  var _BaseNavigation$useNa9 = BaseNavigation.useNavigationContext(),
      setIsMobileNavOpen = _BaseNavigation$useNa9.setIsMobileNavOpen;

  return core.jsx("li", rest, core.jsx(gatsby.Link, {
    activeClassName: "nav-item-active",
    to: linkTo,
    onClick: function onClick() {
      return setIsMobileNavOpen(false);
    }
  }, name));
}
BaseNavigationDropdownItem.propTypes = {
  item: _pt__default.shape({
    name: _pt__default.string.isRequired,
    linkTo: _pt__default.string.isRequired
  }).isRequired
};
BaseNavigation.DropdownItem = BaseNavigationDropdownItem;
function BaseNavigationLinkButton(_ref9) {
  var linkTo = _ref9.linkTo,
      _ref9$icon = _ref9.icon,
      icon = _ref9$icon === void 0 ? true : _ref9$icon,
      _ref9$size = _ref9.size,
      size = _ref9$size === void 0 ? "M" : _ref9$size,
      children = _ref9.children,
      rest = _objectWithoutProperties(_ref9, ["linkTo", "icon", "size", "children"]);

  var _BaseNavigation$useNa10 = BaseNavigation.useNavigationContext(),
      isInverted = _BaseNavigation$useNa10.isInverted;

  return core.jsx(LinkButton, _extends({
    to: linkTo,
    size: size,
    css: baseStyles.button(isInverted),
    rightIcon: icon ? core.jsx(md.MdArrowForward, null) : undefined
  }, rest), children);
}
BaseNavigationLinkButton.propTypes = {
  icon: _pt__default.bool,
  linkTo: _pt__default.string
};
BaseNavigation.LinkButton = BaseNavigationLinkButton;
var BaseNavigationAnchorButton = React__default.forwardRef(function BaseNavigationAnchorButton(_ref10, ref) {
  var linkTo = _ref10.linkTo,
      _ref10$icon = _ref10.icon,
      icon = _ref10$icon === void 0 ? true : _ref10$icon,
      _ref10$size = _ref10.size,
      size = _ref10$size === void 0 ? "M" : _ref10$size,
      children = _ref10.children,
      rest = _objectWithoutProperties(_ref10, ["linkTo", "icon", "size", "children"]);

  var _BaseNavigation$useNa11 = BaseNavigation.useNavigationContext(),
      isInverted = _BaseNavigation$useNa11.isInverted;

  return core.jsx(AnchorButton, _extends({
    ref: ref,
    href: linkTo,
    size: size,
    css: baseStyles.button(isInverted),
    rightIcon: icon ? core.jsx(md.MdArrowForward, null) : undefined
  }, rest), children);
});
BaseNavigationAnchorButton.propTypes = {
  icon: _pt__default.bool,
  linkTo: _pt__default.string
};
BaseNavigation.AnchorButton = BaseNavigationAnchorButton;
function useBaseNavigationContext() {
  var context = React__default.useContext(BaseNavigationContext);

  if (!context) {
    throw new Error("BaseNavigation compound components cannot be rendered outside the BaseNavigation component");
  }

  return context;
}
BaseNavigation.useNavigationContext = useBaseNavigationContext;

function getDropdownId(itemName) {
  // Strip item name (i.e. label) from special characters
  return "".concat(itemName.replace(/[^\w]/gi, "-"), "-dropdown");
}

BaseNavigation.__docgenInfo = {
  "description": "",
  "methods": [{
    "name": "HamburgerIcon",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "props",
      "optional": false,
      "type": {
        "name": "Omit",
        "elements": [{
          "name": "JSX.IntrinsicElements[\"div\"]",
          "raw": "JSX.IntrinsicElements[\"div\"]"
        }, {
          "name": "literal",
          "value": "\"ref\""
        }],
        "raw": "Omit<\n  JSX.IntrinsicElements[\"div\"],\n  \"ref\"\n>",
        "alias": "BaseNavigationHamburgerIconProps"
      }
    }],
    "returns": null
  }, {
    "name": "Nav",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "props",
      "optional": false,
      "type": {
        "name": "Omit",
        "elements": [{
          "name": "JSX.IntrinsicElements[\"nav\"]",
          "raw": "JSX.IntrinsicElements[\"nav\"]"
        }, {
          "name": "literal",
          "value": "\"ref\""
        }],
        "raw": "Omit<JSX.IntrinsicElements[\"nav\"], \"ref\">",
        "alias": "BaseNavigationNavProps"
      }
    }],
    "returns": null
  }, {
    "name": "List",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "props",
      "optional": false,
      "type": {
        "name": "Omit",
        "elements": [{
          "name": "JSX.IntrinsicElements[\"ul\"]",
          "raw": "JSX.IntrinsicElements[\"ul\"]"
        }, {
          "name": "literal",
          "value": "\"ref\""
        }],
        "raw": "Omit<JSX.IntrinsicElements[\"ul\"], \"ref\">",
        "alias": "BaseNavigationListProps"
      }
    }],
    "returns": null
  }, {
    "name": "Item",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "{\n  item,\n  children,\n  ...rest\n}: BaseNavigationListItemProps",
      "type": {
        "name": "intersection",
        "raw": "Omit<\n  JSX.IntrinsicElements[\"li\"],\n  \"ref\"\n> & {\n  item: BaseNavigationItemOptions\n}",
        "elements": [{
          "name": "Omit",
          "elements": [{
            "name": "JSX.IntrinsicElements[\"li\"]",
            "raw": "JSX.IntrinsicElements[\"li\"]"
          }, {
            "name": "literal",
            "value": "\"ref\""
          }],
          "raw": "Omit<\n  JSX.IntrinsicElements[\"li\"],\n  \"ref\"\n>"
        }, {
          "name": "signature",
          "type": "object",
          "raw": "{\n  item: BaseNavigationItemOptions\n}",
          "signature": {
            "properties": [{
              "key": "item",
              "value": {
                "name": "intersection",
                "raw": "BaseNavigationItem & {\n  items?: BaseNavigationItem[]\n}",
                "elements": [{
                  "name": "signature",
                  "type": "object",
                  "raw": "{\n  name: string\n  linkTo: string\n}",
                  "signature": {
                    "properties": [{
                      "key": "name",
                      "value": {
                        "name": "string",
                        "required": true
                      }
                    }, {
                      "key": "linkTo",
                      "value": {
                        "name": "string",
                        "required": true
                      }
                    }]
                  }
                }, {
                  "name": "signature",
                  "type": "object",
                  "raw": "{\n  items?: BaseNavigationItem[]\n}",
                  "signature": {
                    "properties": [{
                      "key": "items",
                      "value": {
                        "name": "Array",
                        "elements": [{
                          "name": "signature",
                          "type": "object",
                          "raw": "{\n  name: string\n  linkTo: string\n}",
                          "signature": {
                            "properties": [{
                              "key": "name",
                              "value": {
                                "name": "string",
                                "required": true
                              }
                            }, {
                              "key": "linkTo",
                              "value": {
                                "name": "string",
                                "required": true
                              }
                            }]
                          }
                        }],
                        "raw": "BaseNavigationItem[]",
                        "required": false
                      }
                    }]
                  }
                }],
                "required": true
              }
            }]
          }
        }],
        "alias": "BaseNavigationListItemProps"
      }
    }],
    "returns": null
  }, {
    "name": "ItemAnchor",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "{\n  item,\n  ...rest\n}: BaseNavigationItemAnchorProps",
      "type": {
        "name": "intersection",
        "raw": "Omit<BaseAnchorProps, \"ref\"> & {\n  item: BaseNavigationItem\n}",
        "elements": [{
          "name": "Omit",
          "elements": [{
            "name": "BaseAnchorProps"
          }, {
            "name": "literal",
            "value": "\"ref\""
          }],
          "raw": "Omit<BaseAnchorProps, \"ref\">"
        }, {
          "name": "signature",
          "type": "object",
          "raw": "{\n  item: BaseNavigationItem\n}",
          "signature": {
            "properties": [{
              "key": "item",
              "value": {
                "name": "signature",
                "type": "object",
                "raw": "{\n  name: string\n  linkTo: string\n}",
                "signature": {
                  "properties": [{
                    "key": "name",
                    "value": {
                      "name": "string",
                      "required": true
                    }
                  }, {
                    "key": "linkTo",
                    "value": {
                      "name": "string",
                      "required": true
                    }
                  }]
                },
                "required": true
              }
            }]
          }
        }],
        "alias": "BaseNavigationItemAnchorProps"
      }
    }],
    "returns": null
  }, {
    "name": "ItemLink",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "{\n  item,\n  ...rest\n}: BaseNavigationItemLinkProps",
      "type": {
        "name": "intersection",
        "raw": "Omit<GatsbyLinkProps<any>, \"ref\"> & {\n  item: BaseNavigationItem\n}",
        "elements": [{
          "name": "Omit",
          "elements": [{
            "name": "GatsbyLinkProps",
            "elements": [{
              "name": "any"
            }],
            "raw": "GatsbyLinkProps<any>"
          }, {
            "name": "literal",
            "value": "\"ref\""
          }],
          "raw": "Omit<GatsbyLinkProps<any>, \"ref\">"
        }, {
          "name": "signature",
          "type": "object",
          "raw": "{\n  item: BaseNavigationItem\n}",
          "signature": {
            "properties": [{
              "key": "item",
              "value": {
                "name": "signature",
                "type": "object",
                "raw": "{\n  name: string\n  linkTo: string\n}",
                "signature": {
                  "properties": [{
                    "key": "name",
                    "value": {
                      "name": "string",
                      "required": true
                    }
                  }, {
                    "key": "linkTo",
                    "value": {
                      "name": "string",
                      "required": true
                    }
                  }]
                },
                "required": true
              }
            }]
          }
        }],
        "alias": "BaseNavigationItemLinkProps"
      }
    }],
    "returns": null
  }, {
    "name": "Dropdown",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "{\n  item,\n  isDropdownOpen,\n  toggleDropdown,\n  dropdownItems = [],\n  dropdownChildren = false,\n  dropdownListClassName,\n  ...rest\n}: BaseNavigationDropdownProps",
      "type": {
        "name": "intersection",
        "raw": "Omit<\n  JSX.IntrinsicElements[\"div\"],\n  \"ref\"\n> & {\n  item: BaseNavigationItem\n  isDropdownOpen: boolean\n  toggleDropdown: (value: boolean) => void\n  dropdownItems?: BaseNavigationItem[]\n  dropdownChildren?: React.ReactNode\n  dropdownListClassName?: string\n}",
        "elements": [{
          "name": "Omit",
          "elements": [{
            "name": "JSX.IntrinsicElements[\"div\"]",
            "raw": "JSX.IntrinsicElements[\"div\"]"
          }, {
            "name": "literal",
            "value": "\"ref\""
          }],
          "raw": "Omit<\n  JSX.IntrinsicElements[\"div\"],\n  \"ref\"\n>"
        }, {
          "name": "signature",
          "type": "object",
          "raw": "{\n  item: BaseNavigationItem\n  isDropdownOpen: boolean\n  toggleDropdown: (value: boolean) => void\n  dropdownItems?: BaseNavigationItem[]\n  dropdownChildren?: React.ReactNode\n  dropdownListClassName?: string\n}",
          "signature": {
            "properties": [{
              "key": "item",
              "value": {
                "name": "signature",
                "type": "object",
                "raw": "{\n  name: string\n  linkTo: string\n}",
                "signature": {
                  "properties": [{
                    "key": "name",
                    "value": {
                      "name": "string",
                      "required": true
                    }
                  }, {
                    "key": "linkTo",
                    "value": {
                      "name": "string",
                      "required": true
                    }
                  }]
                },
                "required": true
              }
            }, {
              "key": "isDropdownOpen",
              "value": {
                "name": "boolean",
                "required": true
              }
            }, {
              "key": "toggleDropdown",
              "value": {
                "name": "signature",
                "type": "function",
                "raw": "(value: boolean) => void",
                "signature": {
                  "arguments": [{
                    "name": "value",
                    "type": {
                      "name": "boolean"
                    }
                  }],
                  "return": {
                    "name": "void"
                  }
                },
                "required": true
              }
            }, {
              "key": "dropdownItems",
              "value": {
                "name": "Array",
                "elements": [{
                  "name": "signature",
                  "type": "object",
                  "raw": "{\n  name: string\n  linkTo: string\n}",
                  "signature": {
                    "properties": [{
                      "key": "name",
                      "value": {
                        "name": "string",
                        "required": true
                      }
                    }, {
                      "key": "linkTo",
                      "value": {
                        "name": "string",
                        "required": true
                      }
                    }]
                  },
                  "required": true
                }],
                "raw": "BaseNavigationItem[]",
                "required": false
              }
            }, {
              "key": "dropdownChildren",
              "value": {
                "name": "ReactReactNode",
                "raw": "React.ReactNode",
                "required": false
              }
            }, {
              "key": "dropdownListClassName",
              "value": {
                "name": "string",
                "required": false
              }
            }]
          }
        }],
        "alias": "BaseNavigationDropdownProps"
      }
    }],
    "returns": null
  }, {
    "name": "DropdownItem",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "{\n  item: { name, linkTo },\n  ...rest\n}: BaseNavigationDropdownItemProps",
      "type": {
        "name": "intersection",
        "raw": "Omit<\n  JSX.IntrinsicElements[\"li\"],\n  \"ref\"\n> & {\n  item: BaseNavigationItem\n}",
        "elements": [{
          "name": "Omit",
          "elements": [{
            "name": "JSX.IntrinsicElements[\"li\"]",
            "raw": "JSX.IntrinsicElements[\"li\"]"
          }, {
            "name": "literal",
            "value": "\"ref\""
          }],
          "raw": "Omit<\n  JSX.IntrinsicElements[\"li\"],\n  \"ref\"\n>"
        }, {
          "name": "signature",
          "type": "object",
          "raw": "{\n  item: BaseNavigationItem\n}",
          "signature": {
            "properties": [{
              "key": "item",
              "value": {
                "name": "signature",
                "type": "object",
                "raw": "{\n  name: string\n  linkTo: string\n}",
                "signature": {
                  "properties": [{
                    "key": "name",
                    "value": {
                      "name": "string",
                      "required": true
                    }
                  }, {
                    "key": "linkTo",
                    "value": {
                      "name": "string",
                      "required": true
                    }
                  }]
                },
                "required": true
              }
            }]
          }
        }],
        "alias": "BaseNavigationDropdownItemProps"
      }
    }],
    "returns": null
  }, {
    "name": "LinkButton",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "{\n  linkTo,\n  icon = true,\n  size = `M`,\n  children,\n  ...rest\n}: BaseNavigationLinkButtonProps",
      "type": {
        "name": "intersection",
        "raw": "LinkButtonProps & {\n  icon?: boolean\n  linkTo?: string\n}",
        "elements": [{
          "name": "LinkButtonProps"
        }, {
          "name": "signature",
          "type": "object",
          "raw": "{\n  icon?: boolean\n  linkTo?: string\n}",
          "signature": {
            "properties": [{
              "key": "icon",
              "value": {
                "name": "boolean",
                "required": false
              }
            }, {
              "key": "linkTo",
              "value": {
                "name": "string",
                "required": false
              }
            }]
          }
        }],
        "alias": "BaseNavigationLinkButtonProps"
      }
    }],
    "returns": null
  }, {
    "name": "useNavigationContext",
    "docblock": null,
    "modifiers": ["static"],
    "params": [],
    "returns": null
  }],
  "displayName": "BaseNavigation",
  "props": {
    "items": {
      "defaultValue": {
        "value": "[]",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "Array",
        "elements": [{
          "name": "intersection",
          "raw": "BaseNavigationItem & {\n  items?: BaseNavigationItem[]\n}",
          "elements": [{
            "name": "signature",
            "type": "object",
            "raw": "{\n  name: string\n  linkTo: string\n}",
            "signature": {
              "properties": [{
                "key": "name",
                "value": {
                  "name": "string",
                  "required": true
                }
              }, {
                "key": "linkTo",
                "value": {
                  "name": "string",
                  "required": true
                }
              }]
            }
          }, {
            "name": "signature",
            "type": "object",
            "raw": "{\n  items?: BaseNavigationItem[]\n}",
            "signature": {
              "properties": [{
                "key": "items",
                "value": {
                  "name": "Array",
                  "elements": [{
                    "name": "signature",
                    "type": "object",
                    "raw": "{\n  name: string\n  linkTo: string\n}",
                    "signature": {
                      "properties": [{
                        "key": "name",
                        "value": {
                          "name": "string",
                          "required": true
                        }
                      }, {
                        "key": "linkTo",
                        "value": {
                          "name": "string",
                          "required": true
                        }
                      }]
                    }
                  }],
                  "raw": "BaseNavigationItem[]",
                  "required": false
                }
              }]
            }
          }]
        }],
        "raw": "BaseNavigationItemOptions[]"
      },
      "description": ""
    },
    "secondaryItems": {
      "defaultValue": {
        "value": "[]",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "Array",
        "elements": [{
          "name": "intersection",
          "raw": "BaseNavigationItem & {\n  items?: BaseNavigationItem[]\n}",
          "elements": [{
            "name": "signature",
            "type": "object",
            "raw": "{\n  name: string\n  linkTo: string\n}",
            "signature": {
              "properties": [{
                "key": "name",
                "value": {
                  "name": "string",
                  "required": true
                }
              }, {
                "key": "linkTo",
                "value": {
                  "name": "string",
                  "required": true
                }
              }]
            }
          }, {
            "name": "signature",
            "type": "object",
            "raw": "{\n  items?: BaseNavigationItem[]\n}",
            "signature": {
              "properties": [{
                "key": "items",
                "value": {
                  "name": "Array",
                  "elements": [{
                    "name": "signature",
                    "type": "object",
                    "raw": "{\n  name: string\n  linkTo: string\n}",
                    "signature": {
                      "properties": [{
                        "key": "name",
                        "value": {
                          "name": "string",
                          "required": true
                        }
                      }, {
                        "key": "linkTo",
                        "value": {
                          "name": "string",
                          "required": true
                        }
                      }]
                    }
                  }],
                  "raw": "BaseNavigationItem[]",
                  "required": false
                }
              }]
            }
          }]
        }],
        "raw": "BaseNavigationItemOptions[]"
      },
      "description": ""
    },
    "isInverted": {
      "defaultValue": {
        "value": "false",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "boolean"
      },
      "description": ""
    },
    "mobileNavMediaQuery": {
      "defaultValue": {
        "value": "`@media (max-width: 1065px)`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "Hamburger": {
      "defaultValue": {
        "value": "React.forwardRef<\n  HTMLButtonElement,\n  BaseNavigationHamburgerProps\n>(function BaseNavigationHamburger(props, ref) {\n  const {\n    mobileNavMediaQuery,\n    isMobileNavOpen,\n    setIsMobileNavOpen,\n\n    components: { HamburgerIcon },\n  } = BaseNavigation.useNavigationContext()\n\n  return (\n    <button\n      onClick={() => {\n        setIsMobileNavOpen(!isMobileNavOpen)\n      }}\n      aria-expanded={isMobileNavOpen}\n      css={{\n        ...baseStyles.hamburger.default,\n        [mobileNavMediaQuery]: baseStyles.hamburger.mobile,\n      }}\n      {...props}\n      aria-label={`${isMobileNavOpen ? \"Close\" : \"Open\"} the menu`}\n      ref={ref}\n    >\n      <HamburgerIcon />\n    </button>\n  )\n})",
        "computed": true
      },
      "required": false
    },
    "HamburgerIcon": {
      "defaultValue": {
        "value": "function BaseNavigationHamburgerIcon(\n  props: BaseNavigationHamburgerIconProps\n) {\n  const { isInverted, isMobileNavOpen } = BaseNavigation.useNavigationContext()\n\n  return (\n    <div\n      className={isMobileNavOpen ? `active` : ``}\n      css={baseStyles.hamburgerIcon(isInverted)}\n      {...props}\n    />\n  )\n}",
        "computed": false
      },
      "required": false
    },
    "Nav": {
      "defaultValue": {
        "value": "function BaseNavigationNav(props: BaseNavigationNavProps) {\n  const {\n    mobileNavMediaQuery,\n    isMobileNavOpen,\n    components: { List },\n  } = BaseNavigation.useNavigationContext()\n\n  return (\n    <nav\n      css={theme => ({\n        [mobileNavMediaQuery]: baseStyles.nav.mobile(isMobileNavOpen)(theme),\n      })}\n      {...props}\n    >\n      <List />\n    </nav>\n  )\n}",
        "computed": false
      },
      "required": false
    },
    "List": {
      "defaultValue": {
        "value": "function BaseNavigationList(props: BaseNavigationListProps) {\n  const {\n    items,\n    secondaryItems,\n    rootChildren,\n    components: { Item },\n  } = useBaseNavigationContext()\n\n  return (\n    <div css={baseStyles.list.wrapper}>\n      <ul css={[baseStyles.list.side, baseStyles.list.leftSide]} {...props}>\n        {items.length > 0 &&\n          items.map(item => <Item key={item.name} item={item} />)}\n        <li role=\"separator\" css={baseStyles.list.spacer} />\n        {secondaryItems.length > 0 &&\n          secondaryItems.map(item => <Item key={item.name} item={item} />)}\n        {rootChildren && rootChildren}\n      </ul>\n    </div>\n  )\n}",
        "computed": false
      },
      "required": false
    },
    "Item": {
      "defaultValue": {
        "value": "function BaseNavigationListItem({\n  item,\n  children,\n  ...rest\n}: BaseNavigationListItemProps) {\n  const [isDropdownOpen, toggleDropdown] = React.useState(false)\n  const dropdownItems = item.items || []\n  const dropdownChildren = children || false\n  const itemHasDropdown = dropdownItems.length > 0 || dropdownChildren\n\n  const ref = React.useRef<HTMLLIElement>(null)\n\n  // Call hook passing in the ref and a function to call on outside click\n  useOnClickOutside(ref, () => {\n    if (itemHasDropdown) {\n      toggleDropdown(false)\n    }\n  })\n\n  const {\n    isInverted,\n    components: { ItemLink, DropdownToggle, Dropdown },\n  } = BaseNavigation.useNavigationContext()\n\n  return (\n    <li ref={ref} css={baseStyles.item(isInverted)} {...rest}>\n      <ItemLink item={item} />\n      {itemHasDropdown && (\n        <React.Fragment>\n          <DropdownToggle\n            item={item}\n            isDropdownOpen={isDropdownOpen}\n            toggleDropdown={toggleDropdown}\n          />\n          <Dropdown\n            item={item}\n            isDropdownOpen={isDropdownOpen}\n            toggleDropdown={toggleDropdown}\n            dropdownItems={item.items}\n            dropdownChildren={dropdownChildren}\n          />\n        </React.Fragment>\n      )}\n    </li>\n  )\n}",
        "computed": false
      },
      "required": false
    },
    "ItemLink": {
      "defaultValue": {
        "value": "function BaseNavigationItemLink({\n  item,\n  ...rest\n}: BaseNavigationItemLinkProps) {\n  const { setIsMobileNavOpen } = BaseNavigation.useNavigationContext()\n\n  return (\n    <Link\n      activeClassName=\"nav-item-active\"\n      to={item.linkTo}\n      onClick={() => setIsMobileNavOpen(false)}\n      {...rest}\n    >\n      {/*\n        This span is needed for the styles applied in theme/styles/navigation\n      */}\n      <span>{item.name}</span>\n    </Link>\n  )\n}",
        "computed": false
      },
      "required": false
    },
    "ItemAnchor": {
      "defaultValue": {
        "value": "function BaseNavigationItemAnchor({\n  item,\n  ...rest\n}: BaseNavigationItemAnchorProps) {\n  return (\n    <BaseAnchor href={item.linkTo} {...rest}>\n      {/*\n        This span is needed for the styles applied in theme/styles/navigation\n      */}\n      <span>{item.name}</span>\n    </BaseAnchor>\n  )\n}",
        "computed": false
      },
      "required": false
    },
    "Dropdown": {
      "defaultValue": {
        "value": "function BaseNavigationDropdown({\n  item,\n  isDropdownOpen,\n  toggleDropdown,\n  dropdownItems = [],\n  dropdownChildren = false,\n  dropdownListClassName,\n  ...rest\n}: BaseNavigationDropdownProps) {\n  const dropdownRef = React.useRef<HTMLDivElement>(null)\n  const {\n    components: { DropdownItem },\n    setDropdownOffsets,\n    mobileNavMediaQuery,\n  } = BaseNavigation.useNavigationContext()\n  const [isMeasured, setIsMeasured] = React.useState(false)\n  const [windowWidth, setWindowWidth] = React.useState(0)\n  const VIEWPORT_FIT_MARGIN = 20\n\n  React.useEffect(() => {\n    setIsMeasured(true)\n    setWindowWidth(window.innerWidth || document.documentElement.clientWidth)\n  }, [])\n\n  React.useEffect(() => {\n    if (dropdownRef.current && isMeasured) {\n      const { left, right } = dropdownRef.current.getBoundingClientRect()\n      setIsMeasured(false)\n\n      const leftFit = left >= VIEWPORT_FIT_MARGIN\n      const rightFit = right <= windowWidth - VIEWPORT_FIT_MARGIN\n      const offset = !leftFit\n        ? (left - VIEWPORT_FIT_MARGIN) * -1\n        : !rightFit\n        ? windowWidth - (right + VIEWPORT_FIT_MARGIN)\n        : 0\n\n      setDropdownOffsets((state: DropdownOffsets) => ({\n        ...state,\n        [item.name]: offset,\n      }))\n    }\n  }, [isMeasured])\n\n  return (\n    <div\n      ref={dropdownRef}\n      css={baseStyles.dropdown(isDropdownOpen, isMeasured, mobileNavMediaQuery)}\n      // id to associate with aria-controls on BaseNavigation.Item\n      id={getDropdownId(item.name)}\n      onKeyDown={e => {\n        // handle closing dropdown on `esc`\n        if (e.keyCode === 27) {\n          toggleDropdown(false)\n        }\n        return\n      }}\n      {...rest}\n    >\n      <ul css={baseStyles.dropdownList()} className={dropdownListClassName}>\n        {dropdownItems.length > 0 &&\n          dropdownItems.map((item, index) => (\n            <DropdownItem key={`${index}-${item.name}`} item={item} />\n          ))}\n        {dropdownChildren && dropdownChildren}\n      </ul>\n    </div>\n  )\n}",
        "computed": false
      },
      "required": false
    },
    "DropdownItem": {
      "defaultValue": {
        "value": "function BaseNavigationDropdownItem({\n  item: { name, linkTo },\n  ...rest\n}: BaseNavigationDropdownItemProps) {\n  const { setIsMobileNavOpen } = BaseNavigation.useNavigationContext()\n\n  return (\n    <li {...rest}>\n      <Link\n        activeClassName=\"nav-item-active\"\n        to={linkTo}\n        onClick={() => setIsMobileNavOpen(false)}\n      >\n        {name}\n      </Link>\n    </li>\n  )\n}",
        "computed": false
      },
      "required": false
    },
    "DropdownToggle": {
      "defaultValue": {
        "value": "React.forwardRef<\n  HTMLButtonElement,\n  BaseNavigationDropdownToggleProps\n>(function BaseNavigationDropdownToggle(\n  { item, isDropdownOpen, toggleDropdown, ...rest },\n  ref\n) {\n  const { isInverted } = BaseNavigation.useNavigationContext()\n\n  return (\n    <button\n      ref={ref}\n      aria-expanded={!!isDropdownOpen}\n      aria-controls={getDropdownId(item.name)}\n      onClick={() => {\n        toggleDropdown(!isDropdownOpen)\n      }}\n      css={baseStyles.dropdownToggle(isInverted)}\n      {...rest}\n    >\n      <span aria-hidden=\"true\">&or;</span>\n      <span css={visuallyHiddenCss}>{`${item.name} Menu`}</span>\n    </button>\n  )\n})",
        "computed": true
      },
      "required": false
    },
    "LinkButton": {
      "defaultValue": {
        "value": "function BaseNavigationLinkButton({\n  linkTo,\n  icon = true,\n  size = `M`,\n  children,\n  ...rest\n}: BaseNavigationLinkButtonProps) {\n  const { isInverted } = BaseNavigation.useNavigationContext()\n\n  return (\n    <LinkButton\n      to={linkTo}\n      size={size}\n      css={baseStyles.button(isInverted)}\n      rightIcon={icon ? <MdArrowForward /> : undefined}\n      {...rest}\n    >\n      {children}\n    </LinkButton>\n  )\n}",
        "computed": false
      },
      "required": false
    },
    "AnchorButton": {
      "defaultValue": {
        "value": "React.forwardRef<\n  HTMLAnchorElement,\n  BaseNavigationAnchorButtonProps\n>(function BaseNavigationAnchorButton(\n  { linkTo, icon = true, size = `M`, children, ...rest },\n  ref\n) {\n  const { isInverted } = BaseNavigation.useNavigationContext()\n\n  return (\n    <AnchorButton\n      ref={ref}\n      href={linkTo}\n      size={size}\n      css={baseStyles.button(isInverted)}\n      rightIcon={icon ? <MdArrowForward /> : undefined}\n      {...rest}\n    >\n      {children}\n    </AnchorButton>\n  )\n})",
        "computed": true
      },
      "required": false
    },
    "isMobileNavOpen": {
      "required": false,
      "tsType": {
        "name": "boolean"
      },
      "description": ""
    },
    "setIsMobileNavOpen": {
      "required": false,
      "tsType": {
        "name": "signature",
        "type": "function",
        "raw": "(value: boolean) => void",
        "signature": {
          "arguments": [{
            "name": "value",
            "type": {
              "name": "boolean"
            }
          }],
          "return": {
            "name": "void"
          }
        }
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BaseNavigation/BaseNavigation.tsx"] = {
    name: "BaseNavigation",
    docgenInfo: BaseNavigation.__docgenInfo,
    path: "src/components/BaseNavigation/BaseNavigation.tsx"
  };
}

BaseNavigationHamburgerIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BaseNavigationHamburgerIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BaseNavigation/BaseNavigation.tsx"] = {
    name: "BaseNavigationHamburgerIcon",
    docgenInfo: BaseNavigationHamburgerIcon.__docgenInfo,
    path: "src/components/BaseNavigation/BaseNavigation.tsx"
  };
}

BaseNavigationNav.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BaseNavigationNav"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BaseNavigation/BaseNavigation.tsx"] = {
    name: "BaseNavigationNav",
    docgenInfo: BaseNavigationNav.__docgenInfo,
    path: "src/components/BaseNavigation/BaseNavigation.tsx"
  };
}

BaseNavigationList.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BaseNavigationList"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BaseNavigation/BaseNavigation.tsx"] = {
    name: "BaseNavigationList",
    docgenInfo: BaseNavigationList.__docgenInfo,
    path: "src/components/BaseNavigation/BaseNavigation.tsx"
  };
}

BaseNavigationListItem.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BaseNavigationListItem",
  "props": {
    "item": {
      "required": true,
      "tsType": {
        "name": "intersection",
        "raw": "BaseNavigationItem & {\n  items?: BaseNavigationItem[]\n}",
        "elements": [{
          "name": "signature",
          "type": "object",
          "raw": "{\n  name: string\n  linkTo: string\n}",
          "signature": {
            "properties": [{
              "key": "name",
              "value": {
                "name": "string",
                "required": true
              }
            }, {
              "key": "linkTo",
              "value": {
                "name": "string",
                "required": true
              }
            }]
          }
        }, {
          "name": "signature",
          "type": "object",
          "raw": "{\n  items?: BaseNavigationItem[]\n}",
          "signature": {
            "properties": [{
              "key": "items",
              "value": {
                "name": "Array",
                "elements": [{
                  "name": "signature",
                  "type": "object",
                  "raw": "{\n  name: string\n  linkTo: string\n}",
                  "signature": {
                    "properties": [{
                      "key": "name",
                      "value": {
                        "name": "string",
                        "required": true
                      }
                    }, {
                      "key": "linkTo",
                      "value": {
                        "name": "string",
                        "required": true
                      }
                    }]
                  }
                }],
                "raw": "BaseNavigationItem[]",
                "required": false
              }
            }]
          }
        }]
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BaseNavigation/BaseNavigation.tsx"] = {
    name: "BaseNavigationListItem",
    docgenInfo: BaseNavigationListItem.__docgenInfo,
    path: "src/components/BaseNavigation/BaseNavigation.tsx"
  };
}

BaseNavigationItemAnchor.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BaseNavigationItemAnchor",
  "props": {
    "item": {
      "required": true,
      "tsType": {
        "name": "signature",
        "type": "object",
        "raw": "{\n  name: string\n  linkTo: string\n}",
        "signature": {
          "properties": [{
            "key": "name",
            "value": {
              "name": "string",
              "required": true
            }
          }, {
            "key": "linkTo",
            "value": {
              "name": "string",
              "required": true
            }
          }]
        }
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BaseNavigation/BaseNavigation.tsx"] = {
    name: "BaseNavigationItemAnchor",
    docgenInfo: BaseNavigationItemAnchor.__docgenInfo,
    path: "src/components/BaseNavigation/BaseNavigation.tsx"
  };
}

BaseNavigationItemLink.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BaseNavigationItemLink",
  "props": {
    "item": {
      "required": true,
      "tsType": {
        "name": "signature",
        "type": "object",
        "raw": "{\n  name: string\n  linkTo: string\n}",
        "signature": {
          "properties": [{
            "key": "name",
            "value": {
              "name": "string",
              "required": true
            }
          }, {
            "key": "linkTo",
            "value": {
              "name": "string",
              "required": true
            }
          }]
        }
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BaseNavigation/BaseNavigation.tsx"] = {
    name: "BaseNavigationItemLink",
    docgenInfo: BaseNavigationItemLink.__docgenInfo,
    path: "src/components/BaseNavigation/BaseNavigation.tsx"
  };
}

BaseNavigationDropdownToggle.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BaseNavigationDropdownToggle"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BaseNavigation/BaseNavigation.tsx"] = {
    name: "BaseNavigationDropdownToggle",
    docgenInfo: BaseNavigationDropdownToggle.__docgenInfo,
    path: "src/components/BaseNavigation/BaseNavigation.tsx"
  };
}

BaseNavigationDropdown.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BaseNavigationDropdown",
  "props": {
    "dropdownItems": {
      "defaultValue": {
        "value": "[]",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "Array",
        "elements": [{
          "name": "signature",
          "type": "object",
          "raw": "{\n  name: string\n  linkTo: string\n}",
          "signature": {
            "properties": [{
              "key": "name",
              "value": {
                "name": "string",
                "required": true
              }
            }, {
              "key": "linkTo",
              "value": {
                "name": "string",
                "required": true
              }
            }]
          }
        }],
        "raw": "BaseNavigationItem[]"
      },
      "description": ""
    },
    "dropdownChildren": {
      "defaultValue": {
        "value": "false",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    },
    "item": {
      "required": true,
      "tsType": {
        "name": "signature",
        "type": "object",
        "raw": "{\n  name: string\n  linkTo: string\n}",
        "signature": {
          "properties": [{
            "key": "name",
            "value": {
              "name": "string",
              "required": true
            }
          }, {
            "key": "linkTo",
            "value": {
              "name": "string",
              "required": true
            }
          }]
        }
      },
      "description": ""
    },
    "isDropdownOpen": {
      "required": true,
      "tsType": {
        "name": "boolean"
      },
      "description": ""
    },
    "toggleDropdown": {
      "required": true,
      "tsType": {
        "name": "signature",
        "type": "function",
        "raw": "(value: boolean) => void",
        "signature": {
          "arguments": [{
            "name": "value",
            "type": {
              "name": "boolean"
            }
          }],
          "return": {
            "name": "void"
          }
        }
      },
      "description": ""
    },
    "dropdownListClassName": {
      "required": false,
      "tsType": {
        "name": "string"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BaseNavigation/BaseNavigation.tsx"] = {
    name: "BaseNavigationDropdown",
    docgenInfo: BaseNavigationDropdown.__docgenInfo,
    path: "src/components/BaseNavigation/BaseNavigation.tsx"
  };
}

BaseNavigationDropdownItem.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BaseNavigationDropdownItem",
  "props": {
    "item": {
      "required": true,
      "tsType": {
        "name": "signature",
        "type": "object",
        "raw": "{\n  name: string\n  linkTo: string\n}",
        "signature": {
          "properties": [{
            "key": "name",
            "value": {
              "name": "string",
              "required": true
            }
          }, {
            "key": "linkTo",
            "value": {
              "name": "string",
              "required": true
            }
          }]
        }
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BaseNavigation/BaseNavigation.tsx"] = {
    name: "BaseNavigationDropdownItem",
    docgenInfo: BaseNavigationDropdownItem.__docgenInfo,
    path: "src/components/BaseNavigation/BaseNavigation.tsx"
  };
}

BaseNavigationLinkButton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BaseNavigationLinkButton",
  "props": {
    "icon": {
      "defaultValue": {
        "value": "true",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "boolean"
      },
      "description": ""
    },
    "size": {
      "defaultValue": {
        "value": "`M`",
        "computed": false
      },
      "required": false
    },
    "linkTo": {
      "required": false,
      "tsType": {
        "name": "string"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BaseNavigation/BaseNavigation.tsx"] = {
    name: "BaseNavigationLinkButton",
    docgenInfo: BaseNavigationLinkButton.__docgenInfo,
    path: "src/components/BaseNavigation/BaseNavigation.tsx"
  };
}

BaseNavigationAnchorButton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BaseNavigationAnchorButton",
  "props": {
    "icon": {
      "defaultValue": {
        "value": "true",
        "computed": false
      },
      "required": false
    },
    "size": {
      "defaultValue": {
        "value": "`M`",
        "computed": false
      },
      "required": false
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BaseNavigation/BaseNavigation.tsx"] = {
    name: "BaseNavigationAnchorButton",
    docgenInfo: BaseNavigationAnchorButton.__docgenInfo,
    path: "src/components/BaseNavigation/BaseNavigation.tsx"
  };
}

var variants = {
  STATUS: function STATUS(tone) {
    return function (theme) {
      return [{
        background: theme.tones[tone].superLight,
        border: "1px solid ".concat(theme.tones[tone].lighter),
        color: theme.tones[tone].text
      }];
    };
  },
  PILL: function PILL(tone) {
    return function (theme) {
      return [{
        background: theme.tones[tone].dark,
        color: theme.tones[tone].textInverted ? theme.tones[tone].textInverted : theme.colors.white
      }];
    };
  }
};
function getBadgeVariantStyles(variant, tone) {
  return variants[variant](tone);
}
getBadgeVariantStyles.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "getBadgeVariantStyles"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Badge/Badge.helpers.tsx"] = {
    name: "getBadgeVariantStyles",
    docgenInfo: getBadgeVariantStyles.__docgenInfo,
    path: "src/components/Badge/Badge.helpers.tsx"
  };
}

var iconHeightBySize = {
  inherit: "1em",
  xxsmall: "16px",
  xsmall: "20px",
  small: "24px",
  medium: "32px",
  large: "40px"
};
function IconSkeleton(_ref) {
  var iconName = _ref.iconName,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? "small" : _ref$size,
      style = _ref.style,
      _ref$applyColorToStro = _ref.applyColorToStroke,
      applyColorToStroke = _ref$applyColorToStro === void 0 ? true : _ref$applyColorToStro,
      rest = _objectWithoutProperties(_ref, ["iconName", "size", "style", "applyColorToStroke"]);

  return /*#__PURE__*/React__default.createElement("svg", _extends({
    preserveAspectRatio: "xMidYMid meet",
    height: iconHeightBySize[size],
    width: iconHeightBySize[size],
    viewBox: "0 0 24 24",
    fill: applyColorToStroke ? "none" : "currentColor",
    stroke: applyColorToStroke ? "currentColor" : "none",
    strokeWidth: "1",
    fillRule: "evenodd",
    "data-testid": "icon-".concat(iconName),
    style: _objectSpread2({
      verticalAlign: "middle"
    }, style || {}),
    "aria-hidden": true
  }, rest));
}
IconSkeleton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "IconSkeleton",
  "props": {
    "size": {
      "defaultValue": {
        "value": "`small`",
        "computed": false
      },
      "required": false
    },
    "applyColorToStroke": {
      "defaultValue": {
        "value": "true",
        "computed": false
      },
      "required": false
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/IconSkeleton.tsx"] = {
    name: "IconSkeleton",
    docgenInfo: IconSkeleton.__docgenInfo,
    path: "src/components/icons/IconSkeleton.tsx"
  };
}

var baseCss$2 = function baseCss(theme) {
  return {
    alignItems: "center",
    borderRadius: theme.radii[1],
    display: "inline-flex",
    fontFamily: theme.fonts.body,
    fontSize: theme.fontSizes[0],
    lineHeight: theme.lineHeights.solid,
    padding: "".concat(theme.space[1], " ").concat(theme.space[3]),
    minHeight: theme.space[7]
  };
};

function Badge(_ref) {
  var children = _ref.children,
      Icon = _ref.Icon,
      _ref$variant = _ref.variant,
      variant = _ref$variant === void 0 ? "STATUS" : _ref$variant,
      _ref$textVariant = _ref.textVariant,
      textVariant = _ref$textVariant === void 0 ? "CAPS" : _ref$textVariant,
      _ref$tone = _ref.tone,
      tone = _ref$tone === void 0 ? "BRAND" : _ref$tone,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? "S" : _ref$size,
      rest = _objectWithoutProperties(_ref, ["children", "Icon", "variant", "textVariant", "tone", "size"]);

  var iconSize = size === "S" ? iconHeightBySize.xxsmall : iconHeightBySize.xsmall;
  return core.jsx("span", _extends({
    css: function css(theme) {
      return [baseCss$2(theme), textVariant === "CAPS" && {
        textTransform: "uppercase",
        fontWeight: 500,
        letterSpacing: theme.letterSpacings.tracked
      }, size === "M" && {
        borderRadius: theme.radii[2],
        fontSize: theme.fontSizes[1],
        minHeight: "calc(".concat(theme.space[2], " * 7)"),
        padding: "".concat(theme.space[1], " ").concat(theme.space[4])
      }, size === "M" && textVariant === "CAPS" && {
        fontSize: theme.fontSizes[0]
      }, getBadgeVariantStyles(variant, tone)(theme)];
    }
  }, rest), Icon && core.jsx(Icon, {
    css: function css(theme) {
      return [{
        marginRight: size === "S" ? theme.space[2] : theme.space[3],
        color: theme.tones[tone].medium,
        flexShrink: 0,
        width: iconSize,
        height: iconSize
      }, variant === "PILL" && {
        color: theme.tones[tone].mediumInverted ? theme.tones[tone].mediumInverted : theme.colors.whiteFade[90]
      }];
    }
  }), children);
}
Badge.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "Badge",
  "props": {
    "variant": {
      "defaultValue": {
        "value": "`STATUS`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "BadgeVariant"
      },
      "description": ""
    },
    "textVariant": {
      "defaultValue": {
        "value": "`CAPS`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "BadgeTextVariant"
      },
      "description": ""
    },
    "tone": {
      "defaultValue": {
        "value": "`BRAND`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "BadgeTone"
      },
      "description": ""
    },
    "size": {
      "defaultValue": {
        "value": "`S`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "BadgeSize"
      },
      "description": ""
    },
    "children": {
      "required": false,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    },
    "Icon": {
      "required": false,
      "tsType": {
        "name": "ReactComponentType",
        "raw": "React.ComponentType<any>",
        "elements": [{
          "name": "any"
        }]
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Badge/Badge.tsx"] = {
    name: "Badge",
    docgenInfo: Badge.__docgenInfo,
    path: "src/components/Badge/Badge.tsx"
  };
}

var baseCss$3 = function baseCss(theme) {
  return {
    alignItems: "center",
    color: theme.colors.purple[60],
    display: "inline-flex"
  };
};

var variantsCss = {
  DEFAULT: function DEFAULT(theme) {
    return {
      textDecoration: "underline",
      ":focus, :hover": {
        color: theme.colors.purple[60],
        textDecoration: "underline"
      }
    };
  },
  SIMPLE: function SIMPLE(theme) {
    return {
      textDecoration: "none",
      ":focus, :hover": {
        color: theme.colors.purple[40],
        textDecoration: "underline"
      }
    };
  }
};
function Link(_ref) {
  var _ref$variant = _ref.variant,
      variant = _ref$variant === void 0 ? "DEFAULT" : _ref$variant,
      rest = _objectWithoutProperties(_ref, ["variant"]);

  var commonProps = {
    css: function css(theme) {
      return [baseCss$3(theme), variantsCss[variant](theme)];
    }
  };

  if (isGatsbyLink(rest)) {
    // GatsbyLink does not support target attribute
    return core.jsx(gatsby.Link, _extends({}, commonProps, rest, {
      target: undefined
    }));
  }

  return core.jsx(BaseAnchor, _extends({}, commonProps, rest));
}
/**
 * An awesome tidbit from React TypeScript Cheatsheet
 * https://github.com/typescript-cheatsheets/react-typescript-cheatsheet/blob/master/ADVANCED.md#typing-a-component-that-accepts-different-props
 */

function isGatsbyLink(props) {
  return "to" in props;
}

Link.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "Link",
  "props": {
    "variant": {
      "defaultValue": {
        "value": "`DEFAULT`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "union",
        "raw": "`DEFAULT` | `SIMPLE`",
        "elements": [{
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }]
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Link/Link.tsx"] = {
    name: "Link",
    docgenInfo: Link.__docgenInfo,
    path: "src/components/Link/Link.tsx"
  };
}

var SIZE = "1.75rem";
var BORDER_WIDTH = "1px";
var BACKGROUND_COLOR = colors.grey["10"];
var baseCss$4 = core.css({
  display: "inline-flex",
  alignItems: "center",
  verticalAlign: "middle",
  minWidth: SIZE,
  height: SIZE,
  padding: "0 0.75rem",
  backgroundColor: BACKGROUND_COLOR,
  borderRadius: "0.75rem",
  fontSize: b[0],
  lineHeight: "calc(".concat(SIZE, " - 2 * ").concat(BORDER_WIDTH, ")"),
  color: colors.blackFade["70"],
  border: "".concat(BORDER_WIDTH, " solid ").concat(BACKGROUND_COLOR),
  whiteSpace: "nowrap"
});
function BaseChip(_ref) {
  var props = _extends({}, _ref);

  return core.jsx("span", _extends({
    css: baseCss$4
  }, props));
}
BaseChip.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BaseChip"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Chip/BaseChip.tsx"] = {
    name: "BaseChip",
    docgenInfo: BaseChip.__docgenInfo,
    path: "src/components/Chip/BaseChip.tsx"
  };
}

var iconCss = core.css({
  display: "inline-flex",
  alignItems: "center",
  verticalAlign: "middle",
  height: "0.875rem",
  width: "0.875rem",
  fontSize: "0.875rem"
});
var iconOffsetCss = core.css({
  marginRight: "0.25rem"
});
var iconOnlyCss = core.css({
  padding: 0,
  justifyContent: "space-around"
});
function Chip(_ref) {
  var _ref$icon = _ref.icon,
      icon = _ref$icon === void 0 ? null : _ref$icon,
      children = _ref.children,
      props = _objectWithoutProperties(_ref, ["icon", "children"]);

  return core.jsx(BaseChip, _extends({
    css: !children && iconOnlyCss
  }, props), icon && core.jsx("span", {
    css: [iconCss, children && iconOffsetCss]
  }, icon), children);
}
Chip.propTypes = {
  icon: _pt__default.oneOfType([_pt__default.node, _pt__default.oneOf([null])])
};
Chip.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "Chip",
  "props": {
    "icon": {
      "defaultValue": {
        "value": "null",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "union",
        "raw": "React.ReactNode | null",
        "elements": [{
          "name": "ReactReactNode",
          "raw": "React.ReactNode"
        }, {
          "name": "null"
        }]
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Chip/Chip.tsx"] = {
    name: "Chip",
    docgenInfo: Chip.__docgenInfo,
    path: "src/components/Chip/Chip.tsx"
  };
}

function copyToClipboard(content) {
  if (!window || !window.navigator) {
    return Promise.resolve();
  }

  var clipboard = window.navigator.clipboard;
  /*
   * fallback to older browsers (including Safari)
   * if clipboard API not supported
   */

  if (!clipboard || typeof clipboard.writeText !== "function") {
    clipboardWriteTextFallback(content);
    return Promise.resolve();
  }

  return clipboard.writeText(content);
}

function clipboardWriteTextFallback(content) {
  var textarea = document.createElement("textarea");
  textarea.value = content;
  textarea.setAttribute("readonly", "true");
  textarea.setAttribute("contenteditable", "true");
  textarea.style.position = "absolute";
  textarea.style.left = "-9999px";
  document.body.appendChild(textarea);
  textarea.select();
  var range = document.createRange();
  var sel = window.getSelection();

  if (!sel) {
    return;
  }

  sel.removeAllRanges();
  sel.addRange(range);
  textarea.setSelectionRange(0, textarea.value.length);
  document.execCommand("copy");
  document.body.removeChild(textarea);
}

function _templateObject$1() {
  var data = _taggedTemplateLiteral(["\n  html:not([dir=\"rtl\"]) & {\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n\n  html[dir=\"rtl\"] & {\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n"]);

  _templateObject$1 = function _templateObject() {
    return data;
  };

  return data;
}
var baseCss$5 = core.css(_templateObject$1());

function CopyButton(_ref) {
  var onClick = _ref.onClick,
      content = _ref.content,
      _ref$getButtonLabel = _ref.getButtonLabel,
      getButtonLabel = _ref$getButtonLabel === void 0 ? function (copied) {
    return copied ? "Copied" : "Copy";
  } : _ref$getButtonLabel,
      _ref$getButtonTitle = _ref.getButtonTitle,
      getButtonTitle = _ref$getButtonTitle === void 0 ? function (copied) {
    return copied ? "Copied to clipboard" : "Copy to clipboard";
  } : _ref$getButtonTitle,
      _ref$delay = _ref.delay,
      delay = _ref$delay === void 0 ? 5000 : _ref$delay,
      children = _ref.children,
      props = _objectWithoutProperties(_ref, ["onClick", "content", "getButtonLabel", "getButtonTitle", "delay", "children"]);

  var timeoutRef = React__default.useRef(undefined);

  var _React$useState = React__default.useState(false),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      copied = _React$useState2[0],
      setCopied = _React$useState2[1];

  var copyOnClick = function copyOnClick(e) {
    if (onClick) {
      onClick(e);
    }

    copyToClipboard(content).then(function () {
      setCopied(true);
      timeoutRef.current = window.setTimeout(function () {
        setCopied(false);
      }, delay);
    });
  };

  React__default.useEffect(function () {
    return function () {
      if (timeoutRef.current) {
        window.clearTimeout(timeoutRef.current);
      }
    };
  }, []);
  return core.jsx(Button, _extends({
    css: baseCss$5,
    title: getButtonTitle(copied),
    onClick: copyOnClick,
    size: "S",
    type: "button",
    variant: "SECONDARY"
  }, props), getButtonLabel(copied), children);
}

CopyButton.propTypes = {
  getButtonTitle: _pt__default.func,
  content: _pt__default.string.isRequired,
  delay: _pt__default.number,
  onClick: _pt__default.func,
  getButtonLabel: _pt__default.func,
  type: _pt__default.oneOf(["button", "submit"])
};
CopyButton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CopyButton",
  "props": {
    "getButtonLabel": {
      "defaultValue": {
        "value": "copied => (copied ? `Copied` : `Copy`)",
        "computed": false
      },
      "type": {
        "name": "func"
      },
      "required": false,
      "description": "",
      "tsType": {
        "name": "signature",
        "type": "function",
        "raw": "(copied: boolean) => string",
        "signature": {
          "arguments": [{
            "name": "copied",
            "type": {
              "name": "boolean"
            }
          }],
          "return": {
            "name": "string"
          }
        }
      }
    },
    "getButtonTitle": {
      "defaultValue": {
        "value": "copied =>\ncopied ? `Copied to clipboard` : `Copy to clipboard`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "signature",
        "type": "function",
        "raw": "(copied: boolean) => string",
        "signature": {
          "arguments": [{
            "name": "copied",
            "type": {
              "name": "boolean"
            }
          }],
          "return": {
            "name": "string"
          }
        }
      },
      "description": ""
    },
    "delay": {
      "defaultValue": {
        "value": "5000",
        "computed": false
      },
      "type": {
        "name": "number"
      },
      "required": false,
      "description": "",
      "tsType": {
        "name": "number"
      }
    },
    "content": {
      "type": {
        "name": "string"
      },
      "required": true,
      "description": "",
      "tsType": {
        "name": "string"
      }
    },
    "onClick": {
      "type": {
        "name": "func"
      },
      "required": false,
      "description": ""
    },
    "type": {
      "type": {
        "name": "enum",
        "value": [{
          "value": "`button`",
          "computed": true
        }, {
          "value": "`submit`",
          "computed": true
        }]
      },
      "required": false,
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/CopyButton/CopyButton.tsx"] = {
    name: "CopyButton",
    docgenInfo: CopyButton.__docgenInfo,
    path: "src/components/CopyButton/CopyButton.tsx"
  };
}

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeKeys = overArg(Object.keys, Object),
    nativeRandom = Math.random;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */
function baseRandom(lower, upper) {
  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Gets a random element from `collection`.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to sample.
 * @returns {*} Returns the random element.
 * @example
 *
 * _.sample([1, 2, 3, 4]);
 * // => 2
 */
function sample(collection) {
  var array = isArrayLike(collection) ? collection : values(collection),
      length = array.length;

  return length > 0 ? array[baseRandom(0, length - 1)] : undefined;
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object ? baseValues(object, keys(object)) : [];
}

var lodash_sample = sample;

/**
  Some components are impure - a good example is DecorativeDots,
  which purposefully produces a different value for every 
  instance.

  This works fine in dev/prod, but causes problems with our
  tests - snapshot tests expect consistent UI given a set of 
  props!

  These functions can be used instead, which provide consistent
  values while in the 'test' environment.
*/
var testSafeMathRandom = function testSafeMathRandom() {
  var defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;

  if (process.env.NODE_ENV === "test") {
    return defaultValue;
  }

  return Math.random();
};
var testSafeSample = function testSafeSample(arr) {
  var defaultIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  if (process.env.NODE_ENV === "test") {
    return arr[defaultIndex];
  }

  return lodash_sample(arr);
};

var getChanceOfBeingBlankForAxis = function getChanceOfBeingBlankForAxis(rateOfDecay, progressRatio) {
  if (rateOfDecay < 0) {
    rateOfDecay = Math.abs(rateOfDecay);
    progressRatio = 1 - progressRatio;
  }

  return rateOfDecay * progressRatio;
};

var mix = function mix(n1, n2) {
  return (n1 + n2) / 2;
};
/**
 * We want our dots to form a gradient based on the angle provided.
 * A 0-degree angle should fade gradually out from left to right.
 * A 90-degree angle should fade out from top to bottom.
 * 45-degrees means it fades out diagonally, from top-left to bottom-right.
 *
 * We can get a specific dot's position by looking at its row/column index
 * against the total number of rows/columns. Then we can figure out where it
 * sits on the spectrum by using trigonometry; every angle decays across each
 * axis at a different rate, so we get the rate for both X and Y axes.
 * Then we mix those two values, for an overall likelihood of blank-ness.
 */


var getLikelihoodOfBeingBlank = function getLikelihoodOfBeingBlank(angle, colIndex, rowIndex, numCols, numRows) {
  var angleInRads = angle * Math.PI / 180;
  var rateOfDecayX = Math.cos(angleInRads);
  var rateOfDecayY = Math.sin(angleInRads);
  var percentageThroughX = colIndex / numCols;
  var percentageThroughY = rowIndex / numRows;
  var chanceOfBeingBlankX = getChanceOfBeingBlankForAxis(rateOfDecayX, percentageThroughX);
  var chanceOfBeingBlankY = getChanceOfBeingBlankForAxis(rateOfDecayY, percentageThroughY);
  return mix(chanceOfBeingBlankX, chanceOfBeingBlankY);
};

var Dot = function Dot(_ref) {
  var x = _ref.x,
      y = _ref.y,
      color = _ref.color,
      opacity = _ref.opacity,
      size = _ref.size;
  return /*#__PURE__*/React.createElement("circle", {
    r: size / 2,
    cx: x,
    cy: y,
    opacity: opacity,
    fill: color
  });
};

Dot.propTypes = {
  x: _pt__default.number.isRequired,
  y: _pt__default.number.isRequired,
  color: _pt__default.string.isRequired,
  opacity: _pt__default.number.isRequired,
  size: _pt__default.number.isRequired
};
Dot.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "Dot"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/DecorativeDots/Dot.tsx"] = {
    name: "Dot",
    docgenInfo: Dot.__docgenInfo,
    path: "src/components/DecorativeDots/Dot.tsx"
  };
}

// These colors were chosen somewhat haphazardly from previous assets.
// For now, this is not customizable, colors are meant to be semi-randomly
// drawn from our design palette.
var COLORS = [colors.red[40], colors.red[60], colors.orange[40], colors.orange[60], colors.yellow[40], colors.green[20], colors.green[40], colors.blue[20], colors.blue[40], colors.magenta[20], colors.magenta[50], colors.purple[40], colors.purple[60], colors.teal[20], colors.teal[50], colors.teal[70]]; // Every circle is given a random opacity, but it's weighted so that outliers
// don't happen much.

var OPACITIES = [0.15, 0.25, 0.25, 0.25, 0.5, 0.5, 0.75];

var generateDotData = function generateDotData(numRows, numCols, angle, dotSize, fadeStrength) {
  var dots = [];
  var dotSpacing = Math.round(dotSize / 10);
  var totalDotSpace = dotSize + dotSpacing;

  for (var rowIndex = 0; rowIndex < numRows; rowIndex++) {
    for (var colIndex = 0; colIndex < numCols; colIndex++) {
      var likelihoodOfBeingBlank = getLikelihoodOfBeingBlank(angle, colIndex, rowIndex, numCols, numRows);
      var isBlank = likelihoodOfBeingBlank * testSafeMathRandom() < fadeStrength;

      if (!isBlank) {
        dots.push({
          x: colIndex * totalDotSpace,
          y: rowIndex * totalDotSpace,
          color: testSafeSample(COLORS),
          opacity: testSafeSample(OPACITIES),
          size: dotSize
        });
      }
    }
  }

  return dots;
};

var dotSvgStyles = {
  // We want to let the circles at the edge of the SVG spill out, not get
  // cropped by the SVG boundaries. Cropping will naturally occur if we
  // position this SVG at an edge of the viewport =)
  overflow: "visible"
};

var DecorativeDots = function DecorativeDots(_ref) {
  var width = _ref.width,
      height = _ref.height,
      dotSize = _ref.dotSize,
      _ref$angle = _ref.angle,
      angle = _ref$angle === void 0 ? 0 : _ref$angle,
      _ref$fadeStrength = _ref.fadeStrength,
      fadeStrength = _ref$fadeStrength === void 0 ? 0.25 : _ref$fadeStrength;
  var numRows = Math.floor(height / dotSize);
  var numCols = Math.floor(width / dotSize);
  var dots = generateDotData(numRows, numCols, angle, dotSize, fadeStrength);
  return /*#__PURE__*/React.createElement("svg", {
    width: width,
    height: height,
    style: dotSvgStyles,
    "aria-hidden": true
  }, dots.map(function (dot, i) {
    return /*#__PURE__*/React.createElement(Dot, {
      key: i,
      x: dot.x,
      y: dot.y,
      color: dot.color,
      opacity: dot.opacity,
      size: dot.size
    });
  }));
};

DecorativeDots.propTypes = {
  width: _pt__default.number.isRequired,
  height: _pt__default.number.isRequired,
  dotSize: _pt__default.number.isRequired,
  angle: _pt__default.number,
  fadeStrength: _pt__default.number
};
DecorativeDots.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "DecorativeDots",
  "props": {
    "angle": {
      "defaultValue": {
        "value": "0",
        "computed": false
      },
      "required": false
    },
    "fadeStrength": {
      "defaultValue": {
        "value": "0.25",
        "computed": false
      },
      "required": false
    }
  }
};
var DecorativeDots$1 = React.memo(DecorativeDots);

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/DecorativeDots/DecorativeDots.tsx"] = {
    name: "DecorativeDots",
    docgenInfo: DecorativeDots.__docgenInfo,
    path: "src/components/DecorativeDots/DecorativeDots.tsx"
  };
}

function BaseHeading(props) {
  var children = props.children,
      _props$as = props.as,
      Component = _props$as === void 0 ? "h1" : _props$as,
      rest = _objectWithoutProperties(props, ["children", "as"]);

  return /*#__PURE__*/React__default.createElement(Component, rest, children);
}
BaseHeading.propTypes = {
  as: _pt__default.oneOf(["h1", "h2", "h3", "h4", "h5", "h6", "span"])
};
BaseHeading.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BaseHeading",
  "props": {
    "as": {
      "required": false,
      "tsType": {
        "name": "union",
        "raw": "\"h1\" | \"h2\" | \"h3\" | \"h4\" | \"h5\" | \"h6\" | \"span\"",
        "elements": [{
          "name": "literal",
          "value": "\"h1\""
        }, {
          "name": "literal",
          "value": "\"h2\""
        }, {
          "name": "literal",
          "value": "\"h3\""
        }, {
          "name": "literal",
          "value": "\"h4\""
        }, {
          "name": "literal",
          "value": "\"h5\""
        }, {
          "name": "literal",
          "value": "\"h6\""
        }, {
          "name": "literal",
          "value": "\"span\""
        }]
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BaseHeading/BaseHeading.tsx"] = {
    name: "BaseHeading",
    docgenInfo: BaseHeading.__docgenInfo,
    path: "src/components/BaseHeading/BaseHeading.tsx"
  };
}

function warn(message) {
  var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "warning";

  if (process.env.NODE_ENV === "development") {
    if (level === "error") {
      console.error(message);
    } else {
      console.warn(message);
    }
  }
}

function showCustomCssDeprecationMessage(customCss) {
  if (customCss === undefined) {
    return;
  }

  warn("Styling components via \"customCss\" prop is deprecated, please use Emotion \"css\" prop or pass a \"className\"");
}

var baseCss$6 = function baseCss(theme) {
  return {
    fontFamily: theme.fonts.heading,
    margin: 0,
    lineHeight: theme.lineHeights.heading // Ask Flo about this

  };
};

var modifiedCss = function modifiedCss(variant, tone) {
  return function (theme) {
    return [{
      color: theme.tones[tone].text
    }, variant === "PRIMARY" && {
      fontWeight: theme.fontWeights.bold
    }, variant === "EMPHASIZED" && {
      fontWeight: theme.fontWeights.extraBold
    }, variant === "LIGHT" && {
      fontWeight: 100,
      textTransform: "uppercase"
    }];
  };
};

function Heading(_ref) {
  var _ref$tone = _ref.tone,
      tone = _ref$tone === void 0 ? "NEUTRAL" : _ref$tone,
      _ref$variant = _ref.variant,
      variant = _ref$variant === void 0 ? "PRIMARY" : _ref$variant,
      _ref$as = _ref.as,
      as = _ref$as === void 0 ? "h2" : _ref$as,
      customCss = _ref.customCss,
      rest = _objectWithoutProperties(_ref, ["tone", "variant", "as", "customCss"]);

  showCustomCssDeprecationMessage(customCss);
  return core.jsx(BaseHeading, _extends({
    as: as,
    css: function css(theme) {
      return [baseCss$6(theme), modifiedCss(variant, tone)(theme), customCss];
    }
  }, rest));
}
Heading.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "Heading",
  "props": {
    "tone": {
      "defaultValue": {
        "value": "`NEUTRAL`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "HeadingTone"
      },
      "description": ""
    },
    "variant": {
      "defaultValue": {
        "value": "`PRIMARY`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "HeadingVariant"
      },
      "description": ""
    },
    "as": {
      "defaultValue": {
        "value": "`h2`",
        "computed": false
      },
      "required": false
    },
    "customCss": {
      "required": false,
      "tsType": {
        "name": "Interpolation"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Heading/Heading.tsx"] = {
    name: "Heading",
    docgenInfo: Heading.__docgenInfo,
    path: "src/components/Heading/Heading.tsx"
  };
}

function BlogIcon(props) {
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    iconName: "BlogIcon"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M8.49188 11.265L7.43188 15.508L11.6739 14.447L18.0379 8.083L14.8559 4.901L8.49188 11.265Z",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M21.751 4.37097L22.811 5.43097C22.9504 5.57027 23.061 5.73567 23.1364 5.91772C23.2119 6.09978 23.2507 6.29491 23.2507 6.49197C23.2507 6.68904 23.2119 6.88417 23.1364 7.06622C23.061 7.24827 22.9504 7.41367 22.811 7.55297L19.5 10.863",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M18.038 8.083L21.751 4.371C22.0322 4.0897 22.1901 3.70824 22.1901 3.3105C22.1901 2.91275 22.0322 2.53129 21.751 2.25L20.69 1.189C20.4087 0.90779 20.0272 0.749817 19.6295 0.749817C19.2317 0.749817 18.8502 0.90779 18.569 1.189L14.856 4.9",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M18.75 14.25V21.75C18.75 22.1478 18.592 22.5294 18.3107 22.8107C18.0294 23.092 17.6478 23.25 17.25 23.25H2.25C1.85218 23.25 1.47064 23.092 1.18934 22.8107C0.908035 22.5294 0.75 22.1478 0.75 21.75V6.75C0.75 6.35218 0.908035 5.97064 1.18934 5.68934C1.47064 5.40804 1.85218 5.25 2.25 5.25H9.75",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
}
BlogIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BlogIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/BlogIcon.tsx"] = {
    name: "BlogIcon",
    docgenInfo: BlogIcon.__docgenInfo,
    path: "src/components/icons/BlogIcon.tsx"
  };
}

function CheckIcon(props) {
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    iconName: "CheckIcon",
    applyColorToStroke: false
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M9.3 16.7l-3.1-4.3A1 1 0 0 1 7.8 11l3.7 3.9c.6.6.6 1.6 0 2.1-.7.5-1.7.4-2.2-.3z"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M9.6 17c-.7-.6-.7-1.5-.2-2.2l7.3-8a1 1 0 0 1 1.6 1.3l-6.6 8.6c-.5.7-1.5.8-2.1.3z"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M9.7 13c.4.5.7.8 1.1.3.5-.5-.1 1.3-.1 1.3l-1.5-.5.5-1z"
  }));
}
CheckIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/CheckIcon.tsx"] = {
    name: "CheckIcon",
    docgenInfo: CheckIcon.__docgenInfo,
    path: "src/components/icons/CheckIcon.tsx"
  };
}

function PortfolioIcon(props) {
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    iconName: "PortfolioIcon"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M6.43308 15.749C6.06531 14.8383 5.92674 13.8512 6.02954 12.8744C6.13233 11.8976 6.47335 10.961 7.02265 10.1468C7.57196 9.33253 8.31275 8.66561 9.17999 8.20454C10.0472 7.74347 11.0144 7.50235 11.9966 7.50235C12.9788 7.50235 13.9459 7.74347 14.8132 8.20454C15.6804 8.66561 16.4212 9.33253 16.9705 10.1468C17.5198 10.961 17.8608 11.8976 17.9636 12.8744C18.0664 13.8512 17.9279 14.8383 17.5601 15.749",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M10.1551 7.78601L11.8461 10.048C11.9643 10.2056 12.0503 10.3849 12.0992 10.5757C12.1481 10.7666 12.1589 10.9651 12.131 11.1601C12.1032 11.3551 12.0372 11.5428 11.9368 11.7123C11.8364 11.8817 11.7037 12.0298 11.5461 12.148L9.74609 13.498V14.248C9.74609 14.6458 9.58806 15.0274 9.30675 15.3087C9.02545 15.59 8.64392 15.748 8.24609 15.748",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M17.629 11.427L15.323 12.587C15.0175 12.7396 14.7732 12.9918 14.6305 13.302C14.4878 13.6121 14.4551 13.9618 14.538 14.293L14.91 15.749",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M6.74609 2.24799V0.747986",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M17.2461 2.24799V0.747986",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M7.5 18.748C7.5 19.1458 7.65804 19.5273 7.93934 19.8086C8.22064 20.09 8.60218 20.248 9 20.248H15C15.3978 20.248 15.7794 20.09 16.0607 19.8086C16.342 19.5273 16.5 19.1458 16.5 18.748",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M22.2461 15.748H1.74609C1.19381 15.748 0.746094 16.1957 0.746094 16.748V22.248C0.746094 22.8003 1.19381 23.248 1.74609 23.248H22.2461C22.7984 23.248 23.2461 22.8003 23.2461 22.248V16.748C23.2461 16.1957 22.7984 15.748 22.2461 15.748Z",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M3 15.748V3.74799C3 3.35016 3.15804 2.96863 3.43934 2.68733C3.72064 2.40602 4.10218 2.24799 4.5 2.24799H19.5C19.8978 2.24799 20.2794 2.40602 20.5607 2.68733C20.842 2.96863 21 3.35016 21 3.74799V15.748",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
}
PortfolioIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "PortfolioIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/PortfolioIcon.tsx"] = {
    name: "PortfolioIcon",
    docgenInfo: PortfolioIcon.__docgenInfo,
    path: "src/components/icons/PortfolioIcon.tsx"
  };
}

function EcommerceIcon(props) {
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    iconName: "EcommerceIcon"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M3.75 5.25001C3.74961 4.96756 3.80495 4.6878 3.91286 4.42677C4.02076 4.16574 4.17912 3.92857 4.37884 3.72885C4.57857 3.52912 4.81574 3.37077 5.07677 3.26286C5.33779 3.15496 5.61755 3.09961 5.9 3.10001",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M0.75 4.687C0.75 3.64284 1.16479 2.64145 1.90312 1.90312C2.64145 1.16479 3.64284 0.75 4.687 0.75",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M10.5001 16.5H7.6731C7.39125 16.5008 7.11717 16.4077 6.89422 16.2353C6.67127 16.0628 6.51217 15.821 6.4421 15.548L4.5421 9.061C4.49636 8.87508 4.49359 8.68119 4.534 8.49405C4.57441 8.3069 4.65694 8.13143 4.77532 7.98095C4.89369 7.83047 5.04481 7.70895 5.21718 7.62561C5.38955 7.54228 5.57864 7.49932 5.7701 7.5H18.9801C19.1719 7.49866 19.3614 7.54116 19.5343 7.62424C19.7071 7.70732 19.8587 7.82878 19.9775 7.97937C20.0962 8.12996 20.179 8.30569 20.2195 8.49314C20.26 8.68059 20.2571 8.87482 20.2111 9.061L19.9001 10.116",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M16.4999 7.5L15.6709 3.75",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M9 7.5L9.828 3.75",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M23.135 23.25L23.235 22.128C23.301 21.4017 23.1001 20.6762 22.67 20.0873C22.2399 19.4983 21.6099 19.0862 20.898 18.928L16.726 18V12C16.726 11.6022 16.5679 11.2206 16.2866 10.9393C16.0053 10.658 15.6238 10.5 15.226 10.5C14.8282 10.5 14.4466 10.658 14.1653 10.9393C13.884 11.2206 13.726 11.6022 13.726 12V21.75L12.026 20.472C11.731 20.2504 11.3659 20.1428 10.9979 20.1688C10.6298 20.1949 10.2836 20.3528 10.0227 20.6137C9.7618 20.8746 9.60383 21.2209 9.5778 21.5889C9.55176 21.9569 9.65942 22.322 9.88098 22.617L10.355 23.25",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
}
EcommerceIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "EcommerceIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/EcommerceIcon.tsx"] = {
    name: "EcommerceIcon",
    docgenInfo: EcommerceIcon.__docgenInfo,
    path: "src/components/icons/EcommerceIcon.tsx"
  };
}

function CheckCircleIcon(props) {
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    iconName: "CheckCircleIcon",
    applyColorToStroke: false
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "12",
    cy: "12",
    r: "10"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M9.87727 15.7413L7.38952 12.3449C7.1394 11.983 7.20585 11.4901 7.54289 11.2073L7.54289 11.2073C7.87994 10.9245 8.37685 10.9446 8.6899 11.2538L11.6026 14.2935C12.0767 14.7618 12.0453 15.5364 11.5349 15.9647L11.5349 15.9647C11.0244 16.3931 10.2561 16.2895 9.87727 15.7413Z",
    fill: "white"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M10.0811 15.9563C9.56249 15.5212 9.51156 14.7414 9.96912 14.2425L15.748 7.94176C16.0414 7.6218 16.5348 7.58958 16.8674 7.86865L16.8674 7.86865C17.2 8.14773 17.2539 8.63917 16.9898 8.98374L11.7882 15.7689C11.3764 16.3062 10.5996 16.3914 10.0811 15.9563L10.0811 15.9563Z",
    fill: "white"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M10.2123 12.8631C10.5034 13.2125 10.7169 13.4454 11.0856 13.0378C11.4544 12.6302 10.9692 14.0664 10.9692 14.0664L9.76593 13.6782L10.2123 12.8631Z",
    fill: "white"
  }));
}
CheckCircleIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckCircleIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/CheckCircleIcon.tsx"] = {
    name: "CheckCircleIcon",
    docgenInfo: CheckCircleIcon.__docgenInfo,
    path: "src/components/icons/CheckCircleIcon.tsx"
  };
}

function EllipsisIcon(props) {
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    iconName: "EllipsisIcon",
    applyColorToStroke: false
  }), /*#__PURE__*/React__default.createElement("filter", {
    id: "EllipsisIcon__filter",
    x: "0",
    y: "0",
    width: "100%",
    height: "100%"
  }, /*#__PURE__*/React__default.createElement("feComponentTransfer", null, /*#__PURE__*/React__default.createElement("feFuncA", {
    type: "linear",
    slope: "0.1"
  }))), /*#__PURE__*/React__default.createElement("circle", {
    cx: "12",
    cy: "12",
    r: "10",
    style: {
      filter: "url(#EllipsisIcon__filter)"
    }
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "6.5",
    cy: "12",
    r: "2"
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "12",
    cy: "12",
    r: "2"
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "17.5",
    cy: "12",
    r: "2"
  }));
}
EllipsisIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "EllipsisIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/EllipsisIcon.tsx"] = {
    name: "EllipsisIcon",
    docgenInfo: EllipsisIcon.__docgenInfo,
    path: "src/components/icons/EllipsisIcon.tsx"
  };
}

function InProgressIcon(props) {
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    iconName: "InProgressIcon",
    applyColorToStroke: false
  }), /*#__PURE__*/React__default.createElement("mask", {
    id: "InProgressIcon__mask--0",
    "mask-type": "alpha",
    maskUnits: "userSpaceOnUse",
    x: "2",
    y: "2",
    width: "20",
    height: "20"
  }, /*#__PURE__*/React__default.createElement("mask", {
    id: "InProgressIcon__mask--1",
    maskUnits: "userSpaceOnUse",
    x: "2",
    y: "12",
    width: "20",
    height: "10"
  }, /*#__PURE__*/React__default.createElement("path", {
    d: "M12 22C17.5229 22 22 17.5229 22 12L2.00003 12C2.00003 17.5229 6.47718 22 12 22Z",
    fill: "#232129"
  })), /*#__PURE__*/React__default.createElement("g", {
    mask: "url(#InProgressIcon__mask--1)"
  }, /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M11.9996 22C17.5224 22 21.9995 17.5228 21.9995 12C21.9995 6.47714 17.5224 2 11.9996 2C6.47672 2 1.99957 6.47714 1.99957 12C1.99957 17.5228 6.47672 22 11.9996 22ZM11.9994 19.9999C16.4177 19.9999 19.9994 16.4182 19.9994 11.9999C19.9994 7.58166 16.4177 3.99994 11.9994 3.99994C7.58111 3.99994 3.99939 7.58166 3.99939 11.9999C3.99939 16.4182 7.58111 19.9999 11.9994 19.9999Z",
    fill: "#2DE3DA"
  })), /*#__PURE__*/React__default.createElement("mask", {
    id: "InProgressIcon__mask--2",
    maskUnits: "userSpaceOnUse",
    x: "2",
    y: "2",
    width: "20",
    height: "20"
  }, /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M12 22C17.5228 22 22 17.5229 22 12C22 6.47718 17.5228 2.00003 12 2.00003C6.47714 2.00003 2 6.47718 2 12C2 17.5229 6.47714 22 12 22ZM11.9998 20C16.4181 20 19.9998 16.4182 19.9998 12C19.9998 7.58169 16.4181 3.99997 11.9998 3.99997C7.58154 3.99997 3.99982 7.58169 3.99982 12C3.99982 16.4182 7.58154 20 11.9998 20Z",
    fill: "#2DE3DA"
  })), /*#__PURE__*/React__default.createElement("g", {
    mask: "url(#InProgressIcon__mask--2)"
  }, /*#__PURE__*/React__default.createElement("path", {
    d: "M12 2.00003C6.47714 2.00003 2 6.47718 2 12L22 12C22 6.47718 17.5228 2.00003 12 2.00003Z",
    fill: "url(#InProgressIcon__linear)"
  }))), /*#__PURE__*/React__default.createElement("g", {
    mask: "url(#InProgressIcon__mask--0)"
  }, /*#__PURE__*/React__default.createElement("circle", {
    cx: "12",
    cy: "12",
    r: "9.99998",
    fill: "currentColor",
    style: {
      filter: "url(#InProgressIcon__filter)"
    }
  })), /*#__PURE__*/React__default.createElement("circle", {
    cx: "12",
    cy: "12",
    r: "4",
    fill: "currentColor"
  }), /*#__PURE__*/React__default.createElement("defs", null, /*#__PURE__*/React__default.createElement("linearGradient", {
    id: "InProgressIcon__linear",
    x1: "5.74999",
    y1: "12",
    x2: "18.25",
    y2: "12",
    gradientUnits: "userSpaceOnUse"
  }, /*#__PURE__*/React__default.createElement("stop", {
    stopColor: "#663399",
    stopOpacity: "0"
  }), /*#__PURE__*/React__default.createElement("stop", {
    offset: "1"
  })), /*#__PURE__*/React__default.createElement("filter", {
    id: "InProgressIcon__filter",
    x: "0",
    y: "0",
    width: "100%",
    height: "100%"
  }, /*#__PURE__*/React__default.createElement("feComponentTransfer", null, /*#__PURE__*/React__default.createElement("feFuncA", {
    type: "linear",
    slope: "0.3"
  })))));
}
InProgressIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "InProgressIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/InProgressIcon.tsx"] = {
    name: "InProgressIcon",
    docgenInfo: InProgressIcon.__docgenInfo,
    path: "src/components/icons/InProgressIcon.tsx"
  };
}

function CloseCircleIcon(props) {
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    iconName: "CloseCircleIcon",
    applyColorToStroke: false
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "12",
    cy: "12",
    r: "10",
    fill: "currentColor"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M16.6666 8.27331L15.7266 7.33331L12 11.06L8.27331 7.33331L7.33331 8.27331L11.06 12L7.33331 15.7266L8.27331 16.6666L12 12.94L15.7266 16.6666L16.6666 15.7266L12.94 12L16.6666 8.27331Z",
    fill: "white"
  }));
}
CloseCircleIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CloseCircleIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/CloseCircleIcon.tsx"] = {
    name: "CloseCircleIcon",
    docgenInfo: CloseCircleIcon.__docgenInfo,
    path: "src/components/icons/CloseCircleIcon.tsx"
  };
}

// TODO consolidate with ./CheckCircleIcon
// this one here already follows the Material Design icon grid
function SuccessIcon(props) {
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    iconName: "SuccessIcon",
    applyColorToStroke: false
  }), /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M22 12c0 5.5228-4.4772 10-10 10-5.52285 0-10-4.4772-10-10C2 6.47715 6.47715 2 12 2c5.5228 0 10 4.47715 10 10zm-11.3557 4.2175c-.2986-.0436-.5802-.2059-.76709-.4763l-2.48775-3.3963c-.25012-.362-.18368-.8548.15337-1.1376.33705-.2829.83396-.2627 1.14701.0465l1.76846 1.8456c.1645.1481.3187.207.5228.0394l4.7666-5.19716c.2935-.31996.7868-.35219 1.1194-.07311.3326.27907.3866.77052.1224 1.11509L11.788 15.7688c-.2786.3633-.724.5199-1.1437.4487z"
  }));
}
SuccessIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "SuccessIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/SuccessIcon.tsx"] = {
    name: "SuccessIcon",
    docgenInfo: SuccessIcon.__docgenInfo,
    path: "src/components/icons/SuccessIcon.tsx"
  };
}

function GeneralIcon(props) {
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    stroke: "none",
    iconName: "GeneralIcon"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M22.6607 9.27801C20.4579 10.703 19 13.1812 19 16C19 17.3216 19.3205 18.5684 19.888 19.6668C20.4176 19.122 20.8913 18.5226 21.2997 17.8777C21.1053 17.287 21 16.6558 21 16C21 14.2276 21.7685 12.6348 22.9905 11.5364C22.9583 10.7601 22.8456 10.0046 22.6607 9.27801Z",
    fill: "currentColor"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M16.602 21.994C15.5831 20.2303 15 18.1833 15 16C15 11.5725 17.3978 7.70503 20.9657 5.62533C21.3515 6.16694 21.6894 6.745 21.9733 7.35333C18.9991 9.08615 17 12.3096 17 16C17 17.819 17.4857 19.5246 18.3345 20.9941C17.7912 21.3775 17.2117 21.7128 16.602 21.994Z",
    fill: "currentColor"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M3.39698 5.14461C4.47981 5.69176 5.70393 5.99999 7.00005 5.99999C10.2635 5.99999 13.0705 4.04592 14.315 1.24401C13.6302 1.09734 12.9219 1.01441 12.1964 1.00171C11.1587 2.79417 9.22019 3.99999 7.00005 3.99999C6.25376 3.99999 5.53929 3.86374 4.88016 3.61476C4.33797 4.07559 3.84103 4.58807 3.39698 5.14461Z",
    fill: "currentColor"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M18.0084 2.78435C16.1602 7.03088 11.9269 9.99999 7.00005 9.99999C5.02241 9.99999 3.15651 9.5216 1.51176 8.67422C1.7159 8.02985 1.97778 7.41116 2.29133 6.82424C3.69453 7.57457 5.29761 7.99999 7.00005 7.99999C11.1606 7.99999 14.7277 5.45915 16.2343 1.8445C16.8567 2.1043 17.4501 2.41965 18.0084 2.78435Z",
    fill: "currentColor"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M9.91093 22.8019C9.33274 18.9519 6.01113 16 2.00005 16C1.91687 16 1.83398 16.0013 1.75141 16.0038C2.03454 16.728 2.39221 17.4148 2.81499 18.0549C5.11332 18.367 6.99803 19.9805 7.70253 22.1289C8.40431 22.427 9.14343 22.6543 9.91093 22.8019Z",
    fill: "currentColor"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M1.00012 12.0411C1.32983 12.0139 1.66332 12 2.00005 12C8.23232 12 13.3549 16.751 13.9436 22.8288C13.3127 22.9413 12.6633 23 12 23C11.9836 23 11.9671 23 11.9507 22.9999C11.4489 17.9466 7.18536 14 2.00005 14C1.72648 14 1.45547 14.011 1.18745 14.0325C1.06682 13.3868 1.00261 12.7212 1.00012 12.0411Z",
    fill: "currentColor"
  }));
}
GeneralIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "GeneralIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/GeneralIcon.tsx"] = {
    name: "GeneralIcon",
    docgenInfo: GeneralIcon.__docgenInfo,
    path: "src/components/icons/GeneralIcon.tsx"
  };
}

function ReportsIcon(props) {
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    iconName: "ReportsIcon"
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "12",
    cy: "12",
    r: "5",
    stroke: "currentColor",
    strokeWidth: "2"
  }), /*#__PURE__*/React__default.createElement("rect", {
    x: "17",
    y: "4",
    width: "4.5",
    height: "2",
    fill: "currentColor"
  }), /*#__PURE__*/React__default.createElement("rect", {
    x: "4.5",
    y: "6",
    width: "2",
    height: "2",
    fill: "currentColor"
  }), /*#__PURE__*/React__default.createElement("rect", {
    x: "15.5",
    y: "18",
    width: "4.5",
    height: "2",
    fill: "currentColor"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M3.5 11.5V20.5H12.5",
    stroke: "currentColor",
    strokeWidth: "2"
  }));
}
ReportsIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "ReportsIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/ReportsIcon.tsx"] = {
    name: "ReportsIcon",
    docgenInfo: ReportsIcon.__docgenInfo,
    path: "src/components/icons/ReportsIcon.tsx"
  };
}

function SkullIcon(props) {
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    stroke: "none",
    iconName: "SkullIcon"
  }), /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M12 2C16.4183 2 20 5.58172 20 10V14C20 15.7416 18.8869 17.2233 17.3333 17.7724V18C17.3333 20.2091 15.5425 22 13.3333 22H10.6667C8.45753 22 6.66667 20.2091 6.66667 18V17.7724C5.11308 17.2233 4 15.7416 4 14V10C4 5.58172 7.58172 2 12 2Z",
    fill: "white"
  }), /*#__PURE__*/React__default.createElement("rect", {
    x: "7",
    y: "11",
    width: "3",
    height: "3",
    rx: "1.5",
    fill: "currentColor"
  }), /*#__PURE__*/React__default.createElement("rect", {
    x: "14",
    y: "11",
    width: "3",
    height: "3",
    rx: "1.5",
    fill: "currentColor"
  }), /*#__PURE__*/React__default.createElement("line", {
    x1: "7",
    y1: "18.5",
    x2: "17",
    y2: "18.5",
    strokeWidth: "1.5",
    stroke: "currentColor"
  }), /*#__PURE__*/React__default.createElement("mask", {
    id: "path-9-inside-1",
    fill: "white"
  }, /*#__PURE__*/React__default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M12 2C16.4183 2 20 5.58172 20 10V14C20 15.7416 18.8869 17.2233 17.3333 17.7724V18C17.3333 20.2091 15.5425 22 13.3333 22H10.6667C8.45753 22 6.66667 20.2091 6.66667 18V17.7724C5.11308 17.2233 4 15.7416 4 14V10C4 5.58172 7.58172 2 12 2Z"
  })), /*#__PURE__*/React__default.createElement("path", {
    d: "M17.3333 17.7724L16.6668 15.8867L15.3333 16.358V17.7724H17.3333ZM6.66667 17.7724H8.66667V16.358L7.33316 15.8867L6.66667 17.7724ZM22 10C22 4.47715 17.5228 0 12 0V4C15.3137 4 18 6.68629 18 10H22ZM22 14V10H18V14H22ZM17.9998 19.6581C20.3275 18.8354 22 16.6156 22 14H18C18 14.8677 17.4463 15.6112 16.6668 15.8867L17.9998 19.6581ZM15.3333 17.7724V18H19.3333V17.7724H15.3333ZM15.3333 18C15.3333 19.1046 14.4379 20 13.3333 20V24C16.647 24 19.3333 21.3137 19.3333 18H15.3333ZM13.3333 20H10.6667V24H13.3333V20ZM10.6667 20C9.5621 20 8.66667 19.1046 8.66667 18H4.66667C4.66667 21.3137 7.35296 24 10.6667 24V20ZM8.66667 18V17.7724H4.66667V18H8.66667ZM2 14C2 16.6156 3.67249 18.8354 6.00017 19.6581L7.33316 15.8867C6.55367 15.6112 6 14.8677 6 14H2ZM2 10V14H6V10H2ZM12 0C6.47715 0 2 4.47715 2 10H6C6 6.68629 8.68629 4 12 4V0Z",
    fill: "currentColor",
    mask: "url(#path-9-inside-1)"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M12 13L13.299 15.25H10.701L12 13Z",
    fill: "currentColor",
    stroke: "currentColor",
    strokeWidth: "0.5"
  }));
}
SkullIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "SkullIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/SkullIcon.tsx"] = {
    name: "SkullIcon",
    docgenInfo: SkullIcon.__docgenInfo,
    path: "src/components/icons/SkullIcon.tsx"
  };
}

function BuildsIcon(props) {
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    iconName: "BuildsIcon"
  }), /*#__PURE__*/React__default.createElement("rect", {
    y: "0.999935",
    width: "9.54724",
    height: "9.54724",
    transform: "matrix(0.866044 0.499967 -0.866044 0.499967 12.8699 11.55)",
    stroke: "currentColor",
    strokeWidth: "2"
  }), /*#__PURE__*/React__default.createElement("rect", {
    y: "0.999935",
    width: "9.54724",
    height: "9.54724",
    transform: "matrix(0.866044 0.499967 -0.866044 0.499967 12.8664 7)",
    stroke: "currentColor",
    strokeWidth: "2"
  }), /*#__PURE__*/React__default.createElement("rect", {
    y: "0.999935",
    width: "9.54724",
    height: "9.54724",
    transform: "matrix(0.866044 0.499967 -0.866044 0.499967 12.8699 2)",
    fill: "white",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeMiterlimit: "11.4737"
  }));
}
BuildsIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BuildsIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/BuildsIcon.tsx"] = {
    name: "BuildsIcon",
    docgenInfo: BuildsIcon.__docgenInfo,
    path: "src/components/icons/BuildsIcon.tsx"
  };
}

function IntegrationsIcon(props) {
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    iconName: "IntegrationsIcon"
  }), /*#__PURE__*/React__default.createElement("circle", {
    r: "2.125",
    transform: "matrix(1 0 0 -1 5.5 5.5)",
    stroke: "currentColor",
    strokeWidth: "1.75"
  }), /*#__PURE__*/React__default.createElement("circle", {
    r: "2.125",
    transform: "matrix(1 0 0 -1 12 12)",
    stroke: "currentColor",
    strokeWidth: "1.75"
  }), /*#__PURE__*/React__default.createElement("circle", {
    r: "2.75",
    transform: "matrix(1 0 0 -1 18.75 18.5)",
    fill: "currentColor"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M7.5 5.5H17.25C19.0449 5.5 20.5 6.95507 20.5 8.75V8.75C20.5 10.5449 19.0449 12 17.25 12H14",
    stroke: "currentColor",
    strokeWidth: "2"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M14 18.5L6.75 18.5C4.95508 18.5 3.5 17.0449 3.5 15.25V15.25C3.5 13.4551 4.95507 12 6.75 12L10.5 12",
    stroke: "currentColor",
    strokeWidth: "2"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M11.1517 15.8483L13.8033 18.5L11.1517 21.1517",
    stroke: "currentColor",
    strokeWidth: "2"
  }));
}
IntegrationsIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "IntegrationsIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/IntegrationsIcon.tsx"] = {
    name: "IntegrationsIcon",
    docgenInfo: IntegrationsIcon.__docgenInfo,
    path: "src/components/icons/IntegrationsIcon.tsx"
  };
}

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose$1(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var isFunction$1 = function isFunction(obj) {
  return typeof obj === 'function';
};

var MDXContext = React__default.createContext({});
var useMDXComponents = function useMDXComponents(components) {
  var contextComponents = React__default.useContext(MDXContext);
  var allComponents = contextComponents;

  if (components) {
    allComponents = isFunction$1(components) ? components(contextComponents) : _objectSpread2$1({}, contextComponents, {}, components);
  }

  return allComponents;
};
var MDXProvider = function MDXProvider(props) {
  var allComponents = useMDXComponents(props.components);
  return React__default.createElement(MDXContext.Provider, {
    value: allComponents
  }, props.children);
};
var DEFAULTS = {
  inlineCode: 'code',
  wrapper: function wrapper(_ref) {
    var children = _ref.children;
    return React__default.createElement(React__default.Fragment, {}, children);
  }
};
var MDXCreateElement = React.forwardRef(function (props, ref) {
  var propComponents = props.components,
      mdxType = props.mdxType,
      originalType = props.originalType,
      parentName = props.parentName,
      etc = _objectWithoutProperties$1(props, ["components", "mdxType", "originalType", "parentName"]);

  var components = useMDXComponents(propComponents);
  var type = mdxType;
  var Component = components["".concat(parentName, ".").concat(type)] || components[type] || DEFAULTS[type] || originalType;

  if (propComponents) {
    return React__default.createElement(Component, _objectSpread2$1({
      ref: ref
    }, etc, {
      components: propComponents
    }));
  }

  return React__default.createElement(Component, _objectSpread2$1({
    ref: ref
  }, etc));
});
MDXCreateElement.displayName = 'MDXCreateElement';

var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function getMergeFunction(key, options) {
	if (!options.customMerge) {
		return deepmerge
	}
	var customMerge = options.customMerge(key);
	return typeof customMerge === 'function' ? customMerge : deepmerge
}

function getEnumerableOwnPropertySymbols(target) {
	return Object.getOwnPropertySymbols
		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
			return target.propertyIsEnumerable(symbol)
		})
		: []
}

function getKeys(target) {
	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
}

function propertyIsOnObject(object, property) {
	try {
		return property in object
	} catch(_) {
		return false
	}
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		getKeys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	getKeys(source).forEach(function(key) {
		if (propertyIsUnsafe(target, key)) {
			return
		}

		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
		} else {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
	// implementations can use it. The caller may not replace it.
	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

var cjs = deepmerge_1;

function memoize(fn) {
  var cache = {};
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

var index = memoize(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
  /* o */
  && prop.charCodeAt(1) === 110
  /* n */
  && prop.charCodeAt(2) < 91;
}
/* Z+1 */
);

function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }

// based on https://github.com/developit/dlv
var get = function get(obj, key, def, p, undef) {
  key = key && key.split ? key.split('.') : [key];

  for (p = 0; p < key.length; p++) {
    obj = obj ? obj[key[p]] : undef;
  }

  return obj === undef ? def : obj;
};
var defaultBreakpoints = [40, 52, 64].map(function (n) {
  return n + 'em';
});
var defaultTheme = {
  space: [0, 4, 8, 16, 32, 64, 128, 256, 512],
  fontSizes: [12, 14, 16, 20, 24, 32, 48, 64, 72]
};
var aliases = {
  bg: 'backgroundColor',
  m: 'margin',
  mt: 'marginTop',
  mr: 'marginRight',
  mb: 'marginBottom',
  ml: 'marginLeft',
  mx: 'marginX',
  my: 'marginY',
  p: 'padding',
  pt: 'paddingTop',
  pr: 'paddingRight',
  pb: 'paddingBottom',
  pl: 'paddingLeft',
  px: 'paddingX',
  py: 'paddingY'
};
var multiples = {
  marginX: ['marginLeft', 'marginRight'],
  marginY: ['marginTop', 'marginBottom'],
  paddingX: ['paddingLeft', 'paddingRight'],
  paddingY: ['paddingTop', 'paddingBottom'],
  size: ['width', 'height']
};
var scales = {
  color: 'colors',
  backgroundColor: 'colors',
  borderColor: 'colors',
  margin: 'space',
  marginTop: 'space',
  marginRight: 'space',
  marginBottom: 'space',
  marginLeft: 'space',
  marginX: 'space',
  marginY: 'space',
  padding: 'space',
  paddingTop: 'space',
  paddingRight: 'space',
  paddingBottom: 'space',
  paddingLeft: 'space',
  paddingX: 'space',
  paddingY: 'space',
  top: 'space',
  right: 'space',
  bottom: 'space',
  left: 'space',
  gridGap: 'space',
  gridColumnGap: 'space',
  gridRowGap: 'space',
  gap: 'space',
  columnGap: 'space',
  rowGap: 'space',
  fontFamily: 'fonts',
  fontSize: 'fontSizes',
  fontWeight: 'fontWeights',
  lineHeight: 'lineHeights',
  letterSpacing: 'letterSpacings',
  border: 'borders',
  borderTop: 'borders',
  borderRight: 'borders',
  borderBottom: 'borders',
  borderLeft: 'borders',
  borderWidth: 'borderWidths',
  borderStyle: 'borderStyles',
  borderRadius: 'radii',
  borderTopRightRadius: 'radii',
  borderTopLeftRadius: 'radii',
  borderBottomRightRadius: 'radii',
  borderBottomLeftRadius: 'radii',
  borderTopWidth: 'borderWidths',
  borderTopColor: 'colors',
  borderTopStyle: 'borderStyles',
  borderBottomWidth: 'borderWidths',
  borderBottomColor: 'colors',
  borderBottomStyle: 'borderStyles',
  borderLeftWidth: 'borderWidths',
  borderLeftColor: 'colors',
  borderLeftStyle: 'borderStyles',
  borderRightWidth: 'borderWidths',
  borderRightColor: 'colors',
  borderRightStyle: 'borderStyles',
  outlineColor: 'colors',
  boxShadow: 'shadows',
  textShadow: 'shadows',
  zIndex: 'zIndices',
  width: 'sizes',
  minWidth: 'sizes',
  maxWidth: 'sizes',
  height: 'sizes',
  minHeight: 'sizes',
  maxHeight: 'sizes',
  flexBasis: 'sizes',
  size: 'sizes',
  // svg
  fill: 'colors',
  stroke: 'colors'
};

var positiveOrNegative = function positiveOrNegative(scale, value) {
  if (typeof value !== 'number' || value >= 0) {
    return get(scale, value, value);
  }

  var absolute = Math.abs(value);
  var n = get(scale, absolute, absolute);
  if (typeof n === 'string') return '-' + n;
  return n * -1;
};

var transforms = ['margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'marginX', 'marginY', 'top', 'bottom', 'left', 'right'].reduce(function (acc, curr) {
  var _extends2;

  return _extends$1({}, acc, (_extends2 = {}, _extends2[curr] = positiveOrNegative, _extends2));
}, {});
var responsive = function responsive(styles) {
  return function (theme) {
    var next = {};
    var breakpoints = get(theme, 'breakpoints', defaultBreakpoints);
    var mediaQueries = [null].concat(breakpoints.map(function (n) {
      return "@media screen and (min-width: " + n + ")";
    }));

    for (var key in styles) {
      var value = typeof styles[key] === 'function' ? styles[key](theme) : styles[key];
      if (value == null) continue;

      if (!Array.isArray(value)) {
        next[key] = value;
        continue;
      }

      for (var i = 0; i < value.slice(0, mediaQueries.length).length; i++) {
        var media = mediaQueries[i];

        if (!media) {
          next[key] = value[i];
          continue;
        }

        next[media] = next[media] || {};
        if (value[i] == null) continue;
        next[media][key] = value[i];
      }
    }

    return next;
  };
};
var css = function css(args) {
  return function (props) {
    if (props === void 0) {
      props = {};
    }

    var theme = _extends$1({}, defaultTheme, {}, props.theme || props);

    var result = {};
    var obj = typeof args === 'function' ? args(theme) : args;
    var styles = responsive(obj)(theme);

    for (var key in styles) {
      var x = styles[key];
      var val = typeof x === 'function' ? x(theme) : x;

      if (key === 'variant') {
        var variant = css(get(theme, val))(theme);
        result = _extends$1({}, result, {}, variant);
        continue;
      }

      if (val && typeof val === 'object') {
        result[key] = css(val)(theme);
        continue;
      }

      var prop = get(aliases, key, key);
      var scaleName = get(scales, prop);
      var scale = get(theme, scaleName, get(theme, prop, {}));
      var transform = get(transforms, prop, get);
      var value = transform(scale, val, val);

      if (multiples[prop]) {
        var dirs = multiples[prop];

        for (var i = 0; i < dirs.length; i++) {
          result[dirs[i]] = value;
        }
      } else {
        result[prop] = value;
      }
    }

    return result;
  };
};

var getCSS = function getCSS(props) {
  if (!props.sx && !props.css) { return undefined; }
  return function (theme) {
    var styles = css(props.sx)(theme);
    var raw = typeof props.css === 'function' ? props.css(theme) : props.css;
    return [styles, raw];
  };
};

var parseProps = function parseProps(props) {
  if (!props) { return null; }
  var next = {};

  for (var key in props) {
    if (key === 'sx') { continue; }
    next[key] = props[key];
  }

  var css$$1 = getCSS(props);
  if (css$$1) { next.css = css$$1; }
  return next;
};

var jsx$1 = function jsx$$1(type, props) {
  var arguments$1 = arguments;

  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments$1[_key];
  }

  return core.jsx.apply(undefined, [type, parseProps(props)].concat(children));
};

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$2(Object(source), true).forEach(function (key) {
        _defineProperty$2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties$2(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose$2(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _slicedToArray$1(arr, i) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _nonIterableRest$1();
}

function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit$1(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var canUseSymbol$1 = typeof Symbol === 'function' && Symbol["for"];
var REACT_ELEMENT = canUseSymbol$1 ? Symbol["for"]('react.element') : 0xeac7;
var FORWARD_REF = canUseSymbol$1 ? Symbol["for"]('react.forward_ref') : 0xeac7;

var isMergeableObject$1 = function isMergeableObject(n) {
  return !!n && _typeof(n) === 'object' && n.$$typeof !== REACT_ELEMENT && n.$$typeof !== FORWARD_REF;
};

var arrayMerge = function arrayMerge(destinationArray, sourceArray, options) {
  return sourceArray;
};

var merge = function merge(a, b) {
  return cjs(a, b, {
    isMergeableObject: isMergeableObject$1,
    arrayMerge: arrayMerge
  });
};

merge.all = function () {
  var arguments$1 = arguments;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments$1[_key];
  }

  return cjs.all(args, {
    isMergeableObject: isMergeableObject$1,
    arrayMerge: arrayMerge
  });
};

var styled = function styled(tag) {
  return function () {
    var arguments$1 = arguments;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments$1[_key];
    }

    var Styled = React.forwardRef(function (_ref, ref) {
      var as = _ref.as,
          props = _objectWithoutProperties$2(_ref, ["as"]);

      var shouldForwardProps = typeof tag !== 'string' || as && typeof as !== 'string';
      var theme = React.useContext(core.ThemeContext);
      var nextProps = shouldForwardProps ? props : {};
      var styles = {};
      args.forEach(function (arg) {
        var style = typeof arg === 'function' ? arg(_objectSpread2$2({
          theme: theme
        }, props)) : arg;
        Object.assign(styles, style);
      });

      if (!shouldForwardProps) {
        for (var key in props) {
          if (!index(key)) { continue; }
          nextProps[key] = props[key];
        }
      }

      return jsx$1(as || tag, _objectSpread2$2({}, nextProps, {
        ref: ref,
        css: styles
      }));
    });
    return Styled;
  };
};

var themed = function themed(key) {
  return function (props) {
    return css(get(props.theme, "styles.".concat(key)))(props.theme);
  };
};

var tags = ['p', 'b', 'i', 'a', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'img', 'pre', 'code', 'ol', 'ul', 'li', 'blockquote', 'hr', 'em', 'table', 'tr', 'th', 'td', 'em', 'strong', 'delete', // mdx
'inlineCode', 'thematicBreak', // other
'div', // theme-ui
'root'];
var aliases$1 = {
  inlineCode: 'code',
  thematicBreak: 'hr',
  root: 'div'
};

var alias = function alias(n) {
  return aliases$1[n] || n;
};

var Styled = styled('div')(themed('div'));
var components = {};
tags.forEach(function (tag) {
  components[tag] = styled(alias(tag))(themed(tag));
  Styled[tag] = components[tag];
});
var createComponents = function createComponents() {
  var components = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var next = {};
  Object.keys(components).forEach(function (key) {
    next[key] = styled(components[key])(themed(key));
  });
  return next;
};

var Context = React.createContext({
  emotionVersion: package_json.version,
  theme: null,
  components: components
});
var useThemeUI = function useThemeUI() {
  return React.useContext(Context);
};

var toVarName = function toVarName(key) {
  return "--theme-ui-".concat(key);
};

var toVarValue = function toVarValue(key, value) {
  return "var(".concat(toVarName(key), ", ").concat(value, ")");
};

var join = function join() {
  var arguments$1 = arguments;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments$1[_key];
  }

  return args.filter(Boolean).join('-');
};

var numberScales = {
  fontWeights: true,
  lineHeights: true
};
var reservedKeys = {
  useCustomProperties: true,
  initialColorModeName: true,
  initialColorMode: true
};

var toPixel = function toPixel(key, value) {
  if (typeof value !== 'number') { return value; }
  if (numberScales[key]) { return value; }
  return value + 'px';
}; // convert theme values to custom properties


var toCustomProperties = function toCustomProperties(obj, parent, themeKey) {
  var next = Array.isArray(obj) ? [] : {};

  for (var key in obj) {
    var value = obj[key];
    var name = join(parent, key);

    if (value && _typeof(value) === 'object') {
      next[key] = toCustomProperties(value, name, key);
      continue;
    }

    if (reservedKeys[key]) {
      next[key] = value;
      continue;
    }

    var val = toPixel(themeKey || key, value);
    next[key] = toVarValue(name, val);
  }

  return next;
};

var STORAGE_KEY = 'theme-ui-color-mode';
var HAS_STORAGE = typeof Storage !== 'undefined';
var storage = {
  get: function get$$1(init) {
    return HAS_STORAGE && window.localStorage.getItem(STORAGE_KEY) || init;
  },
  set: function set(value) {
    return HAS_STORAGE && window.localStorage.setItem(STORAGE_KEY, value);
  }
};
var getMediaQuery = function getMediaQuery() {
  var darkQuery = '(prefers-color-scheme: dark)';
  var mql = window.matchMedia ? window.matchMedia(darkQuery) : {};
  var dark = mql.media === darkQuery;
  return dark && mql.matches;
};

var getName = function getName(theme) {
  return theme.initialColorModeName || theme.initialColorMode || 'default';
};

var useColorState = function useColorState(theme) {
  var _useState = React.useState(getName(theme)),
      _useState2 = _slicedToArray$1(_useState, 2),
      mode = _useState2[0],
      setMode = _useState2[1];

  React.useEffect(function () {
    // initialize
    var stored = storage.get();
    document.body.classList.remove('theme-ui-' + stored);
    var dark = getMediaQuery();
    if (!stored && dark && theme.useColorSchemeMediaQuery) { return setMode('dark'); }
    if (!stored || stored === mode) { return; }
    setMode(stored);
  }, []);
  React.useEffect(function () {
    if (!mode) { return; }
    storage.set(mode);
  }, [mode]);

  if (process.env.NODE_ENV !== 'production') {
    if (theme.colors && theme.colors.modes && Object.keys(theme.colors.modes).indexOf(getName(theme)) > -1) {
      console.warn('The `initialColorMode` value should be a unique name' + ' and cannot reference a key in `theme.colors.modes`.');
    }
  }

  return [mode, setMode];
};

var applyColorMode = function applyColorMode(theme, mode) {
  if (!mode) { return theme; }
  var modes = get(theme, 'colors.modes', {});
  return merge.all({}, theme, {
    colors: get(modes, mode, {})
  });
};

var BaseProvider = function BaseProvider(_ref) {
  var context = _ref.context,
      components$$1 = _ref.components,
      children = _ref.children;

  var theme = _objectSpread2$2({}, context.theme);

  if (theme.useCustomProperties !== false) {
    theme.colors = toCustomProperties(theme.colors, 'colors');
  }

  return jsx$1(core.ThemeContext.Provider, {
    value: theme
  }, jsx$1(MDXProvider, {
    components: components$$1
  }, jsx$1(Context.Provider, {
    value: context,
    children: children
  })));
};

var RootProvider = function RootProvider(_ref2) {
  var _ref2$theme = _ref2.theme,
      propsTheme = _ref2$theme === void 0 ? {} : _ref2$theme,
      components$$1 = _ref2.components,
      children = _ref2.children;
  // components are provided in the default Context
  var outer = useThemeUI();
  var propsThemeObject = typeof propsTheme === 'function' ? propsTheme({}) : propsTheme;

  var _useColorState = useColorState(outer.theme || propsThemeObject),
      _useColorState2 = _slicedToArray$1(_useColorState, 2),
      colorMode = _useColorState2[0],
      setColorMode = _useColorState2[1];

  var theme = applyColorMode(outer.theme || propsThemeObject, colorMode);

  var context = _objectSpread2$2({}, outer, {
    __THEME_UI__: true,
    colorMode: colorMode,
    setColorMode: setColorMode,
    components: _objectSpread2$2({}, outer.components, {}, createComponents(components$$1)),
    theme: theme
  });

  React.useEffect(function () {
    window.__THEME_UI__ = context;
  }, [context.theme, context.colorMode]);
  return jsx$1(BaseProvider, {
    context: context,
    components: context.components,
    children: children
  });
};

var NestedProvider = function NestedProvider(_ref3) {
  var theme = _ref3.theme,
      components$$1 = _ref3.components,
      children = _ref3.children;
  var outer = useThemeUI();
  var context = typeof theme === 'function' ? _objectSpread2$2({}, outer, {
    theme: theme(outer.theme)
  }) : merge.all({}, outer, {
    theme: theme
  });
  return jsx$1(BaseProvider, {
    context: context,
    components: createComponents(components$$1),
    children: children
  });
};

var ThemeProvider = function ThemeProvider(props) {
  var outer = useThemeUI();

  if (process.env.NODE_ENV !== 'production') {
    if (outer.emotionVersion !== package_json.version) {
      console.warn('Multiple versions of Emotion detected,', 'and theming might not work as expected.', 'Please ensure there is only one copy of @emotion/core installed in your application.');
    }
  }

  if (!props.scoped && outer.__THEME_UI__) {
    return jsx$1(NestedProvider, props);
  }

  return jsx$1(RootProvider, props);
};

var Box = styled('div')({
  boxSizing: 'border-box',
  minWidth: 0
});
var Flex = styled(Box)({
  display: 'flex'
}); // root/page layout

var zIndices = {
  background: 0,
  base: 1,
  dropdowns: 10,
  toasts: 100,
  modals: 1000,
  a11yIndicators: 10000
};

var _baseSpace = _toArray(y),
    first = _baseSpace[0],
    rest = _baseSpace.slice(1);

var PX_IN_REM = 16;
var space = [first, "".concat(2 / PX_IN_REM, "rem")].concat(_toConsumableArray(rest), ["".concat(84 / PX_IN_REM, "rem"), "".concat(96 / PX_IN_REM, "rem")]);

var breakpoints = {
  mobile: 360,
  phablet: 550,
  tablet: 750,
  desktop: 1000,
  hd: 1300
};
/**
 * ThemeUI expects "breakpoints" scale to consist of
 * strings representing each breakpoint with a CSS length unit INCLUDED
 * ordered in mobile-first order
 *
 * Hence we need to extract values from our "breakpoints" object,
 * sort them in ascending order and append "px" unit
 */

var breakpointsInPixels = Object.values(breakpoints);
breakpointsInPixels.sort(function (a, b) {
  return a - b;
});
var breakpointsList = breakpointsInPixels.map(function (breakpoint) {
  return "".concat(breakpoint, "px");
});

var tones = {
  BRAND: {
    superLight: colors.purple[5],
    lighter: colors.purple[10],
    light: colors.purple[20],
    medium: colors.purple[40],
    dark: colors.purple[60],
    darker: colors.purple[70],
    superDark: colors.purple[90],
    text: colors.purple[60]
  },
  SUCCESS: {
    superLight: colors.green[5],
    lighter: colors.green[10],
    light: colors.green[20],
    medium: colors.green[50],
    dark: colors.green[80],
    darker: colors.green[90],
    superDark: colors.green[90],
    text: colors.green[80]
  },
  DANGER: {
    superLight: colors.red[5],
    lighter: colors.red[10],
    light: colors.red[20],
    medium: colors.red[50],
    dark: colors.red[70],
    darker: colors.red[80],
    superDark: colors.red[90],
    text: colors.red[70]
  },
  NEUTRAL: {
    superLight: colors.grey[5],
    lighter: colors.grey[10],
    light: colors.grey[20],
    medium: colors.grey[40],
    dark: colors.grey[60],
    darker: colors.grey[70],
    superDark: colors.black,
    text: colors.grey[90]
  },
  WARNING: {
    superLight: colors.orange[5],
    lighter: colors.orange[10],
    light: colors.orange[30],
    medium: colors.orange[50],
    mediumInverted: colors.blackFade[70],
    dark: colors.yellow[50],
    darker: colors.orange[70],
    superDark: colors.yellow[90],
    text: colors.yellow[90],
    textInverted: colors.blackFade[90]
  }
};

var themeColors = colors;
/**
 * Tones
 */

var themeTones = tones;
/**
 * Font families
 */

var themeFonts = i;
/**
 * Font weights
 */

var themeFontWeights = t;
/**
 * Font sizes
 */

var themeFontSizes = b;
/**
 * Line heights
 */

var themeLineHeights = n;
/**
 * Letter spacings
 */

var themeLetterSpacings = d;
/**
 * Space
 */

var themeSpace = space;
/**
 * Radii
 */

var themeRadii = S;
/**
 * Shadows
 */

var themeShadows = u;
/**
 * Z indices
 */

var themeZIndices = zIndices;
/**
 * Breakpoints
 */

var themeBreakpoints = breakpointsList;
/**
 * Media breakpoints
 */

var themeMediaBreakpoints = breakpoints;
/**
 * Media queries
 */

var themeMediaQueries = Object.entries(breakpoints).reduce(function (memo, _ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      breakpoint = _ref2[0],
      widthInPx = _ref2[1];

  return _objectSpread2({}, memo, _defineProperty({}, breakpoint, "@media (min-width: ".concat(widthInPx, "px)")));
}, {});
/**
 * Transitions
 */

var themeTransitions = j;
/**
 * Cards
 */

var themeCardStyles = {
  frame: {
    background: colors.primaryBackground,
    borderRadius: S[2],
    boxShadow: u.raised
  },
  space: {
    DEFAULT: {
      padding: "".concat(space[6], " ").concat(space[3], " ").concat(space[5], " ").concat(space[7])
    },
    M: {
      padding: "".concat(space[5], " ").concat(space[9])
    },
    L: {
      padding: "".concat(space[7], " ").concat(space[9], " ").concat(space[8])
    }
  }
};
var defaultTheme$1 = {
  colors: themeColors,
  tones: themeTones,
  fonts: themeFonts,
  fontWeights: themeFontWeights,
  fontSizes: themeFontSizes,
  lineHeights: themeLineHeights,
  letterSpacings: themeLetterSpacings,
  space: themeSpace,
  radii: themeRadii,
  shadows: themeShadows,
  zIndices: themeZIndices,
  breakpoints: themeBreakpoints,
  mediaBreakpoints: themeMediaBreakpoints,
  mediaQueries: themeMediaQueries,
  transitions: themeTransitions,
  cardStyles: themeCardStyles
};
function getTheme() {
  return defaultTheme$1;
}

function ThemeProvider$1(_ref) {
  var children = _ref.children,
      theme = _ref.theme;
  var themeValue = React__default.useMemo(function () {
    var baseTheme = getTheme();

    if (typeof theme === "function") {
      return theme(baseTheme);
    }

    return theme || baseTheme;
  }, [theme, getTheme]);
  return /*#__PURE__*/React__default.createElement(ThemeProvider, {
    theme: themeValue
  }, children);
} // To distinguish from Theme UI's ThemeProvider

ThemeProvider$1.propTypes = {
  children: _pt__default.node
};
ThemeProvider$1.displayName = "GatsbyInterfaceThemeProvider";
function useTheme() {
  // @ts-ignore
  return useThemeUI().theme;
}
ThemeProvider$1.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "GatsbyInterfaceThemeProvider",
  "props": {
    "children": {
      "required": false,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    },
    "theme": {
      "required": false,
      "tsType": {
        "name": "union",
        "raw": "Theme | ((baseTheme: Theme) => Theme)",
        "elements": [{
          "name": "Theme"
        }, {
          "name": "unknown"
        }]
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/ThemeProvider/ThemeProvider.tsx"] = {
    name: "ThemeProvider",
    docgenInfo: ThemeProvider$1.__docgenInfo,
    path: "src/components/ThemeProvider/ThemeProvider.tsx"
  };
}

function FreePlanIcon(props) {
  var theme = useTheme();
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    iconName: "FreePlanIcon",
    stroke: "none"
  }), /*#__PURE__*/React__default.createElement("circle", {
    r: "10.5",
    transform: "matrix(1 0 0 -1 12 12)",
    stroke: theme.colors.orange[40]
  }), /*#__PURE__*/React__default.createElement("circle", {
    r: "2",
    transform: "matrix(1 0 0 -1 19.5 4.5)",
    fill: theme.colors.orange[60]
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "12",
    cy: "12",
    r: "2",
    fill: theme.colors.orange[60]
  }));
}
FreePlanIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "FreePlanIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/FreePlanIcon.tsx"] = {
    name: "FreePlanIcon",
    docgenInfo: FreePlanIcon.__docgenInfo,
    path: "src/components/icons/FreePlanIcon.tsx"
  };
}

function ProfessionalPlanIcon(props) {
  var theme = useTheme();
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    iconName: "ProfessionalPlanIcon",
    stroke: "none"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M4.65774 4.54746C4.97369 4.23151 5.4624 4.05164 6.15117 4.06176C6.84209 4.07191 7.69058 4.27476 8.6476 4.67453C10.5592 5.47307 12.8081 7.01711 14.9211 9.13008C17.034 11.243 18.5781 13.4919 19.3766 15.4036C19.7764 16.3606 19.9792 17.2091 19.9894 17.9C19.9995 18.5887 19.8196 19.0775 19.5037 19.3934C19.1877 19.7094 18.699 19.8892 18.0103 19.8791C17.3193 19.869 16.4708 19.6661 15.5138 19.2663C13.6022 18.4678 11.3533 16.9238 9.24036 14.8108C7.12739 12.6978 5.58335 10.449 4.78481 8.53732C4.38504 7.5803 4.18219 6.73181 4.17204 6.0409C4.16192 5.35212 4.34179 4.86341 4.65774 4.54746Z",
    stroke: theme.colors.blue[20],
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M19.3908 4.63159C19.7067 4.94754 19.8866 5.43625 19.8765 6.12502C19.8663 6.81594 19.6635 7.66443 19.2637 8.62144C18.4652 10.5331 16.9211 12.782 14.8082 14.8949C12.6952 17.0079 10.4463 18.5519 8.53469 19.3505C7.57768 19.7502 6.72919 19.9531 6.03827 19.9632C5.3495 19.9734 4.86079 19.7935 4.54484 19.4775C4.22889 19.1616 4.04901 18.6729 4.05914 17.9841C4.06929 17.2932 4.27214 16.4447 4.67191 15.4877C5.47044 13.576 7.01448 11.3272 9.12745 9.21421C11.2404 7.10124 13.4893 5.5572 15.4009 4.75866C16.3579 4.35889 17.2064 4.15604 17.8974 4.14589C18.5861 4.13577 19.0748 4.31564 19.3908 4.63159Z",
    stroke: theme.colors.blue[20],
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "12",
    cy: "12",
    r: "2",
    fill: theme.colors.blue[60]
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "12",
    cy: "7",
    r: "1",
    fill: theme.colors.blue[60]
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "12",
    cy: "17",
    r: "1",
    fill: theme.colors.blue[60]
  }));
}
ProfessionalPlanIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "ProfessionalPlanIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/ProfessionalPlanIcon.tsx"] = {
    name: "ProfessionalPlanIcon",
    docgenInfo: ProfessionalPlanIcon.__docgenInfo,
    path: "src/components/icons/ProfessionalPlanIcon.tsx"
  };
}

function BusinessPlanIcon(props) {
  var theme = useTheme();
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    iconName: "BusinessPlanIcon",
    stroke: "none"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M4.65776 4.54746C4.97371 4.23151 5.46242 4.05164 6.15119 4.06176C6.84211 4.07191 7.6906 4.27476 8.64761 4.67453C10.5592 5.47307 12.8081 7.01711 14.9211 9.13008C17.0341 11.243 18.5781 13.4919 19.3766 15.4036C19.7764 16.3606 19.9793 17.2091 19.9894 17.9C19.9995 18.5887 19.8197 19.0775 19.5037 19.3934C19.1878 19.7094 18.699 19.8892 18.0103 19.8791C17.3194 19.869 16.4709 19.6661 15.5139 19.2663C13.6022 18.4678 11.3533 16.9238 9.24037 14.8108C7.1274 12.6978 5.58336 10.449 4.78483 8.53732C4.38506 7.5803 4.18221 6.73181 4.17206 6.0409C4.16193 5.35212 4.34181 4.86341 4.65776 4.54746Z",
    stroke: theme.colors.purple[30],
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M19.3908 4.63159C19.7067 4.94754 19.8866 5.43625 19.8765 6.12502C19.8663 6.81594 19.6635 7.66443 19.2637 8.62144C18.4652 10.5331 16.9212 12.782 14.8082 14.8949C12.6952 17.0079 10.4463 18.5519 8.53471 19.3505C7.57769 19.7502 6.7292 19.9531 6.03829 19.9632C5.34951 19.9734 4.8608 19.7935 4.54485 19.4775C4.2289 19.1616 4.04903 18.6729 4.05915 17.9841C4.06931 17.2932 4.27215 16.4447 4.67192 15.4877C5.47046 13.576 7.0145 11.3272 9.12747 9.21421C11.2404 7.10124 13.4893 5.5572 15.4009 4.75866C16.358 4.35889 17.2065 4.15604 17.8974 4.14589C18.5861 4.13577 19.0748 4.31564 19.3908 4.63159Z",
    stroke: theme.colors.purple[30],
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "12",
    cy: "12",
    r: "2",
    fill: theme.colors.purple[60]
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "12",
    cy: "7",
    r: "1",
    fill: theme.colors.purple[60]
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "7",
    cy: "12",
    r: "1",
    transform: "rotate(-90 7 12)",
    fill: theme.colors.purple[60]
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "12",
    cy: "17",
    r: "1",
    fill: theme.colors.purple[60]
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "17",
    cy: "12",
    r: "1",
    transform: "rotate(-90 17 12)",
    fill: theme.colors.purple[60]
  }), /*#__PURE__*/React__default.createElement("circle", {
    r: "10.5",
    transform: "matrix(1 0 0 -1 12 12)",
    stroke: theme.colors.purple[30]
  }));
}
BusinessPlanIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BusinessPlanIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/BusinessPlanIcon.tsx"] = {
    name: "BusinessPlanIcon",
    docgenInfo: BusinessPlanIcon.__docgenInfo,
    path: "src/components/icons/BusinessPlanIcon.tsx"
  };
}

function EnterprisePlanIcon(props) {
  var theme = useTheme();
  return /*#__PURE__*/React__default.createElement(IconSkeleton, _extends({}, props, {
    iconName: "EnterprisePlanIcon",
    stroke: "none"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M21.1576 6.82012C21.381 7.20708 21.4283 7.72569 21.2402 8.38837C21.0516 9.05312 20.636 9.8202 20.0022 10.6411C18.7361 12.281 16.6626 14.0536 14.0748 15.5477C11.4869 17.0418 8.91507 17.9511 6.86189 18.2277C5.83402 18.3662 4.96194 18.3425 4.29194 18.1735C3.62401 18.005 3.19851 17.7047 2.9751 17.3178C2.75169 16.9308 2.70443 16.4122 2.89248 15.7495C3.08111 15.0848 3.49665 14.3177 4.13049 13.4968C5.39658 11.857 7.47006 10.0843 10.0579 8.59024C12.6458 7.09615 15.2176 6.18677 17.2708 5.91021C18.2987 5.77176 19.1708 5.79542 19.8408 5.96444C20.5087 6.13293 20.9342 6.43316 21.1576 6.82012Z",
    stroke: theme.colors.purple[40],
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M21.0735 17.2049C20.8501 17.5918 20.4246 17.8921 19.7566 18.0606C19.0866 18.2296 18.2146 18.2532 17.1867 18.1148C15.1335 17.8382 12.5616 16.9289 9.97379 15.4348C7.38594 13.9407 5.31246 12.1681 4.04636 10.5282C3.41253 9.70729 2.99698 8.94021 2.80835 8.27547C2.62031 7.61279 2.66757 7.09417 2.89098 6.70722C3.11439 6.32026 3.53989 6.02002 4.20781 5.85153C4.87781 5.68252 5.74989 5.65885 6.77776 5.7973C8.83094 6.07386 11.4028 6.98324 13.9907 8.47734C16.5785 9.97143 18.652 11.744 19.9181 13.3839C20.5519 14.2048 20.9675 14.9719 21.1561 15.6366C21.3441 16.2993 21.2969 16.8179 21.0735 17.2049Z",
    stroke: theme.colors.purple[40],
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M12.0663 1.82129C12.4247 1.82129 12.8368 1.99499 13.2864 2.45802C13.7383 2.92336 14.1798 3.63584 14.5665 4.57737C15.3384 6.45685 15.8332 9.10513 15.8332 12.069C15.8332 15.0328 15.3384 17.6811 14.5665 19.5605C14.1798 20.5021 13.7383 21.2146 13.2864 21.6799C12.8368 22.1429 12.4247 22.3166 12.0663 22.3166C11.7079 22.3166 11.2959 22.1429 10.8462 21.6799C10.3944 21.2146 9.95289 20.5021 9.5662 19.5605C8.79427 17.6811 8.29947 15.0328 8.29947 12.069C8.29947 9.10513 8.79427 6.45685 9.56619 4.57737C9.95289 3.63584 10.3944 2.92337 10.8462 2.45802C11.2959 1.99499 11.7079 1.82129 12.0663 1.82129Z",
    stroke: theme.colors.purple[40],
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "12",
    cy: "12",
    r: "2",
    fill: theme.colors.purple[30]
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "12.0001",
    cy: "7.5",
    r: "1",
    fill: theme.colors.green[50]
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "5",
    cy: "12",
    r: "1",
    transform: "rotate(-90 5 12)",
    fill: theme.colors.yellow[50]
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "12.0001",
    cy: "16.5",
    r: "1",
    fill: theme.colors.orange[50]
  }), /*#__PURE__*/React__default.createElement("circle", {
    cx: "19",
    cy: "12",
    r: "1",
    transform: "rotate(-90 19 12)",
    fill: theme.colors.teal[50]
  }), /*#__PURE__*/React__default.createElement("circle", {
    r: "10",
    transform: "matrix(1 0 0 -1 12 12)",
    stroke: theme.colors.purple[40]
  }));
}
EnterprisePlanIcon.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "EnterprisePlanIcon"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/icons/EnterprisePlanIcon.tsx"] = {
    name: "EnterprisePlanIcon",
    docgenInfo: EnterprisePlanIcon.__docgenInfo,
    path: "src/components/icons/EnterprisePlanIcon.tsx"
  };
}

var iconByTone = {
  BRAND: null,
  SUCCESS: SuccessIcon,
  DANGER: md.MdError,
  WARNING: md.MdWarning,
  NEUTRAL: null
};
var variants$1 = {
  PRIMARY: function PRIMARY(tone) {
    return function (theme) {
      return [{
        background: theme.colors.white,
        borderLeft: "".concat(theme.space[2], " solid ").concat(theme.tones[tone].medium),
        paddingTop: theme.space[5],
        paddingBottom: theme.space[5],
        paddingLeft: theme.space[6],
        paddingRight: theme.space[7]
      }];
    };
  },
  SECONDARY: function SECONDARY(tone) {
    return function (theme) {
      return _defineProperty({
        background: theme.tones[tone].superLight,
        padding: "".concat(theme.space[5], " ").concat(theme.space[7])
      }, theme.mediaQueries.desktop, {
        padding: "".concat(theme.space[7], " ").concat(theme.space[9])
      });
    };
  },
  SOLID: function SOLID(tone) {
    return function (theme) {
      return [_defineProperty({
        background: theme.tones[tone].dark,
        borderRadius: theme.radii[2],
        color: theme.tones[tone].textInverted ? theme.tones[tone].textInverted : theme.colors.white,
        padding: "".concat(theme.space[5], " ").concat(theme.space[7])
      }, theme.mediaQueries.desktop, {
        padding: "".concat(theme.space[7], " ").concat(theme.space[9])
      })];
    };
  }
};
function getNotificationVariantStyles(variant, tone) {
  return variants$1[variant](tone);
}
getNotificationVariantStyles.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "getNotificationVariantStyles"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Notification/Notification.helpers.ts"] = {
    name: "getNotificationVariantStyles",
    docgenInfo: getNotificationVariantStyles.__docgenInfo,
    path: "src/components/Notification/Notification.helpers.ts"
  };
}

var NotificationContext = React__default.createContext({
  onDismiss: function onDismiss() {
    return undefined;
  },
  variant: undefined,
  tone: undefined
});

var baseCss$7 = function baseCss(theme) {
  return {
    color: theme.colors.grey[90],
    display: "flex",
    alignItems: "flex-start",
    justifyContent: "space-between",
    flexWrap: "nowrap",
    width: "100%",
    fontSize: theme.fontSizes[1],
    lineHeight: theme.lineHeights["default"]
  };
};

function Notification(_ref) {
  var children = _ref.children,
      _ref$tone = _ref.tone,
      tone = _ref$tone === void 0 ? "BRAND" : _ref$tone,
      _ref$variant = _ref.variant,
      variant = _ref$variant === void 0 ? "PRIMARY" : _ref$variant,
      content = _ref.content,
      _ref$contentAs = _ref.contentAs,
      contentAs = _ref$contentAs === void 0 ? "span" : _ref$contentAs,
      linkUrl = _ref.linkUrl,
      linkText = _ref.linkText,
      onLinkClick = _ref.onLinkClick,
      _ref$isOpened = _ref.isOpened,
      isOpened = _ref$isOpened === void 0 ? true : _ref$isOpened,
      onDismissButtonClick = _ref.onDismissButtonClick,
      _ref$showDismissButto = _ref.showDismissButton,
      showDismissButton = _ref$showDismissButto === void 0 ? !!onDismissButtonClick : _ref$showDismissButto,
      dismissButtonLabel = _ref.dismissButtonLabel,
      CustomIcon = _ref.Icon,
      rest = _objectWithoutProperties(_ref, ["children", "tone", "variant", "content", "contentAs", "linkUrl", "linkText", "onLinkClick", "isOpened", "onDismissButtonClick", "showDismissButton", "dismissButtonLabel", "Icon"]);

  if (!isOpened) {
    return null;
  }

  var PresetIcon = content && iconByTone[tone];
  var Icon = CustomIcon || PresetIcon;
  return core.jsx(NotificationContext.Provider, {
    value: {
      onDismiss: onDismissButtonClick,
      variant: variant,
      tone: tone
    }
  }, core.jsx("div", _extends({
    css: function css(theme) {
      return [variant === "PRIMARY" && theme.cardStyles.frame, baseCss$7(theme), getNotificationVariantStyles(variant, tone)(theme)];
    }
  }, rest), content && core.jsx(NotificationContent, {
    as: contentAs,
    css: function css(theme) {
      return [linkUrl && linkText && {
        marginRight: theme.space[5]
      }];
    }
  }, Icon && core.jsx(Icon, {
    css: function css(theme) {
      return [{
        marginRight: theme.space[4],
        fontSize: theme.fontSizes[4],
        color: theme.tones[tone].medium,
        flexShrink: 0,
        width: "auto",
        height: "1em"
      }, variant === "SOLID" && {
        color: theme.tones[tone].mediumInverted ? theme.tones[tone].mediumInverted : theme.colors.whiteFade[90]
      }];
    }
  }), content), linkUrl && linkText && core.jsx(Link, {
    to: linkUrl,
    onClick: onLinkClick,
    css: function css(theme) {
      return {
        // to push <Link> to the right also when there's a
        // <NotificationDismissButton>
        marginLeft: "auto",
        color: variant === "SOLID" ? theme.colors.white : null,
        ":hover": {
          color: variant === "SOLID" ? theme.colors.whiteFade[80] : null
        }
      };
    }
  }, linkText && core.jsx(React.Fragment, null, linkText, " ", core.jsx(md.MdArrowForward, null))), showDismissButton && core.jsx(NotificationDismissButton, {
    label: dismissButtonLabel
  }), children));
}
Notification.propTypes = {
  children: _pt__default.node,
  content: _pt__default.node,
  linkUrl: _pt__default.string,
  linkText: _pt__default.node,
  onLinkClick: _pt__default.func,
  isOpened: _pt__default.bool,
  onDismissButtonClick: _pt__default.func,
  showDismissButton: _pt__default.bool,
  dismissButtonLabel: _pt__default.string,
  Icon: _pt__default.elementType
};

function NotificationContent(_ref2) {
  var _ref2$as = _ref2.as,
      Component = _ref2$as === void 0 ? "span" : _ref2$as,
      rest = _objectWithoutProperties(_ref2, ["as"]);

  return core.jsx(Component, _extends({
    css: {
      display: "flex",
      alignItems: "flex-start"
    }
  }, rest));
}

NotificationContent.propTypes = {
  as: _pt__default.oneOf(["span", "div"])
};

function NotificationDismissButton(_ref3) {
  var _ref3$label = _ref3.label,
      label = _ref3$label === void 0 ? "Close" : _ref3$label;

  var _useNotificationConte = useNotificationContext(),
      onDismiss = _useNotificationConte.onDismiss,
      variant = _useNotificationConte.variant,
      tone = _useNotificationConte.tone;

  return core.jsx(Button, {
    css: function css(theme) {
      return [{
        padding: "0",
        minHeight: "auto",
        color: theme.colors.grey[40],
        width: theme.space[5],
        marginLeft: theme.space[5],
        fontSize: theme.fontSizes[4]
      }, variant === "SOLID" && {
        color: theme.colors.whiteFade[60],
        ":hover": {
          background: "transparent",
          color: theme.colors.white
        }
      }, variant === "SOLID" && tone === "WARNING" && {
        color: theme.colors.blackFade[60],
        ":hover": {
          color: theme.colors.black
        }
      }];
    },
    type: "button",
    onClick: onDismiss,
    variant: "GHOST",
    "aria-label": label
  }, core.jsx(md.MdClose, null));
}

function useNotificationContext() {
  var context = React__default.useContext(NotificationContext);

  if (!context) {
    throw new Error("Notification compound components cannot be rendered outside the main component");
  }

  return context;
}

Notification.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "Notification",
  "props": {
    "tone": {
      "defaultValue": {
        "value": "`BRAND`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "NotificationTone"
      },
      "description": ""
    },
    "variant": {
      "defaultValue": {
        "value": "`PRIMARY`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "NotificationVariant"
      },
      "description": ""
    },
    "contentAs": {
      "defaultValue": {
        "value": "`span`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "intersection[\"as\"]",
        "raw": "NotificationContentProps[\"as\"]"
      },
      "description": ""
    },
    "isOpened": {
      "defaultValue": {
        "value": "true",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "boolean"
      },
      "description": ""
    },
    "showDismissButton": {
      "defaultValue": {
        "value": "!!onDismissButtonClick",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "boolean"
      },
      "description": ""
    },
    "children": {
      "required": false,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    },
    "content": {
      "required": false,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    },
    "linkUrl": {
      "required": false,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "linkText": {
      "required": false,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    },
    "onLinkClick": {
      "required": false,
      "tsType": {
        "name": "ReactMouseEventHandler",
        "raw": "React.MouseEventHandler<HTMLAnchorElement>",
        "elements": [{
          "name": "HTMLAnchorElement"
        }]
      },
      "description": ""
    },
    "onDismissButtonClick": {
      "required": false,
      "tsType": {
        "name": "signature",
        "type": "function",
        "raw": "() => void",
        "signature": {
          "arguments": [],
          "return": {
            "name": "void"
          }
        }
      },
      "description": ""
    },
    "dismissButtonLabel": {
      "required": false,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "Icon": {
      "required": false,
      "tsType": {
        "name": "ReactComponentType",
        "raw": "React.ComponentType<any>",
        "elements": [{
          "name": "any"
        }]
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Notification/Notification.tsx"] = {
    name: "Notification",
    docgenInfo: Notification.__docgenInfo,
    path: "src/components/Notification/Notification.tsx"
  };
}

function hexToRGB(hex) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}
function hexToRGBA(hexColor, opacity) {
  var isCssVar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var hexStringToParse = hexColor;

  if (isCssVar) {
    // If the passed string is a CSS var coming from ThemeUI (e.g. "var(--theme-ui-colors-white, #ffffff)"),
    // we can extract the HEX value and parse it
    var hexMatch = hexColor.match(/#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})/i);

    if (hexMatch && hexMatch[0]) {
      hexStringToParse = hexMatch[0];
    }
  }

  var rgbColor = hexToRGB(hexStringToParse);

  if (!rgbColor) {
    return hexColor;
  }

  return "rgba(".concat(rgbColor.r, ", ").concat(rgbColor.g, ", ").concat(rgbColor.b, ", ").concat(opacity, ")");
}

var liReset = {
  margin: 0,
  padding: 0
};
var navigationBaseCss = function navigationBaseCss(_theme) {
  return {
    display: "flex"
  };
};
var hamburgerIconCss = function hamburgerIconCss(theme) {
  return {
    "&.active": {
      background: "0 0",
      "&:after": {
        background: theme.colors.white,
        top: 0,
        width: 24,
        transform: "rotate(-45deg)"
      },
      "&:before": {
        background: theme.colors.white,
        top: 0,
        width: 24,
        transform: "rotate(45deg)"
      },
      "&:hover": {
        transform: "scale(1.2)"
      }
    }
  };
};
var navCss = function navCss(mobileNavMediaQuery, isMobileNavOpen) {
  return function (theme) {
    return [_defineProperty({
      display: "flex",
      justifyContent: "space-between",
      width: "100%"
    }, mobileNavMediaQuery, {
      display: isMobileNavOpen ? "block" : "none",
      position: "fixed",
      overflowY: "auto",
      WebkitOverflowScrolling: "touch",
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      margin: 0,
      background: hexToRGBA(theme.colors.purple[90], 0.975, true),
      padding: "5rem 3.5rem 5rem",
      alignItems: "center",
      textAlign: "right"
    })];
  };
};
var listCss = function listCss(mobileNavMediaQuery) {
  return function (theme) {
    return [_defineProperty({
      display: "flex",
      listStyle: "none",
      width: "100%",
      alignItems: "center"
    }, mobileNavMediaQuery, {
      flexDirection: "column",
      alignItems: "flex-end",
      listStyle: "none",
      margin: "0 auto",
      padding: "0 ".concat(theme.space[5]),
      position: "relative",
      zIndex: 1,
      width: "100%",
      maxWidth: "90rem",
      paddingLeft: theme.space[8],
      paddingRight: theme.space[8]
    })];
  };
};

var dropdownOpenCss = function dropdownOpenCss(theme) {
  return {
    fontSize: theme.fontSizes[1],
    fontFamily: theme.fonts.system,
    boxShadow: theme.shadows.dialog,
    background: theme.colors.white,
    borderRadius: theme.radii[1],
    ":after": {
      position: "absolute",
      top: -6,
      left: "50%",
      width: 12,
      height: 12,
      content: "\" \"",
      borderRadius: "2px 0 0 0",
      background: theme.colors.white,
      boxShadow: "-3px -3px 10px ".concat(hexToRGBA(theme.colors.lilac, 0.1, true)),
      willChange: "transform",
      transitionProperty: "transform",
      transitionDuration: theme.transitions.speed["default"]
    }
  };
};

var dropdownListCss = function dropdownListCss(theme, mobileNavMediaQuery) {
  return _defineProperty({
    display: "grid",
    gridTemplateColumns: "max-content"
  }, mobileNavMediaQuery, {
    display: "block",
    gridTemplateColumns: "none",
    padding: "0 0 ".concat(theme.space[4])
  });
};

var dropdownMobileCss = function dropdownMobileCss(theme) {
  return {
    width: "100%",
    color: theme.colors.white,
    position: "relative",
    background: 0,
    padding: 0,
    marginBottom: theme.space[4],
    ":after": {
      content: "none"
    }
  };
};

var itemCss = function itemCss(mobileNavMediaQuery) {
  return function (theme) {
    return [liReset, _defineProperty({
      marginBottom: 0,
      padding: "0 ".concat(theme.space[4]),
      "&:hover > ul": dropdownOpenCss(theme)
    }, mobileNavMediaQuery, {
      display: "block",
      color: theme.colors.white,
      "&:hover > ul": dropdownMobileCss(theme)
    })];
  };
};
var itemLinkCss = function itemLinkCss(mobileNavMediaQuery, isInverted) {
  return function (theme) {
    return [{
      display: "block",
      textDecoration: "none",
      color: "inherit",
      fontSize: theme.fontSizes[1],
      fontFamily: theme.fonts.system,
      fontWeight: theme.fontWeights.body,
      transition: "opacity ".concat(theme.transitions.speed["default"]),
      WebkitFontSmoothing: "antialiased",
      lineHeight: "calc(3.33rem)",
      position: "relative",
      "& span": {
        position: "relative"
      },
      "&.nav-item-active": {
        color: isInverted ? theme.colors.accent : theme.colors.gatsby
      },
      "&.nav-item-active span:after": {
        width: "100%"
      },
      "& span:after": {
        position: "absolute",
        content: "\" \"",
        display: "block",
        width: 0,
        height: 1,
        bottom: -4,
        opacity: 0.2,
        background: isInverted ? "linear-gradient(45deg, ".concat(theme.colors.orange[40], ", ").concat(theme.colors.accent, ")") : "linear-gradient(45deg, ".concat(theme.colors.lilac, ", ").concat(theme.colors.gatsby, ")"),
        transition: "all ".concat(theme.transitions.speed["default"])
      },
      "&:hover": {
        opacity: 0.8
      }
    }, _defineProperty({}, mobileNavMediaQuery, {
      color: theme.colors.white,
      fontFamily: theme.fonts.heading,
      fontWeight: theme.fontWeights.body,
      transition: "opacity ".concat(theme.transitions.speed["default"]),
      WebkitFontSmoothing: "antialiased",
      fontSize: theme.fontSizes[6],
      "&:focus, &:hover": {
        color: theme.colors.accent,
        background: "none",
        opacity: 1
      }
    })];
  };
};
var dropdownCss = function dropdownCss(mobileNavMediaQuery, offset) {
  return function (theme) {
    return [dropdownOpenCss(theme), {
      // offset is set when dropdown in default positioning hits left or right edge of he viewport
      // if so the dropdown is shifted to the position when it fits into the viewport
      transform: "translate(calc(-50% + ".concat(offset, "), -").concat(theme.space[2], ")"),
      ":after": {
        // to make the spout centered to parent menu item we shift it into the opposite direction
        transform: "translateX(calc(-50% + (".concat(offset, " * -1))) rotate(45deg)")
      }
    }, _defineProperty({}, mobileNavMediaQuery, [{
      display: "inline-block",
      background: 0
    }, dropdownMobileCss(theme)]), {}];
  };
};
var dropdownToggleCss = function dropdownToggleCss(mobileNavMediaQuery) {
  return function (theme) {
    return _defineProperty({
      marginLeft: theme.space[1],
      border: "none"
    }, mobileNavMediaQuery, {
      display: "none"
    });
  };
};
var dropdownItemCss = function dropdownItemCss(mobileNavMediaQuery) {
  return function (theme) {
    return {
      "&:first-of-type > a": {
        margin: 0
      },
      a: _defineProperty({
        color: theme.colors.grey[50],
        textDecoration: "none",
        padding: "".concat(theme.space[4], " ").concat(theme.space[7]),
        display: "block",
        transition: "all ".concat(theme.transitions.speed["default"]),
        "&:hover": {
          color: theme.colors.grey[90],
          background: hexToRGBA(theme.colors.accent, 0.1, true)
        },
        "&:focus-within": {
          color: theme.colors.grey[90],
          background: hexToRGBA(theme.colors.accent, 0.1, true)
        }
      }, mobileNavMediaQuery, {
        color: theme.colors.white,
        textDecoration: "none",
        padding: 0,
        margin: "".concat(theme.space[3], " 0 0 0"),
        fontSize: theme.fontSizes[1],
        "&:hover, &:focus-within": {
          opacity: 1,
          color: theme.colors.accent,
          background: "none"
        }
      })
    };
  };
};
var buttonItemCss = function buttonItemCss(mobileNavMediaQuery) {
  return function (theme) {
    return [liReset, _defineProperty({
      marginLeft: theme.space[3]
    }, mobileNavMediaQuery, {
      marginTop: theme.space[3]
    })];
  };
};

function Navigation(_ref) {
  var items = _ref.items,
      _ref$isInverted = _ref.isInverted,
      isInverted = _ref$isInverted === void 0 ? false : _ref$isInverted,
      _ref$mobileNavMediaQu = _ref.mobileNavMediaQuery,
      mobileNavMediaQuery = _ref$mobileNavMediaQu === void 0 ? "@media (max-width: 1065px)" : _ref$mobileNavMediaQu,
      delegated = _objectWithoutProperties(_ref, ["items", "isInverted", "mobileNavMediaQuery"]);

  return core.jsx(BaseNavigation, _extends({
    items: items,
    isInverted: isInverted,
    mobileNavMediaQuery: mobileNavMediaQuery // override base components
    ,
    Hamburger: Navigation.Hamburger,
    HamburgerIcon: Navigation.HamburgerIcon,
    Nav: Navigation.Nav,
    List: Navigation.List,
    Item: Navigation.Item,
    ItemLink: Navigation.ItemLink,
    Dropdown: Navigation.Dropdown,
    DropdownItem: Navigation.DropdownItem,
    DropdownToggle: Navigation.DropdownToggle,
    css: navigationBaseCss
  }, delegated));
}

function useNavigationContext() {
  return BaseNavigation.useNavigationContext();
}

Navigation.useNavigationContext = useNavigationContext;
var NavigationHamburger = React__default.forwardRef(function NavigationHamburger(delegated, ref) {
  return core.jsx(BaseNavigation.Hamburger, _extends({}, delegated, {
    ref: ref
  }));
});
Navigation.Hamburger = NavigationHamburger;

function NavigationHamburgerIcon(delegated) {
  var _Navigation$useNaviga = Navigation.useNavigationContext(),
      isMobileNavOpen = _Navigation$useNaviga.isMobileNavOpen;

  return core.jsx(BaseNavigation.HamburgerIcon, _extends({
    css: hamburgerIconCss,
    className: isMobileNavOpen ? "active" : ""
  }, delegated));
}

Navigation.HamburgerIcon = NavigationHamburgerIcon;

function NavigationNav(delegated) {
  var _Navigation$useNaviga2 = Navigation.useNavigationContext(),
      mobileNavMediaQuery = _Navigation$useNaviga2.mobileNavMediaQuery,
      isMobileNavOpen = _Navigation$useNaviga2.isMobileNavOpen;

  return core.jsx(BaseNavigation.Nav, _extends({
    css: navCss(mobileNavMediaQuery, isMobileNavOpen)
  }, delegated));
}

Navigation.Nav = NavigationNav;

function NavigationList(delegated) {
  var _Navigation$useNaviga3 = Navigation.useNavigationContext(),
      mobileNavMediaQuery = _Navigation$useNaviga3.mobileNavMediaQuery;

  return core.jsx(BaseNavigation.List, _extends({
    css: listCss(mobileNavMediaQuery)
  }, delegated));
}

Navigation.List = NavigationList;

function NavigationSpacer(delegated) {
  return core.jsx("li", _extends({
    css: {
      flex: 1
    }
  }, delegated, {
    role: "separator"
  }));
}

Navigation.Spacer = NavigationSpacer;

function NavigationItem(delegated) {
  var _Navigation$useNaviga4 = Navigation.useNavigationContext(),
      mobileNavMediaQuery = _Navigation$useNaviga4.mobileNavMediaQuery;

  return core.jsx(BaseNavigation.Item, _extends({
    css: itemCss(mobileNavMediaQuery)
  }, delegated));
}

Navigation.Item = NavigationItem;

function NavigationItemLink(delegated) {
  var _Navigation$useNaviga5 = Navigation.useNavigationContext(),
      isInverted = _Navigation$useNaviga5.isInverted,
      mobileNavMediaQuery = _Navigation$useNaviga5.mobileNavMediaQuery;

  var commonCss = itemLinkCss(mobileNavMediaQuery, isInverted);

  if (isExternalLinkItem(delegated)) {
    return core.jsx(BaseNavigation.ItemAnchor, _extends({
      css: commonCss
    }, delegated));
  }

  return core.jsx(BaseNavigation.ItemLink, _extends({
    css: commonCss
  }, delegated));
}

Navigation.ItemLink = NavigationItemLink;

function isExternalLinkItem(props) {
  return isExternalLink(props.item.linkTo);
}

function NavigationDropdown(delegated) {
  var _Navigation$useNaviga6 = Navigation.useNavigationContext(),
      mobileNavMediaQuery = _Navigation$useNaviga6.mobileNavMediaQuery,
      dropdownOffsets = _Navigation$useNaviga6.dropdownOffsets;

  var itemOffset = dropdownOffsets[delegated.item.name];
  var offset = itemOffset ? "".concat(itemOffset, "px") : "0px";
  return core.jsx(core.ClassNames, null, function (_ref2) {
    var css = _ref2.css,
        theme = _ref2.theme;
    return core.jsx(BaseNavigation.Dropdown, _extends({
      css: dropdownCss(mobileNavMediaQuery, offset),
      dropdownListClassName: css(dropdownListCss(theme, mobileNavMediaQuery))
    }, delegated));
  });
}

Navigation.Dropdown = NavigationDropdown;
var NavigationDropdownToggle = React__default.forwardRef(function NavigationDropdownToggle(delegated, ref) {
  var _Navigation$useNaviga7 = Navigation.useNavigationContext(),
      mobileNavMediaQuery = _Navigation$useNaviga7.mobileNavMediaQuery;

  return core.jsx(BaseNavigation.DropdownToggle, _extends({
    css: dropdownToggleCss(mobileNavMediaQuery)
  }, delegated, {
    ref: ref
  }));
});
Navigation.DropdownToggle = NavigationDropdownToggle;

function NavigationDropdownItem(delegated) {
  var _Navigation$useNaviga8 = Navigation.useNavigationContext(),
      mobileNavMediaQuery = _Navigation$useNaviga8.mobileNavMediaQuery;

  return core.jsx(BaseNavigation.DropdownItem, _extends({
    css: dropdownItemCss(mobileNavMediaQuery)
  }, delegated));
}

Navigation.DropdownItem = NavigationDropdownItem;

function NavigationButton(_ref3) {
  var linkTo = _ref3.linkTo,
      delegated = _objectWithoutProperties(_ref3, ["linkTo"]);

  var _Navigation$useNaviga9 = Navigation.useNavigationContext(),
      mobileNavMediaQuery = _Navigation$useNaviga9.mobileNavMediaQuery;

  var commonCss = buttonItemCss(mobileNavMediaQuery);

  if (isExternalButtonLink(linkTo)) {
    return core.jsx("li", {
      css: commonCss
    }, core.jsx(BaseNavigation.AnchorButton, _extends({
      href: linkTo
    }, delegated)));
  }

  return core.jsx("li", {
    css: commonCss
  }, core.jsx(BaseNavigation.LinkButton, _extends({
    linkTo: linkTo
  }, delegated)));
}

Navigation.Button = NavigationButton;

function isExternalButtonLink(linkTo, _props) {
  return !linkTo || isExternalLink(linkTo);
}

var isExternalLink = function isExternalLink(linkTo) {
  return Boolean(linkTo.match(/(^http|^mailto)/i));
};

Navigation.__docgenInfo = {
  "description": "",
  "methods": [{
    "name": "useNavigationContext",
    "docblock": null,
    "modifiers": ["static"],
    "params": [],
    "returns": {
      "type": {
        "name": "BaseNavigationContextValue"
      }
    }
  }, {
    "name": "HamburgerIcon",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "delegated",
      "type": {
        "name": "BaseNavigationHamburgerIconProps",
        "alias": "NavigationHamburgerIconProps"
      }
    }],
    "returns": null
  }, {
    "name": "Nav",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "delegated",
      "type": {
        "name": "BaseNavigationNavProps",
        "alias": "NavigationNavProps"
      }
    }],
    "returns": null
  }, {
    "name": "List",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "delegated",
      "type": {
        "name": "BaseNavigationListProps",
        "alias": "NavigationListProps"
      }
    }],
    "returns": null
  }, {
    "name": "Spacer",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "delegated",
      "type": {
        "name": "Omit",
        "elements": [{
          "name": "JSX.IntrinsicElements[\"li\"]",
          "raw": "JSX.IntrinsicElements[\"li\"]"
        }, {
          "name": "union",
          "raw": "\"ref\" | \"role\"",
          "elements": [{
            "name": "literal",
            "value": "\"ref\""
          }, {
            "name": "literal",
            "value": "\"role\""
          }]
        }],
        "raw": "Omit<\n  JSX.IntrinsicElements[\"li\"],\n  \"ref\" | \"role\"\n>",
        "alias": "NavigationSpacerProps"
      }
    }],
    "returns": null
  }, {
    "name": "Item",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "delegated",
      "type": {
        "name": "BaseNavigationListItemProps",
        "alias": "NavigationItemProps"
      }
    }],
    "returns": null
  }, {
    "name": "ItemLink",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "delegated",
      "type": {
        "name": "union",
        "raw": "BaseNavigationItemAnchorProps\n| BaseNavigationItemLinkProps",
        "elements": [{
          "name": "BaseNavigationItemAnchorProps"
        }, {
          "name": "BaseNavigationItemLinkProps"
        }],
        "alias": "NavigationItemLinkProps"
      }
    }],
    "returns": null
  }, {
    "name": "Dropdown",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "delegated",
      "type": {
        "name": "BaseNavigationDropdownProps",
        "alias": "NavigationDropdownProps"
      }
    }],
    "returns": null
  }, {
    "name": "DropdownItem",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "delegated",
      "type": {
        "name": "BaseNavigationDropdownItemProps",
        "alias": "NavigationDropdownItemProps"
      }
    }],
    "returns": null
  }, {
    "name": "Button",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "{ linkTo, ...delegated }: NavigationButtonProps",
      "type": {
        "name": "union",
        "raw": "BaseNavigationAnchorButtonProps\n| BaseNavigationLinkButtonProps",
        "elements": [{
          "name": "BaseNavigationAnchorButtonProps"
        }, {
          "name": "BaseNavigationLinkButtonProps"
        }],
        "alias": "NavigationButtonProps"
      }
    }],
    "returns": null
  }],
  "displayName": "Navigation",
  "props": {
    "isInverted": {
      "defaultValue": {
        "value": "false",
        "computed": false
      },
      "required": false
    },
    "mobileNavMediaQuery": {
      "defaultValue": {
        "value": "`@media (max-width: 1065px)`",
        "computed": false
      },
      "required": false
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Navigation/Navigation.tsx"] = {
    name: "Navigation",
    docgenInfo: Navigation.__docgenInfo,
    path: "src/components/Navigation/Navigation.tsx"
  };
}

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var __DEV__ = process.env.NODE_ENV !== 'production';

var warning = function() {};

if (__DEV__) {
  var printWarning = function printWarning(format, args) {
    var len = arguments.length;
    args = new Array(len > 1 ? len - 1 : 0);
    for (var key = 1; key < len; key++) {
      args[key - 1] = arguments[key];
    }
    var argIndex = 0;
    var message = 'Warning: ' +
      format.replace(/%s/g, function() {
        return args[argIndex++];
      });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
          '`warning(condition, format, ...args)` requires a warning ' +
          'message argument'
      );
    }
    if (!condition) {
      printWarning.apply(null, [format].concat(args));
    }
  };
}

var warning_1 = warning;

/* eslint-disable no-restricted-globals, eqeqeq  */
/**
 * React currently throws a warning when using useLayoutEffect on the server.
 * To get around it, we can conditionally useEffect on the server (no-op) and
 * useLayoutEffect in the browser. We occasionally need useLayoutEffect to
 * ensure we don't get a render flash for certain operations, but we may also
 * need affected components to render on the server. One example is when setting
 * a component's descendants to retrieve their index values.
 *
 * Important to note that using this hook as an escape hatch will break the
 * eslint dependency warnings unless you rename the import to `useLayoutEffect`.
 * Use sparingly only when the effect won't effect the rendered HTML to avoid
 * any server/client mismatch.
 *
 * If a useLayoutEffect is needed and the result would create a mismatch, it's
 * likely that the component in question shouldn't be rendered on the server at
 * all, so a better approach would be to lazily render those in a parent
 * component after client-side hydration.
 *
 * TODO: We are calling useLayoutEffect in a couple of places that will likely
 * cause some issues for SSR users, whether the warning shows or not. Audit and
 * fix these.
 *
 * https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85
 * https://github.com/reduxjs/react-redux/blob/master/src/utils/useIsomorphicLayoutEffect.js
 *
 * @param effect
 * @param deps
 */

var useIsomorphicLayoutEffect = /*#__PURE__*/canUseDOM() ? React__default.useLayoutEffect : React__default.useEffect;
var checkedPkgs = {};
/**
 * When in dev mode, checks that styles for a given @reach package are loaded.
 *
 * @param packageName Name of the package to check.
 * @example checkStyles("dialog") will check for styles for @reach/dialog
 */
// @ts-ignore

var checkStyles = noop;

if (process.env.NODE_ENV !== "production") {
  // In CJS files, process.env.NODE_ENV is stripped from our build, but we need
  // it to prevent style checks from clogging up user logs while testing.
  // This is a workaround until we can tweak the build a bit to accommodate.
  var _ref = typeof process !== "undefined" ? process : {
    env: {
      NODE_ENV: "development"
    }
  },
      env = _ref.env;

  checkStyles = function checkStyles(packageName) {
    // only check once per package
    if (checkedPkgs[packageName]) return;
    checkedPkgs[packageName] = true;

    if (env.NODE_ENV !== "test" && parseInt(window.getComputedStyle(document.body).getPropertyValue("--reach-" + packageName), 10) !== 1) {
      console.warn("@reach/" + packageName + " styles not found. If you are using a bundler like webpack or parcel include this in the entry file of your app before any of your own styles:\n\n    import \"@reach/" + packageName + "/styles.css\";\n\n  Otherwise you'll need to include them some other way:\n\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"node_modules/@reach/" + packageName + "/styles.css\" />\n\n  For more information visit https://ui.reach.tech/styling.\n  ");
    }
  };
}
/**
 * Passes or assigns an arbitrary value to a ref function or object.
 *
 * @param ref
 * @param value
 */

function assignRef(ref, value) {
  if (ref == null) return;

  if (isFunction$2(ref)) {
    ref(value);
  } else {
    try {
      ref.current = value;
    } catch (error) {
      throw new Error("Cannot assign value \"" + value + "\" to ref \"" + ref + "\"");
    }
  }
}
/**
 * Checks true|"true" vs false|"false"
 *
 * @param value
 */

function boolOrBoolString(value) {
  return value === "true" ? true : isBoolean(value) ? value : false;
}
function canUseDOM() {
  return typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
}
/**
 * Type-safe clone element
 *
 * @param element
 * @param props
 * @param children
 */

function cloneValidElement(element, props) {
  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }

  return React.isValidElement(element) ? React.cloneElement.apply(void 0, [element, props].concat(children)) : element;
}
function createNamedContext(name, defaultValue) {
  var Ctx = React.createContext(defaultValue);
  Ctx.displayName = name;
  return Ctx;
}
/**
 * This is a hack for sure. The thing is, getting a component to intelligently
 * infer props based on a component or JSX string passed into an `as` prop is
 * kind of a huge pain. Getting it to work and satisfy the constraints of
 * `forwardRef` seems dang near impossible. To avoid needing to do this awkward
 * type song-and-dance every time we want to forward a ref into a component
 * that accepts an `as` prop, we abstract all of that mess to this function for
 * the time time being.
 *
 * TODO: Eventually we should probably just try to get the type defs above
 * working across the board, but ain't nobody got time for that mess!
 *
 * @param Comp
 */

function forwardRefWithAs(comp) {
  return React__default.forwardRef(comp);
}
/**
 * Get the size of the working document minus the scrollbar offset.
 *
 * @param element
 */

function getDocumentDimensions(element) {
  if (!canUseDOM()) return {
    width: 0,
    height: 0
  };
  var doc = element ? getOwnerDocument(element) : document;
  var win = element ? getOwnerWindow(element) : window;
  return {
    width: doc.documentElement.clientWidth || win.innerWidth,
    height: doc.documentElement.clientHeight || win.innerHeight
  };
}
/**
 * Get a computed style value by property, backwards compatible with IE
 * @param element
 * @param styleProp
 */

function getElementComputedStyle(element, styleProp) {
  var y = null;
  var doc = getOwnerDocument(element);

  if (element.currentStyle) {
    y = element.currentStyle[styleProp];
  } else if (doc && doc.defaultView && isFunction$2(doc.defaultView.getComputedStyle)) {
    y = doc.defaultView.getComputedStyle(element, null).getPropertyValue(styleProp);
  }

  return y;
}
/**
 * Get an element's owner document. Useful when components are used in iframes
 * or other environments like dev tools.
 *
 * @param element
 */

function getOwnerDocument(element) {
  return element && element.ownerDocument ? element.ownerDocument : canUseDOM() ? document : null;
}
function getOwnerWindow(element) {
  var doc = element ? getOwnerDocument(element) : null;
  return doc ? doc.defaultView || window : null;
}
/**
 * Checks whether or not a value is a boolean.
 *
 * @param value
 */

function isBoolean(value) {
  return typeof value === "boolean";
}
/**
 * Checks whether or not a value is a function.
 *
 * @param value
 */

function isFunction$2(value) {
  return !!(value && {}.toString.call(value) == "[object Function]");
}
/**
 * Checks whether or not a value is a number.
 *
 * @param value
 */

function isNumber(value) {
  return typeof value === "number";
}
/**
 * Checks whether or not a value is a string.
 *
 * @param value
 */

function isString(value) {
  return typeof value === "string";
}
/**
 * Joins strings to format IDs for compound components.
 *
 * @param args
 */

function makeId() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return args.filter(function (val) {
    return val != null;
  }).join("--");
}
/**
 * No-op function.
 */

function noop() {}
/**
 * Check if a component is controlled or uncontrolled and return the correct
 * state value and setter accordingly. If the component state is controlled by
 * the app, the setter is a noop.
 *
 * @param controlledValue
 * @param defaultValue
 */

function useControlledState(controlledValue, defaultValue) {
  var controlledRef = React.useRef(controlledValue != null);

  var _useState = React.useState(defaultValue),
      valueState = _useState[0],
      setValue = _useState[1];

  var set = React.useCallback(function (n) {
    if (!controlledRef.current) {
      setValue(n);
    }
  }, []);
  return [controlledRef.current ? controlledValue : valueState, set];
}
/**
 * Logs a warning in dev mode when a component switches from controlled to
 * uncontrolled, or vice versa
 *
 * A single prop should typically be used to determine whether or not a
 * component is controlled or not.
 *
 * @param controlledValue
 * @param controlledPropName
 * @param componentName
 */

var useControlledSwitchWarning = noop;

if (process.env.NODE_ENV !== "production") {
  useControlledSwitchWarning = function useControlledSwitchWarning(controlledValue, controlledPropName, componentName) {
    var controlledRef = React.useRef(controlledValue != null);
    var nameCache = React.useRef({
      componentName: componentName,
      controlledPropName: controlledPropName
    });
    React.useEffect(function () {
      nameCache.current = {
        componentName: componentName,
        controlledPropName: controlledPropName
      };
    }, [componentName, controlledPropName]);
    React.useEffect(function () {
      var wasControlled = controlledRef.current;
      var _nameCache$current = nameCache.current,
          componentName = _nameCache$current.componentName,
          controlledPropName = _nameCache$current.controlledPropName;
      var isControlled = controlledValue != null;

      if (wasControlled !== isControlled) {
        console.error("A component is changing an " + (wasControlled ? "" : "un") + "controlled `" + controlledPropName + "` state of " + componentName + " to be " + (wasControlled ? "un" : "") + "controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled " + componentName + " element for the lifetime of the component.\nMore info: https://fb.me/react-controlled-components");
      }
    }, [controlledValue]);
  };
}

if (process.env.NODE_ENV !== "production") ;
/**
 * @param callback
 */

function useEventCallback(callback) {
  var ref = React.useRef(callback);
  useIsomorphicLayoutEffect(function () {
    ref.current = callback;
  });
  return React.useCallback(function (event) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }

    return ref.current.apply(ref, [event].concat(args));
  }, []);
}
/**
 * Passes or assigns a value to multiple refs (typically a DOM node). Useful for
 * dealing with components that need an explicit ref for DOM calculations but
 * also forwards refs assigned by an app.
 *
 * @param refs Refs to fork
 */

function useForkedRef() {
  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    refs[_key4] = arguments[_key4];
  }

  return React.useMemo(function () {
    if (refs.every(function (ref) {
      return ref == null;
    })) {
      return null;
    }

    return function (node) {
      refs.forEach(function (ref) {
        assignRef(ref, node);
      });
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, refs);
}
/**
 * Returns the previous value of a reference after a component update.
 *
 * @param value
 */

function usePrevious(value) {
  var ref = React.useRef(null);
  React.useEffect(function () {
    ref.current = value;
  }, [value]);
  return ref.current;
}
/**
 * Call an effect after a component update, skipping the initial mount.
 *
 * @param effect Effect to call
 * @param deps Effect dependency list
 */

function useUpdateEffect(effect, deps) {
  var mounted = React.useRef(false);
  React.useEffect(function () {
    if (mounted.current) {
      effect();
    } else {
      mounted.current = true;
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, deps);
}

if (process.env.NODE_ENV !== "production") ;
/**
 * Wraps a lib-defined event handler and a user-defined event handler, returning
 * a single handler that allows a user to prevent lib-defined handlers from
 * firing.
 *
 * @param theirHandler User-supplied event handler
 * @param ourHandler Library-supplied event handler
 */

function wrapEvent(theirHandler, ourHandler) {
  return function (event) {
    theirHandler && theirHandler(event);

    if (!event.defaultPrevented) {
      return ourHandler(event);
    }
  };
}

/**
 * Welcome to @reach/portal!
 *
 * Creates and appends a DOM node to the end of `document.body` and renders a
 * React tree into it. Useful for rendering a natural React element hierarchy
 * with a different DOM hierarchy to prevent parent styles from clipping or
 * hiding content (for popovers, dropdowns, and modals).
 *
 * @see Docs   https://reacttraining.com/reach-ui/portal
 * @see Source https://github.com/reach/reach-ui/tree/master/packages/portal
 * @see React  https://reactjs.org/docs/portals.html
 */
/**
 * Portal
 *
 * @see Docs https://reacttraining.com/reach-ui/portal#portal
 */

var Portal = function Portal(_ref) {
  var children = _ref.children,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? "reach-portal" : _ref$type;
  var mountNode = React.useRef(null);
  var portalNode = React.useRef(null);

  var _useState = React.useState(),
      forceUpdate = _useState[1];

  useIsomorphicLayoutEffect(function () {
    // This ref may be null when a hot-loader replaces components on the page
    if (!mountNode.current) return; // It's possible that the content of the portal has, itself, been portaled.
    // In that case, it's important to append to the correct document element.

    var ownerDocument = mountNode.current.ownerDocument;
    portalNode.current = ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.createElement(type);
    ownerDocument.body.appendChild(portalNode.current);
    forceUpdate({});
    return function () {
      if (portalNode.current && portalNode.current.ownerDocument) {
        portalNode.current.ownerDocument.body.removeChild(portalNode.current);
      }
    };
  }, [type]);
  return portalNode.current ? reactDom.createPortal(children, portalNode.current) : React__default.createElement("span", {
    ref: mountNode
  });
};

if (process.env.NODE_ENV !== "production") {
  Portal.displayName = "Portal";
}

function _objectWithoutPropertiesLoose$3(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _extends$2() {
  _extends$2 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$2.apply(this, arguments);
}

var FOCUS_GROUP = 'data-focus-lock';
var FOCUS_DISABLED = 'data-focus-lock-disabled';
var FOCUS_ALLOW = 'data-no-focus-lock';
var FOCUS_AUTO = 'data-autofocus-inside';

function assignRef$1(ref, value) {
    if (typeof ref === 'function') {
        ref(value);
    }
    else if (ref) {
        ref.current = value;
    }
    return ref;
}

function useCallbackRef(initialValue, callback) {
    var ref = React.useState(function () { return ({
        // value
        value: initialValue,
        // last callback
        callback: callback,
        // "memoized" public interface
        facade: {
            get current() {
                return ref.value;
            },
            set current(value) {
                var last = ref.value;
                if (last !== value) {
                    ref.value = value;
                    ref.callback(value, last);
                }
            }
        }
    }); })[0];
    // update callback
    ref.callback = callback;
    return ref.facade;
}

function useMergeRefs(refs, defaultValue) {
    return useCallbackRef(defaultValue, function (newValue) {
        return refs.forEach(function (ref) { return assignRef$1(ref, newValue); });
    });
}

var hiddenGuard = {
  width: '1px',
  height: '0px',
  padding: 0,
  overflow: 'hidden',
  position: 'fixed',
  top: '1px',
  left: '1px'
};

var InFocusGuard = function InFocusGuard(_ref) {
  var children = _ref.children;
  return React.createElement(React.Fragment, null, React.createElement("div", {
    key: "guard-first",
    "data-focus-guard": true,
    "data-focus-auto-guard": true,
    style: hiddenGuard
  }), children, children && React.createElement("div", {
    key: "guard-last",
    "data-focus-guard": true,
    "data-focus-auto-guard": true,
    style: hiddenGuard
  }));
};

InFocusGuard.propTypes = process.env.NODE_ENV !== "production" ? {
  children: _pt__default.node
} : {};
InFocusGuard.defaultProps = {
  children: null
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

// Only Node.JS has a process variable that is of [[Class]] process
var detectNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';

function ItoI(a) {
    return a;
}
function innerCreateMedium(defaults, middleware) {
    if (middleware === void 0) { middleware = ItoI; }
    var buffer = [];
    var assigned = false;
    var medium = {
        read: function () {
            if (assigned) {
                throw new Error('Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.');
            }
            if (buffer.length) {
                return buffer[buffer.length - 1];
            }
            return defaults;
        },
        useMedium: function (data) {
            var item = middleware(data, assigned);
            buffer.push(item);
            return function () {
                buffer = buffer.filter(function (x) { return x !== item; });
            };
        },
        assignSyncMedium: function (cb) {
            assigned = true;
            while (buffer.length) {
                var cbs = buffer;
                buffer = [];
                cbs.forEach(cb);
            }
            buffer = {
                push: function (x) { return cb(x); },
                filter: function () { return buffer; },
            };
        },
        assignMedium: function (cb) {
            assigned = true;
            var pendingQueue = [];
            if (buffer.length) {
                var cbs = buffer;
                buffer = [];
                cbs.forEach(cb);
                pendingQueue = buffer;
            }
            var executeQueue = function () {
                var cbs = pendingQueue;
                pendingQueue = [];
                cbs.forEach(cb);
            };
            var cycle = function () { return Promise.resolve().then(executeQueue); };
            cycle();
            buffer = {
                push: function (x) {
                    pendingQueue.push(x);
                    cycle();
                },
                filter: function (filter) {
                    pendingQueue = pendingQueue.filter(filter);
                    return buffer;
                },
            };
        },
    };
    return medium;
}
function createMedium(defaults, middleware) {
    if (middleware === void 0) { middleware = ItoI; }
    return innerCreateMedium(defaults, middleware);
}
function createSidecarMedium(options) {
    if (options === void 0) { options = {}; }
    var medium = innerCreateMedium(null);
    medium.options = __assign({ async: true, ssr: false }, options);
    return medium;
}

var SideCar = function (_a) {
    var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
    if (!sideCar) {
        throw new Error('Sidecar: please provide `sideCar` property to import the right car');
    }
    var Target = sideCar.read();
    if (!Target) {
        throw new Error('Sidecar medium not found');
    }
    return React.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
    medium.useMedium(exported);
    return SideCar;
}

var mediumFocus = createMedium({}, function (_ref) {
  var target = _ref.target,
      currentTarget = _ref.currentTarget;
  return {
    target: target,
    currentTarget: currentTarget
  };
});
var mediumBlur = createMedium();
var mediumEffect = createMedium();
var mediumSidecar = createSidecarMedium({
  async: true
});

var emptyArray = [];
var FocusLock = React.forwardRef(function (props, parentRef) {
  var _extends2;

  var _React$useState = React.useState(),
      realObserved = _React$useState[0],
      setObserved = _React$useState[1];

  var observed = React.useRef();
  var isActive = React.useRef(false);
  var originalFocusedElement = React.useRef(null);
  var children = props.children,
      disabled = props.disabled,
      noFocusGuards = props.noFocusGuards,
      persistentFocus = props.persistentFocus,
      crossFrame = props.crossFrame,
      autoFocus = props.autoFocus,
      allowTextSelection = props.allowTextSelection,
      group = props.group,
      className = props.className,
      whiteList = props.whiteList,
      _props$shards = props.shards,
      shards = _props$shards === void 0 ? emptyArray : _props$shards,
      _props$as = props.as,
      Container = _props$as === void 0 ? 'div' : _props$as,
      _props$lockProps = props.lockProps,
      containerProps = _props$lockProps === void 0 ? {} : _props$lockProps,
      SideCar = props.sideCar,
      shouldReturnFocus = props.returnFocus,
      onActivationCallback = props.onActivation,
      onDeactivationCallback = props.onDeactivation;

  var _React$useState2 = React.useState({}),
      id = _React$useState2[0]; // SIDE EFFECT CALLBACKS


  var onActivation = React.useCallback(function () {
    originalFocusedElement.current = originalFocusedElement.current || document && document.activeElement;

    if (observed.current && onActivationCallback) {
      onActivationCallback(observed.current);
    }

    isActive.current = true;
  }, [onActivationCallback]);
  var onDeactivation = React.useCallback(function () {
    isActive.current = false;

    if (onDeactivationCallback) {
      onDeactivationCallback(observed.current);
    }
  }, [onDeactivationCallback]);
  var returnFocus = React.useCallback(function (allowDefer) {
    var current = originalFocusedElement.current;

    if (Boolean(shouldReturnFocus) && current && current.focus) {
      var focusOptions = typeof shouldReturnFocus === 'object' ? shouldReturnFocus : undefined;
      originalFocusedElement.current = null;

      if (allowDefer) {
        // React might return focus after update
        // it's safer to defer the action
        Promise.resolve().then(function () {
          return current.focus(focusOptions);
        });
      } else {
        current.focus(focusOptions);
      }
    }
  }, [shouldReturnFocus]); // MEDIUM CALLBACKS

  var onFocus = React.useCallback(function (event) {
    if (isActive.current) {
      mediumFocus.useMedium(event);
    }
  }, []);
  var onBlur = mediumBlur.useMedium; // REF PROPAGATION
  // not using real refs due to race conditions

  var setObserveNode = React.useCallback(function (newObserved) {
    if (observed.current !== newObserved) {
      observed.current = newObserved;
      setObserved(newObserved);
    }
  }, []);

  if (process.env.NODE_ENV !== 'production') {
    if (typeof allowTextSelection !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn('React-Focus-Lock: allowTextSelection is deprecated and enabled by default');
    }

    React.useEffect(function () {
      if (!observed.current) {
        // eslint-disable-next-line no-console
        console.error('FocusLock: could not obtain ref to internal node');
      }
    }, []);
  }

  var lockProps = _extends$2((_extends2 = {}, _extends2[FOCUS_DISABLED] = disabled && 'disabled', _extends2[FOCUS_GROUP] = group, _extends2), containerProps);

  var hasLeadingGuards = noFocusGuards !== true;
  var hasTailingGuards = hasLeadingGuards && noFocusGuards !== 'tail';
  var mergedRef = useMergeRefs([parentRef, setObserveNode]);
  return React.createElement(React.Fragment, null, hasLeadingGuards && [React.createElement("div", {
    key: "guard-first",
    "data-focus-guard": true,
    tabIndex: disabled ? -1 : 0,
    style: hiddenGuard
  }), // nearest focus guard
  React.createElement("div", {
    key: "guard-nearest",
    "data-focus-guard": true,
    tabIndex: disabled ? -1 : 1,
    style: hiddenGuard
  })], !disabled && React.createElement(SideCar, {
    id: id,
    sideCar: mediumSidecar,
    observed: realObserved,
    disabled: disabled,
    persistentFocus: persistentFocus,
    crossFrame: crossFrame,
    autoFocus: autoFocus,
    whiteList: whiteList,
    shards: shards,
    onActivation: onActivation,
    onDeactivation: onDeactivation,
    returnFocus: returnFocus
  }), React.createElement(Container, _extends$2({
    ref: mergedRef
  }, lockProps, {
    className: className,
    onBlur: onBlur,
    onFocus: onFocus
  }), children), hasTailingGuards && React.createElement("div", {
    "data-focus-guard": true,
    tabIndex: disabled ? -1 : 0,
    style: hiddenGuard
  }));
});
FocusLock.propTypes = process.env.NODE_ENV !== "production" ? {
  children: _pt.node,
  disabled: _pt.bool,
  returnFocus: _pt.oneOfType([_pt.bool, _pt.object]),
  noFocusGuards: _pt.bool,
  allowTextSelection: _pt.bool,
  autoFocus: _pt.bool,
  persistentFocus: _pt.bool,
  crossFrame: _pt.bool,
  group: _pt.string,
  className: _pt.string,
  whiteList: _pt.func,
  shards: _pt.arrayOf(_pt.any),
  as: _pt.oneOfType([_pt.string, _pt.func, _pt.object]),
  lockProps: _pt.object,
  onActivation: _pt.func,
  onDeactivation: _pt.func,
  sideCar: _pt.any.isRequired
} : {};
FocusLock.defaultProps = {
  children: undefined,
  disabled: false,
  returnFocus: false,
  noFocusGuards: false,
  autoFocus: true,
  persistentFocus: false,
  crossFrame: true,
  allowTextSelection: undefined,
  group: undefined,
  className: undefined,
  whiteList: undefined,
  shards: undefined,
  as: 'div',
  lockProps: {},
  onActivation: undefined,
  onDeactivation: undefined
};

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function withSideEffect(reducePropsToState, handleStateChangeOnClient) {
  if (process.env.NODE_ENV !== "production") {
    if (typeof reducePropsToState !== 'function') {
      throw new Error('Expected reducePropsToState to be a function.');
    }

    if (typeof handleStateChangeOnClient !== 'function') {
      throw new Error('Expected handleStateChangeOnClient to be a function.');
    }
  }

  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || 'Component';
  }

  return function wrap(WrappedComponent) {
    if (process.env.NODE_ENV !== "production") {
      if (typeof WrappedComponent !== 'function') {
        throw new Error('Expected WrappedComponent to be a React component.');
      }
    }

    var mountedInstances = [];
    var state;

    function emitChange() {
      state = reducePropsToState(mountedInstances.map(function (instance) {
        return instance.props;
      }));
      handleStateChangeOnClient(state);
    }

    var SideEffect =
    /*#__PURE__*/
    function (_PureComponent) {
      _inheritsLoose(SideEffect, _PureComponent);

      function SideEffect() {
        return _PureComponent.apply(this, arguments) || this;
      }

      // Try to use displayName of wrapped component
      SideEffect.peek = function peek() {
        return state;
      };

      var _proto = SideEffect.prototype;

      _proto.componentDidMount = function componentDidMount() {
        mountedInstances.push(this);
        emitChange();
      };

      _proto.componentDidUpdate = function componentDidUpdate() {
        emitChange();
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        var index = mountedInstances.indexOf(this);
        mountedInstances.splice(index, 1);
        emitChange();
      };

      _proto.render = function render() {
        return React__default.createElement(WrappedComponent, this.props);
      };

      return SideEffect;
    }(React.PureComponent);

    _defineProperty$3(SideEffect, "displayName", "SideEffect(" + getDisplayName(WrappedComponent) + ")");

    return SideEffect;
  };
}

var toArray = function toArray(a) {
  var ret = Array(a.length);
  for (var i = 0; i < a.length; ++i) {
    ret[i] = a[i];
  }
  return ret;
};

var arrayFind = function arrayFind(array, search) {
  return array.filter(function (a) {
    return a === search;
  })[0];
};

var asArray = function asArray(a) {
  return Array.isArray(a) ? a : [a];
};

var tabSort = function tabSort(a, b) {
  var tabDiff = a.tabIndex - b.tabIndex;
  var indexDiff = a.index - b.index;

  if (tabDiff) {
    if (!a.tabIndex) return 1;
    if (!b.tabIndex) return -1;
  }

  return tabDiff || indexDiff;
};

var orderByTabIndex = function orderByTabIndex(nodes, filterNegative, keepGuards) {
  return toArray(nodes).map(function (node, index) {
    return {
      node: node,
      index: index,
      tabIndex: keepGuards && node.tabIndex === -1 ? (node.dataset || {}).focusGuard ? 0 : -1 : node.tabIndex
    };
  }).filter(function (data) {
    return !filterNegative || data.tabIndex >= 0;
  }).sort(tabSort);
};

var tabbables = ['button:enabled:not([readonly])', 'select:enabled:not([readonly])', 'textarea:enabled:not([readonly])', 'input:enabled:not([readonly])', 'a[href]', 'area[href]', 'iframe', 'object', 'embed', '[tabindex]', '[contenteditable]', '[autofocus]'];

var queryTabbables = tabbables.join(',');
var queryGuardTabbables = queryTabbables + ', [data-focus-guard]';

var getFocusables = function getFocusables(parents, withGuards) {
  return parents.reduce(function (acc, parent) {
    return acc.concat(
    // add all tabbables inside
    toArray(parent.querySelectorAll(withGuards ? queryGuardTabbables : queryTabbables)),
    // add if node is tabble itself
    parent.parentNode ? toArray(parent.parentNode.querySelectorAll(tabbables.join(','))).filter(function (node) {
      return node === parent;
    }) : []);
  }, []);
};

var getParentAutofocusables = function getParentAutofocusables(parent) {
  var parentFocus = parent.querySelectorAll('[' + FOCUS_AUTO + ']');
  return toArray(parentFocus).map(function (node) {
    return getFocusables([node]);
  }).reduce(function (acc, nodes) {
    return acc.concat(nodes);
  }, []);
};

var isElementHidden = function isElementHidden(computedStyle) {
  if (!computedStyle || !computedStyle.getPropertyValue) {
    return false;
  }
  return computedStyle.getPropertyValue('display') === 'none' || computedStyle.getPropertyValue('visibility') === 'hidden';
};

var isVisible = function isVisible(node) {
  return !node || node === document || node.nodeType === Node.DOCUMENT_NODE || !isElementHidden(window.getComputedStyle(node, null)) && isVisible(node.parentNode);
};

var notHiddenInput = function notHiddenInput(node) {
  return !((node.tagName === 'INPUT' || node.tagName === 'BUTTON') && (node.type === 'hidden' || node.disabled));
};

var getParents = function getParents(node) {
  var parents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  parents.push(node);
  if (node.parentNode) {
    getParents(node.parentNode, parents);
  }
  return parents;
};

var getCommonParent = function getCommonParent(nodea, nodeb) {
  var parentsA = getParents(nodea);
  var parentsB = getParents(nodeb);

  for (var i = 0; i < parentsA.length; i += 1) {
    var currentParent = parentsA[i];
    if (parentsB.indexOf(currentParent) >= 0) {
      return currentParent;
    }
  }
  return false;
};

var filterFocusable = function filterFocusable(nodes) {
  return toArray(nodes).filter(function (node) {
    return isVisible(node);
  }).filter(function (node) {
    return notHiddenInput(node);
  });
};

var getTabbableNodes = function getTabbableNodes(topNodes, withGuards) {
  return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards)), true, withGuards);
};

var getAllTabbableNodes = function getAllTabbableNodes(topNodes) {
  return orderByTabIndex(filterFocusable(getFocusables(topNodes)), false);
};

var parentAutofocusables = function parentAutofocusables(topNode) {
  return filterFocusable(getParentAutofocusables(topNode));
};

var isRadio = function isRadio(node) {
  return node.tagName === 'INPUT' && node.type === 'radio';
};

var findSelectedRadio = function findSelectedRadio(node, nodes) {
  return nodes.filter(isRadio).filter(function (el) {
    return el.name === node.name;
  }).filter(function (el) {
    return el.checked;
  })[0] || node;
};

var pickFirstFocus = function pickFirstFocus(nodes) {
  if (nodes[0] && nodes.length > 1) {
    if (isRadio(nodes[0]) && nodes[0].name) {
      return findSelectedRadio(nodes[0], nodes);
    }
  }
  return nodes[0];
};

var pickFocusable = function pickFocusable(nodes, index) {
  if (nodes.length > 1) {
    if (isRadio(nodes[index]) && nodes[index].name) {
      return nodes.indexOf(findSelectedRadio(nodes[index], nodes));
    }
  }
  return index;
};

var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var filterNested = function filterNested(nodes) {
  var l = nodes.length;
  for (var i = 0; i < l; i += 1) {
    var _loop = function _loop(j) {
      if (i !== j) {
        if (nodes[i].contains(nodes[j])) {
          return {
            v: filterNested(nodes.filter(function (x) {
              return x !== nodes[j];
            }))
          };
        }
      }
    };

    for (var j = 0; j < l; j += 1) {
      var _ret = _loop(j);

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof$1(_ret)) === "object") return _ret.v;
    }
  }
  return nodes;
};

var getTopParent = function getTopParent(node) {
  return node.parentNode ? getTopParent(node.parentNode) : node;
};

var getAllAffectedNodes = function getAllAffectedNodes(node) {
  var nodes = asArray(node);
  return nodes.filter(Boolean).reduce(function (acc, currentNode) {
    var group = currentNode.getAttribute(FOCUS_GROUP);
    acc.push.apply(acc, group ? filterNested(toArray(getTopParent(currentNode).querySelectorAll('[' + FOCUS_GROUP + '="' + group + '"]:not([' + FOCUS_DISABLED + '="disabled"])'))) : [currentNode]);
    return acc;
  }, []);
};

var findAutoFocused = function findAutoFocused(autoFocusables) {
  return function (node) {
    return !!node.autofocus || node.dataset && !!node.dataset.autofocus || autoFocusables.indexOf(node) >= 0;
  };
};

var isGuard = function isGuard(node) {
  return node && node.dataset && node.dataset.focusGuard;
};
var notAGuard = function notAGuard(node) {
  return !isGuard(node);
};

var newFocus = function newFocus(innerNodes, outerNodes, activeElement, lastNode, autoFocused) {
  var cnt = innerNodes.length;
  var firstFocus = innerNodes[0];
  var lastFocus = innerNodes[cnt - 1];
  var isOnGuard = isGuard(activeElement);

  // focus is inside
  if (innerNodes.indexOf(activeElement) >= 0) {
    return undefined;
  }

  var activeIndex = outerNodes.indexOf(activeElement);
  var lastIndex = outerNodes.indexOf(lastNode || activeIndex);
  var lastNodeInside = innerNodes.indexOf(lastNode);
  var indexDiff = activeIndex - lastIndex;
  var firstNodeIndex = outerNodes.indexOf(firstFocus);
  var lastNodeIndex = outerNodes.indexOf(lastFocus);

  var returnFirstNode = pickFocusable(innerNodes, 0);
  var returnLastNode = pickFocusable(innerNodes, cnt - 1);

  // new focus
  if (activeIndex === -1 || lastNodeInside === -1) {
    return innerNodes.indexOf(autoFocused && autoFocused.length ? pickFirstFocus(autoFocused) : pickFirstFocus(innerNodes));
  }
  // old focus
  if (!indexDiff && lastNodeInside >= 0) {
    return lastNodeInside;
  }
  // first element
  if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnLastNode;
  }
  // last element
  if (activeIndex >= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnFirstNode;
  }
  // jump out, but not on the guard
  if (indexDiff && Math.abs(indexDiff) > 1) {
    return lastNodeInside;
  }
  // focus above lock
  if (activeIndex <= firstNodeIndex) {
    return returnLastNode;
  }
  // focus below lock
  if (activeIndex > lastNodeIndex) {
    return returnFirstNode;
  }
  // index is inside tab order, but outside Lock
  if (indexDiff) {
    if (Math.abs(indexDiff) > 1) {
      return lastNodeInside;
    }
    return (cnt + lastNodeInside + indexDiff) % cnt;
  }
  // do nothing
  return undefined;
};

var getTopCommonParent = function getTopCommonParent(baseActiveElement, leftEntry, rightEntries) {
  var activeElements = asArray(baseActiveElement);
  var leftEntries = asArray(leftEntry);
  var activeElement = activeElements[0];
  var topCommon = null;
  leftEntries.filter(Boolean).forEach(function (entry) {
    topCommon = getCommonParent(topCommon || entry, entry) || topCommon;
    rightEntries.filter(Boolean).forEach(function (subEntry) {
      var common = getCommonParent(activeElement, subEntry);
      if (common) {
        if (!topCommon || common.contains(topCommon)) {
          topCommon = common;
        } else {
          topCommon = getCommonParent(common, topCommon);
        }
      }
    });
  });
  return topCommon;
};

var allParentAutofocusables = function allParentAutofocusables(entries) {
  return entries.reduce(function (acc, node) {
    return acc.concat(parentAutofocusables(node));
  }, []);
};

var reorderNodes = function reorderNodes(srcNodes, dstNodes) {
  var remap = new Map();
  // no Set(dstNodes) for IE11 :(
  dstNodes.forEach(function (entity) {
    return remap.set(entity.node, entity);
  });
  // remap to dstNodes
  return srcNodes.map(function (node) {
    return remap.get(node);
  }).filter(Boolean);
};

var getFocusabledIn = function getFocusabledIn(topNode) {
  var entries = getAllAffectedNodes(topNode).filter(notAGuard);
  var commonParent = getTopCommonParent(topNode, topNode, entries);
  var outerNodes = getTabbableNodes([commonParent], true);
  var innerElements = getTabbableNodes(entries).filter(function (_ref) {
    var node = _ref.node;
    return notAGuard(node);
  }).map(function (_ref2) {
    var node = _ref2.node;
    return node;
  });

  return outerNodes.map(function (_ref3) {
    var node = _ref3.node,
        index = _ref3.index;
    return {
      node: node,
      index: index,
      lockItem: innerElements.indexOf(node) >= 0,
      guard: isGuard(node)
    };
  });
};

var getFocusMerge = function getFocusMerge(topNode, lastNode) {
  var activeElement = document && document.activeElement;
  var entries = getAllAffectedNodes(topNode).filter(notAGuard);

  var commonParent = getTopCommonParent(activeElement || topNode, topNode, entries);

  var innerElements = getTabbableNodes(entries).filter(function (_ref4) {
    var node = _ref4.node;
    return notAGuard(node);
  });

  if (!innerElements[0]) {
    innerElements = getAllTabbableNodes(entries).filter(function (_ref5) {
      var node = _ref5.node;
      return notAGuard(node);
    });
    if (!innerElements[0]) {
      return undefined;
    }
  }

  var outerNodes = getTabbableNodes([commonParent]).map(function (_ref6) {
    var node = _ref6.node;
    return node;
  });
  var orderedInnerElements = reorderNodes(outerNodes, innerElements);
  var innerNodes = orderedInnerElements.map(function (_ref7) {
    var node = _ref7.node;
    return node;
  });

  var newId = newFocus(innerNodes, outerNodes, activeElement, lastNode, innerNodes.filter(findAutoFocused(allParentAutofocusables(entries))));

  if (newId === undefined) {
    return newId;
  }
  return orderedInnerElements[newId];
};

var focusInFrame = function focusInFrame(frame) {
  return frame === document.activeElement;
};

var focusInsideIframe = function focusInsideIframe(topNode) {
  return !!arrayFind(toArray(topNode.querySelectorAll('iframe')), focusInFrame);
};

var focusInside = function focusInside(topNode) {
  var activeElement = document && document.activeElement;

  if (!activeElement || activeElement.dataset && activeElement.dataset.focusGuard) {
    return false;
  }
  return getAllAffectedNodes(topNode).reduce(function (result, node) {
    return result || node.contains(activeElement) || focusInsideIframe(node);
  }, false);
};

var focusIsHidden = function focusIsHidden() {
  return document && toArray(document.querySelectorAll('[' + FOCUS_ALLOW + ']')).some(function (node) {
    return node.contains(document.activeElement);
  });
};

var focusOn = function focusOn(target) {
  target.focus();
  if (target.contentWindow) {
    target.contentWindow.focus();
  }
};

var guardCount = 0;
var lockDisabled = false;

var setFocus = (function (topNode, lastNode) {
  var focusable = getFocusMerge(topNode, lastNode);

  if (lockDisabled) {
    return;
  }

  if (focusable) {
    if (guardCount > 2) {
      // eslint-disable-next-line no-console
      console.error('FocusLock: focus-fighting detected. Only one focus management system could be active. ' + 'See https://github.com/theKashey/focus-lock/#focus-fighting');
      lockDisabled = true;
      setTimeout(function () {
        lockDisabled = false;
      }, 1);
      return;
    }
    guardCount++;
    focusOn(focusable.node);
    guardCount--;
  }
});

function deferAction(action) {
  // Hidding setImmediate from Webpack to avoid inserting polyfill
  var _window = window,
      setImmediate = _window.setImmediate;

  if (typeof setImmediate !== 'undefined') {
    setImmediate(action);
  } else {
    setTimeout(action, 1);
  }
}
var inlineProp = function inlineProp(name, value) {
  var obj = {};
  obj[name] = value;
  return obj;
};

var focusOnBody = function focusOnBody() {
  return document && document.activeElement === document.body;
};

var isFreeFocus = function isFreeFocus() {
  return focusOnBody() || focusIsHidden();
};

var lastActiveTrap = null;
var lastActiveFocus = null;
var lastPortaledElement = null;
var focusWasOutsideWindow = false;

var defaultWhitelist = function defaultWhitelist() {
  return true;
};

var focusWhitelisted = function focusWhitelisted(activeElement) {
  return (lastActiveTrap.whiteList || defaultWhitelist)(activeElement);
};

var recordPortal = function recordPortal(observerNode, portaledElement) {
  lastPortaledElement = {
    observerNode: observerNode,
    portaledElement: portaledElement
  };
};

var focusIsPortaledPair = function focusIsPortaledPair(element) {
  return lastPortaledElement && lastPortaledElement.portaledElement === element;
};

function autoGuard(startIndex, end, step, allNodes) {
  var lastGuard = null;
  var i = startIndex;

  do {
    var item = allNodes[i];

    if (item.guard) {
      if (item.node.dataset.focusAutoGuard) {
        lastGuard = item;
      }
    } else if (item.lockItem) {
      if (i !== startIndex) {
        // we will tab to the next element
        return;
      }

      lastGuard = null;
    } else {
      break;
    }
  } while ((i += step) !== end);

  if (lastGuard) {
    lastGuard.node.tabIndex = 0;
  }
}

var extractRef = function extractRef(ref) {
  return ref && 'current' in ref ? ref.current : ref;
};

var focusWasOutside = function focusWasOutside(crossFrameOption) {
  if (crossFrameOption) {
    // with cross frame return true for any value
    return Boolean(focusWasOutsideWindow);
  } // in other case return only of focus went a while aho


  return focusWasOutsideWindow === "meanwhile";
};

var activateTrap = function activateTrap() {
  var result = false;

  if (lastActiveTrap) {
    var _lastActiveTrap = lastActiveTrap,
        observed = _lastActiveTrap.observed,
        persistentFocus = _lastActiveTrap.persistentFocus,
        autoFocus = _lastActiveTrap.autoFocus,
        shards = _lastActiveTrap.shards,
        crossFrame = _lastActiveTrap.crossFrame;
    var workingNode = observed || lastPortaledElement && lastPortaledElement.portaledElement;
    var activeElement = document && document.activeElement;

    if (workingNode) {
      var workingArea = [workingNode].concat(shards.map(extractRef).filter(Boolean));

      if (!activeElement || focusWhitelisted(activeElement)) {
        if (persistentFocus || focusWasOutside(crossFrame) || !isFreeFocus() || !lastActiveFocus && autoFocus) {
          if (workingNode && !(focusInside(workingArea) || focusIsPortaledPair(activeElement))) {
            if (document && !lastActiveFocus && activeElement && !autoFocus) {
              activeElement.blur();
              document.body.focus();
            } else {
              result = setFocus(workingArea, lastActiveFocus);
              lastPortaledElement = {};
            }
          }

          focusWasOutsideWindow = false;
          lastActiveFocus = document && document.activeElement;
        }
      }

      if (document) {
        var newActiveElement = document && document.activeElement;
        var allNodes = getFocusabledIn(workingArea);
        var focusedItem = allNodes.find(function (_ref) {
          var node = _ref.node;
          return node === newActiveElement;
        });

        if (focusedItem) {
          // remove old focus
          allNodes.filter(function (_ref2) {
            var guard = _ref2.guard,
                node = _ref2.node;
            return guard && node.dataset.focusAutoGuard;
          }).forEach(function (_ref3) {
            var node = _ref3.node;
            return node.removeAttribute('tabIndex');
          });
          var focusedIndex = allNodes.indexOf(focusedItem);
          autoGuard(focusedIndex, allNodes.length, +1, allNodes);
          autoGuard(focusedIndex, -1, -1, allNodes);
        }
      }
    }
  }

  return result;
};

var onTrap = function onTrap(event) {
  if (activateTrap() && event) {
    // prevent scroll jump
    event.stopPropagation();
    event.preventDefault();
  }
};

var onBlur = function onBlur() {
  return deferAction(activateTrap);
};

var onFocus = function onFocus(event) {
  // detect portal
  var source = event.target;
  var currentNode = event.currentTarget;

  if (!currentNode.contains(source)) {
    recordPortal(currentNode, source);
  }
};

var FocusWatcher = function FocusWatcher() {
  return null;
};

var FocusTrap = function FocusTrap(_ref4) {
  var children = _ref4.children;
  return React.createElement("div", {
    onBlur: onBlur,
    onFocus: onFocus
  }, children);
};

FocusTrap.propTypes = process.env.NODE_ENV !== "production" ? {
  children: _pt__default.node.isRequired
} : {};

var onWindowBlur = function onWindowBlur() {
  focusWasOutsideWindow = "just"; // using setTimeout to set  this variable after React/sidecar reaction

  setTimeout(function () {
    focusWasOutsideWindow = "meanwhile";
  }, 0);
};

var attachHandler = function attachHandler() {
  document.addEventListener('focusin', onTrap, true);
  document.addEventListener('focusout', onBlur);
  window.addEventListener('blur', onWindowBlur);
};

var detachHandler = function detachHandler() {
  document.removeEventListener('focusin', onTrap, true);
  document.removeEventListener('focusout', onBlur);
  window.removeEventListener('blur', onWindowBlur);
};

function reducePropsToState(propsList) {
  return propsList.filter(function (_ref5) {
    var disabled = _ref5.disabled;
    return !disabled;
  });
}

function handleStateChangeOnClient(traps) {
  var trap = traps.slice(-1)[0];

  if (trap && !lastActiveTrap) {
    attachHandler();
  }

  var lastTrap = lastActiveTrap;
  var sameTrap = lastTrap && trap && trap.id === lastTrap.id;
  lastActiveTrap = trap;

  if (lastTrap && !sameTrap) {
    lastTrap.onDeactivation(); // return focus only of last trap was removed

    if (!traps.filter(function (_ref6) {
      var id = _ref6.id;
      return id === lastTrap.id;
    }).length) {
      // allow defer is no other trap is awaiting restore
      lastTrap.returnFocus(!trap);
    }
  }

  if (trap) {
    lastActiveFocus = null;

    if (!sameTrap || lastTrap.observed !== trap.observed) {
      trap.onActivation();
    }

    activateTrap();
    deferAction(activateTrap);
  } else {
    detachHandler();
    lastActiveFocus = null;
  }
} // bind medium


mediumFocus.assignSyncMedium(onFocus);
mediumBlur.assignMedium(onBlur);
mediumEffect.assignMedium(function (cb) {
  return cb({
    moveFocusInside: setFocus,
    focusInside: focusInside
  });
});
var FocusTrap$1 = withSideEffect(reducePropsToState, handleStateChangeOnClient)(FocusWatcher);

/* that would be a BREAKING CHANGE!
// delaying sidecar execution till the first usage
const RequireSideCar = (props) => {
  // eslint-disable-next-line global-require
  const SideCar = require('./Trap').default;
  return <SideCar {...props} />;
};
*/

var FocusLockCombination = React.forwardRef(function (props, ref) {
  return React.createElement(FocusLock, _extends$2({
    sideCar: FocusTrap$1,
    ref: ref
  }, props));
});

var _ref$1 = FocusLock.propTypes || {},
    sideCar = _ref$1.sideCar,
    propTypes = _objectWithoutPropertiesLoose$3(_ref$1, ["sideCar"]);

FocusLockCombination.propTypes = propTypes;

var AutoFocusInside = function AutoFocusInside(_ref) {
  var disabled = _ref.disabled,
      children = _ref.children,
      className = _ref.className;
  return React.createElement("div", _extends$2({}, inlineProp(FOCUS_AUTO, !disabled), {
    className: className
  }), children);
};

AutoFocusInside.propTypes = process.env.NODE_ENV !== "production" ? {
  children: _pt__default.node.isRequired,
  disabled: _pt__default.bool,
  className: _pt__default.string
} : {};
AutoFocusInside.defaultProps = {
  disabled: false,
  className: undefined
};

function MoveFocusInside(_ref) {
  var isDisabled = _ref.disabled,
      className = _ref.className,
      children = _ref.children;
  var ref = React.useRef(null);
  var disabled = React.useRef(isDisabled);

  var moveFocus = function moveFocus() {
    var observed = ref.current;
    mediumEffect.useMedium(function (car) {
      if (!disabled.current && observed) {
        if (!car.focusInside(observed)) {
          car.moveFocusInside(observed, null);
        }
      }
    });
  };

  React.useEffect(function () {
    disabled.current = isDisabled;
    moveFocus();
  }, [isDisabled]);
  return React.createElement("div", _extends$2({}, inlineProp(FOCUS_AUTO, !isDisabled), {
    ref: ref,
    className: className
  }), children);
}

MoveFocusInside.propTypes = process.env.NODE_ENV !== "production" ? {
  children: _pt__default.node.isRequired,
  disabled: _pt__default.bool,
  className: _pt__default.string
} : {};
MoveFocusInside.defaultProps = {
  disabled: false,
  className: undefined
};

var FreeFocusInside = function FreeFocusInside(_ref) {
  var children = _ref.children,
      className = _ref.className;
  return React.createElement("div", _extends$2({}, inlineProp(FOCUS_ALLOW, true), {
    className: className
  }), children);
};

FreeFocusInside.propTypes = process.env.NODE_ENV !== "production" ? {
  children: _pt__default.node.isRequired,
  className: _pt__default.string
} : {};
FreeFocusInside.defaultProps = {
  className: undefined
};

var zeroRightClassName = 'right-scroll-bar-position';
var fullWidthClassName = 'width-before-scroll-bar';
var noScrollbarsClassName = 'with-scroll-bars-hidden';

var effectCar = createSidecarMedium();

var nothing = function () {
    return;
};
var RemoveScroll = React.forwardRef(function (props, parentRef) {
    var ref = React.useRef(null);
    var _a = React.useState({
        onScrollCapture: nothing,
        onWheelCapture: nothing,
        onTouchMoveCapture: nothing
    }), callbacks = _a[0], setCallbacks = _a[1];
    var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom"]);
    var SideCar = sideCar;
    var containerProps = __assign({ ref: useMergeRefs([
            ref,
            parentRef
        ]) }, rest, callbacks);
    return (React.createElement(React.Fragment, null,
        enabled && (React.createElement(SideCar, { sideCar: effectCar, removeScrollBar: removeScrollBar, shards: shards, noIsolation: noIsolation, inert: inert, setCallbacks: setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref })),
        forwardProps ? (React.cloneElement(React.Children.only(children), containerProps)) : (React.createElement("div", __assign({}, containerProps, { className: className }), children))));
});
RemoveScroll.defaultProps = {
    enabled: true,
    removeScrollBar: true,
    inert: false
};
RemoveScroll.classNames = {
    fullWidth: fullWidthClassName,
    zeroRight: zeroRightClassName
};

var getNonce = function () {
    if (typeof __webpack_nonce__ !== 'undefined') {
        return __webpack_nonce__;
    }
    return undefined;
};

function makeStyleTag() {
    if (!document)
        return null;
    var tag = document.createElement('style');
    tag.type = 'text/css';
    var nonce = getNonce();
    if (nonce) {
        tag.setAttribute('nonce', nonce);
    }
    return tag;
}
function injectStyles(tag, css) {
    if (tag.styleSheet) {
        tag.styleSheet.cssText = css;
    }
    else {
        tag.appendChild(document.createTextNode(css));
    }
}
function insertStyleTag(tag) {
    var head = document.head || document.getElementsByTagName('head')[0];
    head.appendChild(tag);
}
var stylesheetSingleton = function () {
    var counter = 0;
    var stylesheet = null;
    return {
        add: function (style) {
            if (counter == 0) {
                if (stylesheet = makeStyleTag()) {
                    injectStyles(stylesheet, style);
                    insertStyleTag(stylesheet);
                }
            }
            counter++;
        },
        remove: function () {
            counter--;
            if (!counter && stylesheet) {
                stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
                stylesheet = null;
            }
        }
    };
};

var styleHookSingleton = function () {
    var sheet = stylesheetSingleton();
    return function (styles) {
        React.useEffect(function () {
            sheet.add(styles);
            return function () {
                sheet.remove();
            };
        }, []);
    };
};

var styleSingleton = function () {
    var useStyle = styleHookSingleton();
    var Sheet = function (_a) {
        var styles = _a.styles;
        useStyle(styles);
        return null;
    };
    return Sheet;
};

var zeroGap = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0,
};
var parse = function (x) { return parseInt(x || '', 10) || 0; };
var getOffset = function (gapMode) {
    var cs = window.getComputedStyle(document.body);
    var left = cs[gapMode === 'padding' ? 'paddingLeft' : 'marginLeft'];
    var top = cs[gapMode === 'padding' ? 'paddingTop' : 'marginTop'];
    var right = cs[gapMode === 'padding' ? 'paddingRight' : 'marginRight'];
    return [
        parse(left),
        parse(top),
        parse(right),
    ];
};
var getGapWidth = function (gapMode) {
    if (gapMode === void 0) { gapMode = 'margin'; }
    if (typeof window === 'undefined') {
        return zeroGap;
    }
    var offsets = getOffset(gapMode);
    var documentWidth = document.documentElement.clientWidth;
    var windowWidth = window.innerWidth;
    return {
        left: offsets[0],
        top: offsets[1],
        right: offsets[2],
        gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0]),
    };
};

var Style = styleSingleton();
var getStyles = function (_a, allowRelative, gapMode, important) {
    var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
    if (gapMode === void 0) { gapMode = 'margin'; }
    return "\n  ." + noScrollbarsClassName + " {\n   overflow: hidden " + important + ";\n   padding-right: " + gap + "px " + important + ";\n  }\n  body {\n    overflow: hidden " + important + ";\n    " + [
        allowRelative && "position: relative " + important + ";",
        gapMode === 'margin' && "\n    padding-left: " + left + "px;\n    padding-top: " + top + "px;\n    padding-right: " + right + "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: " + gap + "px " + important + ";\n    ",
        gapMode === 'padding' && "padding-right: " + gap + "px " + important + ";",
    ].filter(Boolean).join('') + "\n  }\n  \n  ." + zeroRightClassName + " {\n    right: " + gap + "px " + important + ";\n  }\n  \n  ." + fullWidthClassName + " {\n    margin-right: " + gap + "px " + important + ";\n  }\n  \n  ." + zeroRightClassName + " ." + zeroRightClassName + " {\n    right: 0 " + important + ";\n  }\n  \n  ." + fullWidthClassName + " ." + fullWidthClassName + " {\n    margin-right: 0 " + important + ";\n  }\n";
};
var RemoveScrollBar = function (props) {
    var _a = React.useState(getGapWidth(props.gapMode)), gap = _a[0], setGap = _a[1];
    React.useEffect(function () {
        setGap(getGapWidth(props.gapMode));
    }, [props.gapMode]);
    var noRelative = props.noRelative, noImportant = props.noImportant, _b = props.gapMode, gapMode = _b === void 0 ? 'margin' : _b;
    return React.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : '') });
};

var elementCouldBeVScrolled = function (node) {
    var styles = window.getComputedStyle(node);
    return (styles.overflowY !== 'hidden' && // not-not-scrollable
        !(styles.overflowY === styles.overflowX && styles.overflowY === 'visible') // scrollable
    );
};
var elementCouldBeHScrolled = function (node) {
    var styles = window.getComputedStyle(node);
    return (styles.overflowX !== 'hidden' && // not-not-scrollable
        !(styles.overflowY === styles.overflowX && styles.overflowX === 'visible') // scrollable
    );
};
var locationCouldBeScrolled = function (axis, node) {
    var current = node;
    do {
        var isScrollable = elementCouldBeScrolled(axis, current);
        if (isScrollable) {
            var _a = getScrollVariables(axis, current), s = _a[1], d = _a[2];
            if (s > d) {
                return true;
            }
        }
        current = current.parentNode;
    } while (current && current !== document.body);
    return false;
};
var getVScrollVariables = function (_a) {
    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
    return [scrollTop, scrollHeight, clientHeight];
};
var getHScrollVariables = function (_a) {
    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
    return [scrollLeft, scrollWidth, clientWidth];
};
var elementCouldBeScrolled = function (axis, node) {
    return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function (axis, node) {
    return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node);
};
var handleScroll = function (axis, endTarget, event, sourceDelta, noOverscroll) {
    var delta = sourceDelta;
    // find scrollable target
    var target = event.target;
    var targetInLock = endTarget.contains(target);
    var shouldCancelScroll = false;
    var isDeltaPositive = delta > 0;
    var availableScroll = 0;
    var availableScrollTop = 0;
    do {
        var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
        var elementScroll = scroll_1 - capacity - position;
        if (position || elementScroll) {
            if (elementCouldBeScrolled(axis, target)) {
                availableScroll += elementScroll;
                availableScrollTop += position;
            }
        }
        target = target.parentNode;
    } while (
    // portaled content
    (!targetInLock && target !== document.body) ||
        // self content
        (targetInLock && (endTarget.contains(target) || endTarget === target)));
    if (isDeltaPositive &&
        ((noOverscroll && availableScroll === 0) ||
            (!noOverscroll && delta > availableScroll))) {
        shouldCancelScroll = true;
    }
    else if (!isDeltaPositive &&
        ((noOverscroll && availableScrollTop === 0) ||
            (!noOverscroll && -delta > availableScrollTop))) {
        shouldCancelScroll = true;
    }
    return shouldCancelScroll;
};

var passiveSupported = false;
if (typeof window !== 'undefined') {
    try {
        var options = Object.defineProperty({}, 'passive', {
            get: function () {
                passiveSupported = true;
                return true;
            }
        });
        window.addEventListener('test', options, options);
        window.removeEventListener('test', options, options);
    }
    catch (err) {
        passiveSupported = false;
    }
}
var nonPassive = passiveSupported ? { passive: false } : false;

var getTouchXY = function (event) {
    return 'changedTouches' in event
        ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY]
        : [0, 0];
};
var getDeltaXY = function (event) { return [event.deltaX, event.deltaY]; };
var extractRef$1 = function (ref) {
    return ref && 'current' in ref ? ref.current : ref;
};
var deltaCompare = function (x, y) {
    return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function (id) { return "\n  .block-interactivity-" + id + " {pointer-events: none;}\n  .allow-interactivity-" + id + " {pointer-events: all;}\n"; };
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
    var shouldPreventQueue = React.useRef([]);
    var touchStartRef = React.useRef([0, 0]);
    var activeAxis = React.useRef();
    var id = React.useState(idCounter++)[0];
    var Style = React.useState(function () { return styleSingleton(); })[0];
    var lastProps = React.useRef(props);
    React.useEffect(function () {
        lastProps.current = props;
    }, [props]);
    React.useEffect(function () {
        if (props.inert) {
            document.body.classList.add("block-interactivity-" + id);
            var allow_1 = [
                props.lockRef.current
            ].concat((props.shards || []).map(extractRef$1)).filter(Boolean);
            allow_1.forEach(function (el) { return el.classList.add("allow-interactivity-" + id); });
            return function () {
                document.body.classList.remove("block-interactivity-" + id);
                allow_1.forEach(function (el) {
                    return el.classList.remove("allow-interactivity-" + id);
                });
            };
        }
        return;
    }, [props.inert, props.lockRef.current, props.shards]);
    var shouldCancelEvent = React.useCallback(function (event, parent) {
        if ('touches' in event && event.touches.length === 2) {
            return !lastProps.current.allowPinchZoom;
        }
        var touch = getTouchXY(event);
        var touchStart = touchStartRef.current;
        var deltaX = 'deltaX' in event ? event.deltaX : touchStart[0] - touch[0];
        var deltaY = 'deltaY' in event ? event.deltaY : touchStart[1] - touch[1];
        var currentAxis;
        var target = event.target;
        var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? 'h' : 'v';
        var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
        if (!canBeScrolledInMainDirection) {
            return true;
        }
        if (canBeScrolledInMainDirection) {
            currentAxis = moveDirection;
        }
        else {
            currentAxis = moveDirection === 'v' ? 'h' : 'v';
            canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
            // other axis might be not scrollable
        }
        if (!canBeScrolledInMainDirection) {
            return false;
        }
        if (!activeAxis.current &&
            'changedTouches' in event &&
            (deltaX || deltaY)) {
            activeAxis.current = currentAxis;
        }
        if (!currentAxis) {
            return true;
        }
        var cancelingAxis = activeAxis.current || currentAxis;
        return handleScroll(cancelingAxis, parent, event, cancelingAxis == 'h' ? deltaX : deltaY, true);
    }, []);
    var shouldPrevent = React.useCallback(function (_event) {
        var event = _event;
        if (!lockStack.length || lockStack[lockStack.length - 1] !== Style) {
            // not the last active
            return;
        }
        var delta = 'deltaY' in event ? getDeltaXY(event) : getTouchXY(event);
        var sourceEvent = shouldPreventQueue.current.filter(function (e) {
            return e.name === event.type &&
                e.target === event.target &&
                deltaCompare(e.delta, delta);
        })[0];
        // self event, and should be canceled
        if (sourceEvent && sourceEvent.should) {
            event.preventDefault();
            return;
        }
        // outside or shard event
        if (!sourceEvent) {
            var shardNodes = (lastProps.current.shards || [])
                .map(extractRef$1)
                .filter(Boolean)
                .filter(function (node) { return node.contains(event.target); });
            var shouldStop = shardNodes.length > 0
                ? shouldCancelEvent(event, shardNodes[0])
                : !lastProps.current.noIsolation;
            if (shouldStop) {
                event.preventDefault();
            }
        }
    }, []);
    var shouldCancel = React.useCallback(function (name, delta, target, should) {
        var event = { name: name, delta: delta, target: target, should: should };
        shouldPreventQueue.current.push(event);
        setTimeout(function () {
            shouldPreventQueue.current = shouldPreventQueue.current.filter(function (e) { return e !== event; });
        }, 1);
    }, []);
    var scrollTouchStart = React.useCallback(function (event) {
        touchStartRef.current = getTouchXY(event);
        activeAxis.current = undefined;
    }, []);
    var scrollWheel = React.useCallback(function (event) {
        shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    var scrollTouchMove = React.useCallback(function (event) {
        shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    React.useEffect(function () {
        lockStack.push(Style);
        props.setCallbacks({
            onScrollCapture: scrollWheel,
            onWheelCapture: scrollWheel,
            onTouchMoveCapture: scrollTouchMove
        });
        document.addEventListener('wheel', shouldPrevent, nonPassive);
        document.addEventListener('touchmove', shouldPrevent, nonPassive);
        document.addEventListener('touchstart', scrollTouchStart, nonPassive);
        return function () {
            lockStack = lockStack.filter(function (inst) { return inst !== Style; });
            document.removeEventListener('wheel', shouldPrevent, nonPassive);
            document.removeEventListener('touchmove', shouldPrevent, nonPassive);
            document.removeEventListener('touchstart', scrollTouchStart, nonPassive);
        };
    }, []);
    var removeScrollBar = props.removeScrollBar, inert = props.inert;
    return (React.createElement(React.Fragment, null,
        inert ? React.createElement(Style, { styles: generateStyle(id) }) : null,
        removeScrollBar ? React.createElement(RemoveScrollBar, { gapMode: "margin" }) : null));
}

var SideCar$1 = exportSidecar(effectCar, RemoveScrollSideCar);

var ReactRemoveScroll = React.forwardRef(function (props, ref) { return (React.createElement(RemoveScroll, __assign({}, props, { ref: ref, sideCar: SideCar$1 }))); });
ReactRemoveScroll.classNames = RemoveScroll.classNames;

function _extends$3() {
  _extends$3 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$3.apply(this, arguments);
}

function _objectWithoutPropertiesLoose$4(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var overlayPropTypes = {
  initialFocusRef: function initialFocusRef() {
    return null;
  },
  allowPinchZoom: _pt__default.bool,
  onDismiss: _pt__default.func
}; ////////////////////////////////////////////////////////////////////////////////

/**
 * DialogOverlay
 *
 * Low-level component if you need more control over the styles or rendering of
 * the dialog overlay.
 *
 * Note: You must render a `DialogContent` inside.
 *
 * @see Docs https://reacttraining.com/reach-ui/dialog#dialogoverlay
 */

var DialogOverlay = /*#__PURE__*/React.forwardRef(function DialogOverlay(_ref, forwardedRef) {
  var _ref$isOpen = _ref.isOpen,
      isOpen = _ref$isOpen === void 0 ? true : _ref$isOpen,
      props = _objectWithoutPropertiesLoose$4(_ref, ["isOpen"]);

  React.useEffect(function () {
    return checkStyles("dialog");
  }, []); // We want to ignore the immediate focus of a tooltip so it doesn't pop
  // up again when the menu closes, only pops up when focus returns again
  // to the tooltip (like native OS tooltips).

  React.useEffect(function () {
    if (isOpen) {
      // @ts-ignore
      window.__REACH_DISABLE_TOOLTIPS = true;
    } else {
      window.requestAnimationFrame(function () {
        // Wait a frame so that this doesn't fire before tooltip does
        // @ts-ignore
        window.__REACH_DISABLE_TOOLTIPS = false;
      });
    }
  }, [isOpen]);
  return isOpen ? React__default.createElement(Portal, {
    "data-reach-dialog-wrapper": ""
  }, React__default.createElement(DialogInner, Object.assign({
    ref: forwardedRef
  }, props))) : null;
});

if (process.env.NODE_ENV !== "production") {
  DialogOverlay.displayName = "DialogOverlay";
  DialogOverlay.propTypes = /*#__PURE__*/_extends$3( /*#__PURE__*/_extends$3({}, overlayPropTypes), {}, {
    isOpen: _pt__default.bool
  });
} ////////////////////////////////////////////////////////////////////////////////

/**
 * DialogInner
 */


var DialogInner = /*#__PURE__*/React.forwardRef(function DialogInner(_ref2, forwardedRef) {
  var allowPinchZoom = _ref2.allowPinchZoom,
      initialFocusRef = _ref2.initialFocusRef,
      onClick = _ref2.onClick,
      _ref2$onDismiss = _ref2.onDismiss,
      onDismiss = _ref2$onDismiss === void 0 ? noop : _ref2$onDismiss,
      onMouseDown = _ref2.onMouseDown,
      onKeyDown = _ref2.onKeyDown,
      _ref2$unstable_lockFo = _ref2.unstable_lockFocusAcrossFrames,
      unstable_lockFocusAcrossFrames = _ref2$unstable_lockFo === void 0 ? true : _ref2$unstable_lockFo,
      props = _objectWithoutPropertiesLoose$4(_ref2, ["allowPinchZoom", "initialFocusRef", "onClick", "onDismiss", "onMouseDown", "onKeyDown", "unstable_lockFocusAcrossFrames"]);

  var mouseDownTarget = React.useRef(null);
  var overlayNode = React.useRef(null);
  var ref = useForkedRef(overlayNode, forwardedRef);
  var activateFocusLock = React.useCallback(function () {
    if (initialFocusRef && initialFocusRef.current) {
      initialFocusRef.current.focus();
    }
  }, [initialFocusRef]);

  function handleClick(event) {
    if (mouseDownTarget.current === event.target) {
      event.stopPropagation();
      onDismiss(event);
    }
  }

  function handleKeyDown(event) {
    if (event.key === "Escape") {
      event.stopPropagation();
      onDismiss(event);
    }
  }

  function handleMouseDown(event) {
    mouseDownTarget.current = event.target;
  }

  React.useEffect(function () {
    return overlayNode.current ? createAriaHider(overlayNode.current) : void null;
  }, []);
  return React__default.createElement(FocusLockCombination, {
    autoFocus: true,
    returnFocus: true,
    onActivation: activateFocusLock,
    crossFrame: unstable_lockFocusAcrossFrames
  }, React__default.createElement(ReactRemoveScroll, {
    allowPinchZoom: allowPinchZoom
  }, React__default.createElement("div", Object.assign({}, props, {
    ref: ref,
    "data-reach-dialog-overlay": "",

    /*
     * We can ignore the `no-static-element-interactions` warning here
     * because our overlay is only designed to capture any outside
     * clicks, not to serve as a clickable element itself.
     */
    onClick: wrapEvent(onClick, handleClick),
    onKeyDown: wrapEvent(onKeyDown, handleKeyDown),
    onMouseDown: wrapEvent(onMouseDown, handleMouseDown)
  }))));
});

if (process.env.NODE_ENV !== "production") {
  DialogOverlay.displayName = "DialogOverlay";
  DialogOverlay.propTypes = /*#__PURE__*/_extends$3({}, overlayPropTypes);
} ////////////////////////////////////////////////////////////////////////////////

/**
 * DialogContent
 *
 * Low-level component if you need more control over the styles or rendering of
 * the dialog content.
 *
 * Note: Must be a child of `DialogOverlay`.
 *
 * Note: You only need to use this when you are also styling `DialogOverlay`,
 * otherwise you can use the high-level `Dialog` component and pass the props
 * to it. Any props passed to `Dialog` component (besides `isOpen` and
 * `onDismiss`) will be spread onto `DialogContent`.
 *
 * @see Docs https://reacttraining.com/reach-ui/dialog#dialogcontent
 */


var DialogContent = /*#__PURE__*/React.forwardRef(function DialogContent(_ref3, forwardedRef) {
  var onClick = _ref3.onClick,
      onKeyDown = _ref3.onKeyDown,
      props = _objectWithoutPropertiesLoose$4(_ref3, ["onClick", "onKeyDown"]);

  return React__default.createElement("div", Object.assign({
    "aria-modal": "true",
    role: "dialog",
    tabIndex: -1
  }, props, {
    ref: forwardedRef,
    "data-reach-dialog-content": "",
    onClick: wrapEvent(onClick, function (event) {
      event.stopPropagation();
    })
  }));
});

if (process.env.NODE_ENV !== "production") {
  DialogContent.displayName = "DialogContent";
  DialogContent.propTypes = {
    "aria-label": ariaLabelType,
    "aria-labelledby": ariaLabelType
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * Dialog
 *
 * High-level component to render a modal dialog window over the top of the page
 * (or another dialog).
 *
 * @see Docs https://reacttraining.com/reach-ui/dialog#dialog
 */


var Dialog = /*#__PURE__*/React.forwardRef(function Dialog(_ref4, forwardedRef) {
  var isOpen = _ref4.isOpen,
      _ref4$onDismiss = _ref4.onDismiss,
      onDismiss = _ref4$onDismiss === void 0 ? noop : _ref4$onDismiss,
      initialFocusRef = _ref4.initialFocusRef,
      allowPinchZoom = _ref4.allowPinchZoom,
      props = _objectWithoutPropertiesLoose$4(_ref4, ["isOpen", "onDismiss", "initialFocusRef", "allowPinchZoom"]);

  return React__default.createElement(DialogOverlay, {
    initialFocusRef: initialFocusRef,
    allowPinchZoom: allowPinchZoom,
    isOpen: isOpen,
    onDismiss: onDismiss
  }, React__default.createElement(DialogContent, Object.assign({
    ref: forwardedRef
  }, props)));
});

if (process.env.NODE_ENV !== "production") {
  Dialog.displayName = "Dialog";
  Dialog.propTypes = {
    isOpen: _pt__default.bool,
    onDismiss: _pt__default.func,
    "aria-label": ariaLabelType,
    "aria-labelledby": ariaLabelType
  };
}

function createAriaHider(dialogNode) {
  var originalValues = [];
  var rootNodes = [];
  var ownerDocument = getOwnerDocument(dialogNode) || document;

  if (!dialogNode) {
    if (process.env.NODE_ENV !== "production") {
      console.warn("A ref has not yet been attached to a dialog node when attempting to call `createAriaHider`.");
    }

    return noop;
  }

  Array.prototype.forEach.call(ownerDocument.querySelectorAll("body > *"), function (node) {
    var _dialogNode$parentNod, _dialogNode$parentNod2;

    var portalNode = (_dialogNode$parentNod = dialogNode.parentNode) === null || _dialogNode$parentNod === void 0 ? void 0 : (_dialogNode$parentNod2 = _dialogNode$parentNod.parentNode) === null || _dialogNode$parentNod2 === void 0 ? void 0 : _dialogNode$parentNod2.parentNode;

    if (node === portalNode) {
      return;
    }

    var attr = node.getAttribute("aria-hidden");
    var alreadyHidden = attr !== null && attr !== "false";

    if (alreadyHidden) {
      return;
    }

    originalValues.push(attr);
    rootNodes.push(node);
    node.setAttribute("aria-hidden", "true");
  });
  return function () {
    rootNodes.forEach(function (node, index) {
      var originalValue = originalValues[index];

      if (originalValue === null) {
        node.removeAttribute("aria-hidden");
      } else {
        node.setAttribute("aria-hidden", originalValue);
      }
    });
  };
}

function ariaLabelType(props, propName, compName, location, propFullName) {
  var details = "\nSee https://www.w3.org/TR/wai-aria/#aria-label for details.";

  if (!props["aria-label"] && !props["aria-labelledby"]) {
    return new Error("A <" + compName + "> must have either an `aria-label` or `aria-labelledby` prop.\n      " + details);
  }

  if (props["aria-label"] && props["aria-labelledby"]) {
    return new Error("You provided both `aria-label` and `aria-labelledby` props to a <" + compName + ">. If the a label for this component is visible on the screen, that label's component should be given a unique ID prop, and that ID should be passed as the `aria-labelledby` prop into <" + compName + ">. If the label cannot be determined programmatically from the content of the element, an alternative label should be provided as the `aria-label` prop, which will be used as an `aria-label` on the HTML tag." + details);
  } else if (props[propName] != null && !isString(props[propName])) {
    return new Error("Invalid prop `" + propName + "` supplied to `" + compName + "`. Expected `string`, received `" + (Array.isArray(propFullName) ? "array" : typeof propFullName) + "`.");
  }

  return null;
}

/**
 * To mark our components built on top of ReachUI as safe for tree-shaking, we have to apply global styles
 * from @reach/<component>/styles.css locally via Emotion instead of importing them
 *
 * However, @reach/<component>> will display a warning if we do so,
 * and this is what this hack component is for.
 *
 * It MUST be a component, so that it can be rendered before/at the same time as the ReachUI component
 */

function DisableReachStyleCheck(_ref) {
  var reachComponent = _ref.reachComponent;
  React__default.useEffect(function () {
    var reachCheckProperty = "--reach-".concat(reachComponent);
    var reachCheckValue = parseInt(window.getComputedStyle(document.body).getPropertyValue(reachCheckProperty), 10);

    if (reachCheckValue !== 1) {
      document.body.style.setProperty(reachCheckProperty, "1");
    }
  }, []);
  return null;
}

function _templateObject$2() {
  var data = _taggedTemplateLiteral(["\n    0% {\n       background-color: transparent;\n     }\n   \n     100% {\n       background-color: ", ";\n     }\n   "]);

  _templateObject$2 = function _templateObject() {
    return data;
  };

  return data;
}

var buildFadeIn = function buildFadeIn(color) {
  return core.keyframes(_templateObject$2(), color);
};

var fadeMap = {
  info: buildFadeIn(hexToRGBA(colors.purple[50], 0.75)),
  success: buildFadeIn(hexToRGBA(colors.green[50], 0.75)),
  warn: buildFadeIn(hexToRGBA(colors.orange[50], 0.75)),
  error: buildFadeIn(hexToRGBA(colors.red[50], 0.75))
};

var overlayCss = function overlayCss(theme) {
  return {
    background: "hsla(0, 0%, 0%, 0.33)",
    position: "fixed",
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    overflow: "auto",
    zIndex: theme.zIndices.modals
  };
};

var Modal = function Modal(_ref) {
  var _ref$type = _ref.type,
      type = _ref$type === void 0 ? "info" : _ref$type,
      initialFocusRef = _ref.initialFocusRef,
      isOpen = _ref.isOpen,
      onDismiss = _ref.onDismiss,
      children = _ref.children,
      props = _objectWithoutProperties(_ref, ["type", "initialFocusRef", "isOpen", "onDismiss", "children"]);

  return core.jsx(React__default.Fragment, null, core.jsx(DisableReachStyleCheck, {
    reachComponent: "dialog"
  }), core.jsx(DialogOverlay, {
    initialFocusRef: initialFocusRef,
    isOpen: isOpen,
    onDismiss: onDismiss,
    css: function css(theme) {
      return [overlayCss(theme), {
        animation: "".concat(fadeMap[type], " 0.5s ease forwards")
      }];
    }
  }, React__default.cloneElement(children, props)));
};
Modal.propTypes = {
  type: _pt__default.oneOf(["success", "info", "warn", "error"])
};
Modal.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "Modal",
  "props": {
    "type": {
      "defaultValue": {
        "value": "\"info\"",
        "computed": false
      },
      "required": false
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Modal/Modal.tsx"] = {
    name: "Modal",
    docgenInfo: Modal.__docgenInfo,
    path: "src/components/Modal/Modal.tsx"
  };
}

var ModalContent = styled$1(DialogContent)({
  outline: "none",
  margin: 0,
  padding: 0,
  background: "transparent",
  width: "auto"
});

function _templateObject$3() {
  var data = _taggedTemplateLiteral(["\n  100% {\n     transform: translate(0, calc(50vh - 50%)) scale(1) perspective(1000px) rotateX(0);\n  }\n"]);

  _templateObject$3 = function _templateObject() {
    return data;
  };

  return data;
}
var cardIncoming = core.keyframes(_templateObject$3());

var baseCss$8 = function baseCss(theme) {
  var _ref;

  return _ref = {
    background: theme.colors.white,
    borderRadius: theme.radii[3],
    boxShadow: "0px 5px 30px rgba(0, 0, 0, 0.2)",
    maxWidth: "calc(100% - (".concat(theme.space[5], " * 2))"),
    animation: "".concat(cardIncoming, " 0.5s 0.25s ease forwards"),
    transform: "translate(0, 90vh) scale(0.9) perspective(1000px) rotateX(-90deg)",
    transformOrigin: "top center",
    margin: "0 auto"
  }, _defineProperty(_ref, theme.mediaQueries.mobile, {
    maxWidth: "calc(100% - (".concat(theme.space[7], " * 2))")
  }), _defineProperty(_ref, theme.mediaQueries.phablet, {
    width: "620px"
  }), _ref;
};

var ModalCard = function ModalCard(props) {
  return core.jsx(ModalContent, _extends({
    css: baseCss$8
  }, props));
};
ModalCard.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "ModalCard"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Modal/ModalCard.tsx"] = {
    name: "ModalCard",
    docgenInfo: ModalCard.__docgenInfo,
    path: "src/components/Modal/ModalCard.tsx"
  };
}

function _templateObject$4() {
  var data = _taggedTemplateLiteral(["\n  0% {\n    transform: translate3d", "\n   }\n \n   100% {\n    transform: translate3d(0,0,0);\n   }\n "]);

  _templateObject$4 = function _templateObject() {
    return data;
  };

  return data;
}

var buildTranslation = function buildTranslation(position) {
  return core.keyframes(_templateObject$4(), position === "left" ? "(-100%, 0,0)" : "(100%,0,0)");
};

var translateLeft = buildTranslation("left");
var translateRight = buildTranslation("right");

var baseCss$9 = function baseCss(theme) {
  return {
    background: theme.colors.white,
    height: "100vh",
    position: "absolute",
    animationDuration: "0.5s",
    animationFillMode: "forwards",
    animationTimingFunction: "ease"
  };
};

var ModalPanel = function ModalPanel(_ref) {
  var _ref$maxWidth = _ref.maxWidth,
      maxWidth = _ref$maxWidth === void 0 ? "20%" : _ref$maxWidth,
      _ref$position = _ref.position,
      position = _ref$position === void 0 ? "right" : _ref$position,
      props = _objectWithoutProperties(_ref, ["maxWidth", "position"]);

  return core.jsx(ModalContent, _extends({
    css: function css(theme) {
      return [baseCss$9(theme), {
        maxWidth: maxWidth
      }, position === "right" ? {
        right: 0,
        animationName: translateRight
      } : {
        left: 0,
        animationName: translateLeft
      }];
    }
  }, props));
};
ModalPanel.propTypes = {
  position: _pt__default.oneOf(["left", "right"]),
  maxWidth: _pt__default.string
};
ModalPanel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "ModalPanel",
  "props": {
    "maxWidth": {
      "defaultValue": {
        "value": "`20%`",
        "computed": false
      },
      "required": false
    },
    "position": {
      "defaultValue": {
        "value": "`right`",
        "computed": false
      },
      "required": false
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Modal/ModalPanel.tsx"] = {
    name: "ModalPanel",
    docgenInfo: ModalPanel.__docgenInfo,
    path: "src/components/Modal/ModalPanel.tsx"
  };
}

function _templateObject$5() {
  var data = _taggedTemplateLiteral(["\n  100% {\n     transform: translate(0, 0) scale(1) perspective(1000px) rotateX(0);\n  }\n"]);

  _templateObject$5 = function _templateObject() {
    return data;
  };

  return data;
}
var rotationIncoming = core.keyframes(_templateObject$5());

var baseCss$a = function baseCss(theme) {
  return {
    background: theme.colors.white,
    height: "100vh",
    width: "100%",
    position: "relative",
    overflowY: "auto",
    overflowX: "hidden",
    animation: "".concat(rotationIncoming, " 0.5s 0.25s ease forwards"),
    transform: "translate(0, 150vh) scale(0.9) perspective(1000px) rotateX(-90deg)",
    transformOrigin: "top center"
  };
};

var ModalFullScreen = function ModalFullScreen(props) {
  return core.jsx(ModalContent, _extends({
    css: baseCss$a
  }, props));
};
ModalFullScreen.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "ModalFullScreen"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Modal/ModalFullScreen.tsx"] = {
    name: "ModalFullScreen",
    docgenInfo: ModalFullScreen.__docgenInfo,
    path: "src/components/Modal/ModalFullScreen.tsx"
  };
}

function _templateObject$6() {
  var data = _taggedTemplateLiteral(["\n  100% {\n     opacity: 1\n  }\n"]);

  _templateObject$6 = function _templateObject() {
    return data;
  };

  return data;
}
var entry = core.keyframes(_templateObject$6());
var headerCss = function headerCss(theme) {
  var _ref;

  return _ref = {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    padding: "".concat(theme.space[7], " ").concat(theme.space[8]),
    borderRadius: "".concat(theme.radii[3], " ").concat(theme.radii[3], " 0 0"),
    background: theme.colors.white
  }, _defineProperty(_ref, theme.mediaQueries.mobile, {
    paddingLeft: theme.space[8],
    paddingRight: theme.space[8]
  }), _defineProperty(_ref, theme.mediaQueries.phablet, {
    paddingLeft: theme.space[9],
    paddingRight: theme.space[9]
  }), _ref;
};
var titleCss = function titleCss(theme) {
  return {
    animation: "".concat(entry, " 0.75s 0.7s ease forwards"),
    fontSize: theme.fontSizes[4],
    opacity: 0
  };
};
var CLOSE_BUTTON_SIZE = 40;
var CLOSE_ICON_SIZE = 20;
var closeButtonCss = function closeButtonCss(_theme) {
  return {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    border: "none",
    background: "none",
    padding: 0,
    cursor: "pointer",
    width: CLOSE_BUTTON_SIZE,
    height: CLOSE_BUTTON_SIZE,
    transform: "translateX(".concat(CLOSE_BUTTON_SIZE - CLOSE_ICON_SIZE / 2, ")")
  };
};
var closeIconCss = function closeIconCss(_theme) {
  return {
    width: CLOSE_ICON_SIZE,
    height: CLOSE_ICON_SIZE
  };
};
var bodyCss = function bodyCss(theme) {
  var _ref2;

  return _ref2 = {
    display: "flex",
    flexDirection: "column",
    background: theme.colors.white,
    padding: "".concat(theme.space[5], " ").concat(theme.space[8], " ").concat(theme.space[7]),
    borderRadius: "0 0 ".concat(theme.radii[3], " ").concat(theme.radii[3]),
    animation: "".concat(entry, " 0.75s 0.8s ease forwards"),
    opacity: 0
  }, _defineProperty(_ref2, theme.mediaQueries.mobile, {
    paddingTop: theme.space[7],
    paddingBottom: theme.space[7],
    paddingRight: theme.space[7],
    paddingLeft: theme.space[7]
  }), _defineProperty(_ref2, theme.mediaQueries.phablet, {
    paddingTop: theme.space[8],
    paddingBottom: theme.space[8],
    paddingRight: theme.space[8],
    paddingLeft: theme.space[8]
  }), _ref2;
};

var bodyGradientBaseCss = function bodyGradientBaseCss(theme) {
  return {
    position: "relative",
    ":before": {
      position: "absolute",
      content: '""',
      top: "0",
      left: "0",
      width: "100%",
      height: "5px",
      backgroundSize: "50px 50px",
      backgroundImage: "linear-gradient(\n        130deg,\n        ".concat(hexToRGBA(theme.colors.white, 0.5, true), " 25%,\n        transparent 25%,\n        transparent 50%,\n        ").concat(hexToRGBA(theme.colors.white, 0.5, true), " 50%,\n        ").concat(hexToRGBA(theme.colors.white, 0.5, true), " 75%,\n        transparent 75%,\n        transparent\n      )")
    }
  };
};

var bodyVariantCss = {
  DEFAULT: function DEFAULT(_theme) {
    return {};
  },
  SUCCESS: function SUCCESS(theme) {
    return {
      backgroundColor: theme.colors.green[5],
      borderTop: "1px solid ".concat(theme.colors.green[10])
    };
  },
  WARNING: function WARNING(theme) {
    return [bodyGradientBaseCss(theme), {
      backgroundColor: theme.colors.red[5],
      ":before": {
        backgroundColor: hexToRGBA(theme.colors.red[50], 0.8, true)
      }
    }];
  },
  ERROR: function ERROR(theme) {
    return {
      backgroundColor: theme.colors.red[5],
      borderTop: "1px solid ".concat(theme.colors.red[10])
    };
  },
  ACTION: function ACTION(theme) {
    return {
      backgroundColor: theme.colors.purple[5],
      borderTop: "1px solid ".concat(theme.colors.purple[10])
    };
  },
  RETAKE: function RETAKE(theme) {
    return [bodyGradientBaseCss(theme), {
      backgroundColor: theme.colors.purple[5],
      ":before": {
        backgroundColor: hexToRGBA(theme.colors.purple[50], 0.8, true)
      }
    }];
  }
};
var actionsCss = function actionsCss(theme) {
  return _defineProperty({
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    width: "100%",
    marginTop: theme.space[7]
  }, theme.mediaQueries.desktop, {
    marginTop: theme.space[8]
  });
};

var StyledModalContext = React__default.createContext({
  variant: "DEFAULT"
});
function useStyledModalContext() {
  return React__default.useContext(StyledModalContext);
}
function StyledModal(_ref) {
  var children = _ref.children,
      _ref$variant = _ref.variant,
      variant = _ref$variant === void 0 ? "DEFAULT" : _ref$variant;
  return core.jsx(StyledModalContext.Provider, {
    value: {
      variant: variant
    }
  }, children);
}
StyledModal.propTypes = {
  children: _pt__default.node.isRequired,
  variant: _pt__default.oneOf(["DEFAULT", "SUCCESS", "WARNING", "ERROR", "ACTION", "RETAKE"])
};
function StyledModalHeader(_ref2) {
  var children = _ref2.children,
      onCloseButtonClick = _ref2.onCloseButtonClick,
      _ref2$closeButtonLabe = _ref2.closeButtonLabel,
      closeButtonLabel = _ref2$closeButtonLabe === void 0 ? "Close modal" : _ref2$closeButtonLabe;
  return core.jsx("div", {
    css: headerCss
  }, core.jsx(Heading, {
    css: titleCss
  }, children), core.jsx(StyledModalCloseButton, {
    onClick: onCloseButtonClick,
    "aria-label": closeButtonLabel
  }));
}
StyledModalHeader.propTypes = {
  children: _pt__default.node.isRequired,
  onCloseButtonClick: _pt__default.func,
  closeButtonLabel: _pt__default.string
};
function StyledModalCloseButton(props) {
  return core.jsx("button", _extends({
    css: closeButtonCss
  }, props), core.jsx(md.MdClose, {
    css: closeIconCss
  }));
}
function StyledModalBody(_ref3) {
  var children = _ref3.children;

  var _useStyledModalContex = useStyledModalContext(),
      variant = _useStyledModalContex.variant;

  return core.jsx("div", {
    css: function css(theme) {
      return [bodyCss(theme), bodyVariantCss[variant](theme)];
    }
  }, children);
}
StyledModalBody.propTypes = {
  children: _pt__default.node.isRequired
};
function StyledModalActions(_ref4) {
  var children = _ref4.children;
  return core.jsx("div", {
    css: actionsCss
  }, children);
}
StyledModalActions.propTypes = {
  children: _pt__default.node.isRequired
};
StyledModal.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "StyledModal",
  "props": {
    "variant": {
      "defaultValue": {
        "value": "`DEFAULT`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "union",
        "raw": "`DEFAULT`\n| `SUCCESS`\n| `WARNING`\n| `ERROR`\n| `ACTION`\n| `RETAKE`",
        "elements": [{
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }]
      },
      "description": ""
    },
    "children": {
      "required": true,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Modal/StyledModal.tsx"] = {
    name: "StyledModal",
    docgenInfo: StyledModal.__docgenInfo,
    path: "src/components/Modal/StyledModal.tsx"
  };
}

StyledModalHeader.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "StyledModalHeader",
  "props": {
    "closeButtonLabel": {
      "defaultValue": {
        "value": "`Close modal`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "children": {
      "required": true,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    },
    "onCloseButtonClick": {
      "required": false,
      "tsType": {
        "name": "signature",
        "type": "function",
        "raw": "() => void",
        "signature": {
          "arguments": [],
          "return": {
            "name": "void"
          }
        }
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Modal/StyledModal.tsx"] = {
    name: "StyledModalHeader",
    docgenInfo: StyledModalHeader.__docgenInfo,
    path: "src/components/Modal/StyledModal.tsx"
  };
}

StyledModalCloseButton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "StyledModalCloseButton"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Modal/StyledModal.tsx"] = {
    name: "StyledModalCloseButton",
    docgenInfo: StyledModalCloseButton.__docgenInfo,
    path: "src/components/Modal/StyledModal.tsx"
  };
}

StyledModalBody.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "StyledModalBody",
  "props": {
    "children": {
      "required": true,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Modal/StyledModal.tsx"] = {
    name: "StyledModalBody",
    docgenInfo: StyledModalBody.__docgenInfo,
    path: "src/components/Modal/StyledModal.tsx"
  };
}

StyledModalActions.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "StyledModalActions",
  "props": {
    "children": {
      "required": true,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Modal/StyledModal.tsx"] = {
    name: "StyledModalActions",
    docgenInfo: StyledModalActions.__docgenInfo,
    path: "src/components/Modal/StyledModal.tsx"
  };
}

var StickyObserverContext = React__default.createContext({
  isStuck: false,
  lipShadowPosition: "bottom",
  setIsIntersecting: function setIsIntersecting() {
    return undefined;
  }
});
// This component is a shorthand; use
//  - StickyObserverProvider,
//  - StickyObservedContainer
//  - StickyObserverSentinel
//  - StickyLipShadow
// if you need more control over DOM structure,
function StickyObserver(_ref) {
  var lipShadowPosition = _ref.lipShadowPosition,
      children = _ref.children,
      rest = _objectWithoutProperties(_ref, ["lipShadowPosition", "children"]);

  return core.jsx(StickyObserverProvider, {
    lipShadowPosition: lipShadowPosition
  }, core.jsx(StickyObservedContainer, rest, children));
}
StickyObserver.propTypes = {
  lipShadowPosition: _pt__default.oneOf(["top", "bottom"]).isRequired
};
function StickyObserverProvider(_ref2) {
  var lipShadowPosition = _ref2.lipShadowPosition,
      children = _ref2.children;

  var _React$useState = React__default.useState(false),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      isIntersecting = _React$useState2[0],
      setIsIntersecting = _React$useState2[1];

  var contextValue = {
    isStuck: isIntersecting,
    setIsIntersecting: setIsIntersecting,
    lipShadowPosition: lipShadowPosition
  };
  return core.jsx(StickyObserverContext.Provider, {
    value: contextValue
  }, children);
}
StickyObserverProvider.propTypes = {
  lipShadowPosition: _pt__default.oneOf(["top", "bottom"]).isRequired,
  children: _pt__default.node.isRequired
};
function useStickyObserver() {
  return React__default.useContext(StickyObserverContext);
}
function StickyObservedContainer(_ref3) {
  var children = _ref3.children,
      rest = _objectWithoutProperties(_ref3, ["children"]);

  var _useStickyObserver = useStickyObserver(),
      lipShadowPosition = _useStickyObserver.lipShadowPosition;

  return core.jsx(React__default.Fragment, null, lipShadowPosition === "bottom" && core.jsx(StickyObserverSentinel, null), core.jsx(StickyObserverSentinel, null), core.jsx("div", _extends({
    css: [{
      position: "sticky",
      zIndex: 1,
      left: 0,
      width: "100%"
    }, lipShadowPosition === "top" && {
      bottom: 0
    }, lipShadowPosition === "bottom" && {
      top: 0
    }]
  }, rest), lipShadowPosition === "top" && core.jsx(StickyLipShadow, null), children, lipShadowPosition === "bottom" && core.jsx(StickyLipShadow, null)), lipShadowPosition === "top" && core.jsx(StickyObserverSentinel, null));
}
// A "sentinel" is a hack DIV element that is rendered next to the sticky element:
//  - before the sticky element if it sticks to the top
//  - after the sticky element if it sticks to the bottom
// IntersectionObserver does not work properly for elements with position: sticky,
// and this is why this "sentinel" is needed if we want to use Intersection API to identify
// whether a sticky element has "stuck".
//
// When the sticky element gets "stuck", it pushes the sentinel away from the screen, triggering an intersection entry
// When the sticky element gets "unstuck", the sentinel appears on the screen, triggering an intersection entry
function StickyObserverSentinel(_props) {
  var _useStickyObserver2 = useStickyObserver(),
      setIsIntersecting = _useStickyObserver2.setIsIntersecting,
      lipShadowPosition = _useStickyObserver2.lipShadowPosition;

  var sentinelRef = React__default.useRef(null);
  var observerRef = React__default.useRef(null);
  React__default.useEffect(function () {
    if (!sentinelRef.current) {
      return;
    }

    observerRef.current = new IntersectionObserver(function (entries) {
      if (entries[0].intersectionRatio === 0) {
        setIsIntersecting(true);
      } else if (entries[0].intersectionRatio === 1) {
        setIsIntersecting(false);
      }
    }, {
      threshold: [0, 1]
    });
    observerRef.current.observe(sentinelRef.current);
    return function () {
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    };
  }, [lipShadowPosition, sentinelRef.current]);
  return core.jsx("div", {
    ref: sentinelRef,
    css: {
      height: "1px"
    },
    "aria-hidden": true
  });
}
// Lip shadows MUST be rendered as children of the sticky element for proper positioning
function StickyLipShadow(_props) {
  var _useStickyObserver3 = useStickyObserver(),
      isStuck = _useStickyObserver3.isStuck,
      lipShadowPosition = _useStickyObserver3.lipShadowPosition;

  return core.jsx("div", {
    "data-sticky-lip-visible": isStuck,
    css: function css(theme) {
      return [{
        height: 0,
        position: "relative",
        ":before": {
          content: '""',
          display: "block",
          position: "absolute",
          left: 0,
          right: 0,
          height: 1,
          transition: "box-lip ".concat(theme.transitions["default"]),
          boxShadow: "none"
        }
      }, lipShadowPosition === "top" && {
        ":before": {
          top: 0
        },
        '&[data-sticky-lip-visible="true"]:before': {
          boxShadow: getLipBoxShadow(theme, "top")
        }
      }, lipShadowPosition === "bottom" && {
        ":before": {
          bottom: 0
        },
        '&[data-sticky-lip-visible="true"]:before': {
          boxShadow: getLipBoxShadow(theme, "bottom")
        }
      }];
    }
  });
}

function getLipBoxShadow(theme, shadowDirection) {
  return "\n        0px ".concat(shadowDirection === "top" ? -2 : 2, "px 2px ").concat(theme.colors.blackFade[20], ",\n        0px ").concat(shadowDirection === "top" ? -4 : 4, "px 4px ").concat(theme.colors.blackFade[40], "\n    ");
}

StickyObserver.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "StickyObserver",
  "props": {
    "lipShadowPosition": {
      "required": true,
      "tsType": {
        "name": "union",
        "raw": "`top` | `bottom`",
        "elements": [{
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }]
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/StickyObserver/StickyObserver.tsx"] = {
    name: "StickyObserver",
    docgenInfo: StickyObserver.__docgenInfo,
    path: "src/components/StickyObserver/StickyObserver.tsx"
  };
}

StickyObserverProvider.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "StickyObserverProvider",
  "props": {
    "lipShadowPosition": {
      "required": true,
      "tsType": {
        "name": "union",
        "raw": "`top` | `bottom`",
        "elements": [{
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }]
      },
      "description": ""
    },
    "children": {
      "required": true,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/StickyObserver/StickyObserver.tsx"] = {
    name: "StickyObserverProvider",
    docgenInfo: StickyObserverProvider.__docgenInfo,
    path: "src/components/StickyObserver/StickyObserver.tsx"
  };
}

StickyObservedContainer.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "StickyObservedContainer"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/StickyObserver/StickyObserver.tsx"] = {
    name: "StickyObservedContainer",
    docgenInfo: StickyObservedContainer.__docgenInfo,
    path: "src/components/StickyObserver/StickyObserver.tsx"
  };
}

StickyObserverSentinel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "StickyObserverSentinel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/StickyObserver/StickyObserver.tsx"] = {
    name: "StickyObserverSentinel",
    docgenInfo: StickyObserverSentinel.__docgenInfo,
    path: "src/components/StickyObserver/StickyObserver.tsx"
  };
}

StickyLipShadow.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "StickyLipShadow"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/StickyObserver/StickyObserver.tsx"] = {
    name: "StickyLipShadow",
    docgenInfo: StickyLipShadow.__docgenInfo,
    path: "src/components/StickyObserver/StickyObserver.tsx"
  };
}

function StyledPanel(_ref) {
  var children = _ref.children;
  return core.jsx(React__default.Fragment, null, children);
}
StyledPanel.propTypes = {
  children: _pt__default.node.isRequired
};

var headerContainerCss = function headerContainerCss(theme) {
  return {
    backgroundColor: theme.colors.white,
    borderBottom: "1px solid ".concat(theme.colors.grey[20])
  };
};

var headerCss$1 = function headerCss(theme) {
  return {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    paddingTop: theme.space[7],
    paddingRight: theme.space[7],
    paddingBottom: theme.space[7],
    paddingLeft: theme.space[7]
  };
};

function StyledPanelHeader(_ref2) {
  var children = _ref2.children,
      onCloseButtonClick = _ref2.onCloseButtonClick,
      _ref2$closeButtonLabe = _ref2.closeButtonLabel,
      closeButtonLabel = _ref2$closeButtonLabe === void 0 ? "Close panel" : _ref2$closeButtonLabe;
  return core.jsx(StickyObserver, {
    lipShadowPosition: "bottom",
    css: headerContainerCss
  }, core.jsx("div", {
    css: headerCss$1
  }, core.jsx(Heading, {
    variant: "PRIMARY"
  }, children), core.jsx(StyledPanelCloseButton, {
    onClick: onCloseButtonClick,
    "aria-label": closeButtonLabel
  })));
}
StyledPanelHeader.propTypes = {
  children: _pt__default.node.isRequired,
  onCloseButtonClick: _pt__default.func,
  closeButtonLabel: _pt__default.string
};
function StyledPanelCloseButton(props) {
  return core.jsx(StyledModalCloseButton, props);
}

var bodySectionCss = function bodySectionCss(theme) {
  return {
    backgroundColor: theme.colors.white,
    paddingTop: theme.space[5],
    paddingRight: theme.space[7],
    paddingBottom: theme.space[7],
    paddingLeft: theme.space[7]
  };
};

function StyledPanelBodySection(_ref3) {
  var children = _ref3.children;
  return core.jsx("div", {
    css: bodySectionCss
  }, children);
}
StyledPanelBodySection.propTypes = {
  children: _pt__default.node.isRequired
};

var actionsContainerCss = function actionsContainerCss(theme) {
  return {
    width: "100%",
    backgroundColor: theme.colors.white,
    borderTop: "1px solid ".concat(theme.colors.grey[20])
  };
};

var actionsCss$1 = function actionsCss(theme) {
  return {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    paddingTop: theme.space[7],
    paddingRight: theme.space[7],
    paddingBottom: theme.space[7],
    paddingLeft: theme.space[7]
  };
};

function StyledPanelActions(_ref4) {
  var children = _ref4.children;
  return core.jsx(StickyObserver, {
    lipShadowPosition: "top",
    css: actionsContainerCss
  }, core.jsx("div", {
    css: actionsCss$1
  }, children));
}
StyledPanelActions.propTypes = {
  children: _pt__default.node.isRequired
};
StyledPanel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "StyledPanel",
  "props": {
    "children": {
      "required": true,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Modal/StyledPanel.tsx"] = {
    name: "StyledPanel",
    docgenInfo: StyledPanel.__docgenInfo,
    path: "src/components/Modal/StyledPanel.tsx"
  };
}

StyledPanelHeader.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "StyledPanelHeader",
  "props": {
    "closeButtonLabel": {
      "defaultValue": {
        "value": "`Close panel`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "children": {
      "required": true,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    },
    "onCloseButtonClick": {
      "required": false,
      "tsType": {
        "name": "signature",
        "type": "function",
        "raw": "() => void",
        "signature": {
          "arguments": [],
          "return": {
            "name": "void"
          }
        }
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Modal/StyledPanel.tsx"] = {
    name: "StyledPanelHeader",
    docgenInfo: StyledPanelHeader.__docgenInfo,
    path: "src/components/Modal/StyledPanel.tsx"
  };
}

StyledPanelCloseButton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "StyledPanelCloseButton"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Modal/StyledPanel.tsx"] = {
    name: "StyledPanelCloseButton",
    docgenInfo: StyledPanelCloseButton.__docgenInfo,
    path: "src/components/Modal/StyledPanel.tsx"
  };
}

StyledPanelBodySection.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "StyledPanelBodySection",
  "props": {
    "children": {
      "required": true,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Modal/StyledPanel.tsx"] = {
    name: "StyledPanelBodySection",
    docgenInfo: StyledPanelBodySection.__docgenInfo,
    path: "src/components/Modal/StyledPanel.tsx"
  };
}

StyledPanelActions.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "StyledPanelActions",
  "props": {
    "children": {
      "required": true,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Modal/StyledPanel.tsx"] = {
    name: "StyledPanelActions",
    docgenInfo: StyledPanelActions.__docgenInfo,
    path: "src/components/Modal/StyledPanel.tsx"
  };
}

/**
 * Welcome to @reach/visually-hidden!
 *
 * Provides text for screen readers that is visually hidden.
 * It is the logical opposite of the `aria-hidden` attribute.
 *
 * @see https://snook.ca/archives/html_and_css/hiding-content-for-accessibility
 * @see https://a11yproject.com/posts/how-to-hide-content/
 * @see Docs     https://reacttraining.com/reach-ui/visually-hidden
 * @see Source   https://github.com/reach/reach-ui/tree/master/packages/visually-hidden
 */
/**
 * VisuallyHidden
 *
 * Provides text for screen readers that is visually hidden.
 * It is the logical opposite of the `aria-hidden` attribute.
 */

var VisuallyHidden = /*#__PURE__*/React.forwardRef(function VisuallyHidden(props, ref) {
  return React__default.createElement("span", Object.assign({
    ref: ref,
    style: {
      border: 0,
      clip: "rect(0 0 0 0)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: 0,
      position: "absolute",
      width: "1px",
      // https://medium.com/@jessebeach/beware-smushed-off-screen-accessible-text-5952a4c2cbfe
      whiteSpace: "nowrap",
      wordWrap: "normal"
    }
  }, props));
});

if (process.env.NODE_ENV !== "production") {
  VisuallyHidden.displayName = "VisuallyHidden";
}

function _objectWithoutPropertiesLoose$5(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/*
 * Singleton state is fine because you don't server render
 * an alert (SRs don't read them on first load anyway)
 */

var keys$1 = {
  polite: -1,
  assertive: -1
};
var elements = {
  polite: {},
  assertive: {}
};
var liveRegions = {
  polite: null,
  assertive: null
};
var renderTimer; ////////////////////////////////////////////////////////////////////////////////

/**
 * Alert
 *
 * Screen-reader-friendly alert messages. In many apps developers add "alert"
 * messages when network events or other things happen. Users with assistive
 * technologies may not know about the message unless you develop for it.
 *
 * @see Docs https://reacttraining.com/reach-ui/alert
 */

var Alert = /*#__PURE__*/React.forwardRef(function Alert(_ref, forwardedRef) {
  var children = _ref.children,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? "polite" : _ref$type,
      props = _objectWithoutPropertiesLoose$5(_ref, ["children", "type"]);

  var ownRef = React.useRef(null);
  var ref = useForkedRef(forwardedRef, ownRef);
  var child = React.useMemo(function () {
    return React__default.createElement("div", Object.assign({}, props, {
      ref: ref,
      "data-reach-alert": true
    }), children);
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [children, props]);
  useMirrorEffects(type, child, ownRef);
  return child;
});

if (process.env.NODE_ENV !== "production") {
  Alert.displayName = "Alert";
  Alert.propTypes = {
    children: _pt__default.node,
    type: /*#__PURE__*/_pt__default.oneOf(["assertive", "polite"])
  };
}

function createMirror(type, doc) {
  var key = ++keys$1[type];

  var mount = function mount(element) {
    if (liveRegions[type]) {
      elements[type][key] = element;
      renderAlerts();
    } else {
      var node = doc.createElement("div");
      node.setAttribute("data-reach-live-" + type, "true");
      liveRegions[type] = node;
      doc.body.appendChild(liveRegions[type]);
      mount(element);
    }
  };

  var update = function update(element) {
    elements[type][key] = element;
    renderAlerts();
  };

  var unmount = function unmount() {
    delete elements[type][key];
    renderAlerts();
  };

  return {
    mount: mount,
    update: update,
    unmount: unmount
  };
}

function renderAlerts() {
  if (renderTimer != null) {
    window.clearTimeout(renderTimer);
  }

  renderTimer = window.setTimeout(function () {
    Object.keys(elements).forEach(function (elementType) {
      var type = elementType;
      var container = liveRegions[type];

      if (container) {
        reactDom.render(React__default.createElement(VisuallyHidden, null, React__default.createElement("div", {
          // The status role is a type of live region and a container whose
          // content is advisory information for the user that is not
          // important enough to justify an alert, and is often presented as
          // a status bar. When the role is added to an element, the browser
          // will send out an accessible status event to assistive
          // technology products which can then notify the user about it.
          // https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_status_role
          role: type === "assertive" ? "alert" : "status",
          "aria-live": type
        }, Object.keys(elements[type]).map(function (key) {
          return React__default.cloneElement(elements[type][key], {
            key: key,
            ref: null
          });
        }))), liveRegions[type]);
      }
    });
  }, 500);
}

function useMirrorEffects(type, element, ref) {
  var prevType = usePrevious(type);
  var mirror = React.useRef(null);
  var mounted = React.useRef(false);
  React.useEffect(function () {
    var ownerDocument = getOwnerDocument(ref.current) || document;

    if (!mounted.current) {
      mounted.current = true;
      mirror.current = createMirror(type, ownerDocument);
      mirror.current.mount(element);
    } else if (prevType !== type) {
      mirror.current && mirror.current.unmount();
      mirror.current = createMirror(type, ownerDocument);
      mirror.current.mount(element);
    } else {
      mirror.current && mirror.current.update(element);
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [element, type, prevType]);
  React.useEffect(function () {
    return function () {
      mirror.current && mirror.current.unmount();
    };
  }, []);
}

var dimensions = {
  siteHeader: {
    height: "3.75rem"
  },
  layout: {
    width: 90
  },
  dropdown: {
    list: {
      width: "250px"
    }
  },
  toast: {
    minHeight: "3rem"
  },
  pageNav: {
    minHeight: "5rem"
  },
  pagePadding: {
    mobile: "1.4rem",
    tablet: "2rem"
  },
  buildList: {
    indentation: "5rem"
  }
};

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n  align-items: center;\n  background: none;\n  border: none;\n  color: ", ";\n  cursor: pointer;\n  display: flex;\n  height: ", ";\n  justify-content: center;\n  width: ", ";\n"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n  align-items: center;\n  color: ", ";\n  display: flex;\n"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n  line-height: 1;\n  margin: 0 ", " 0 ", ";\n"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2$1() {
  var data = _taggedTemplateLiteral(["\n  align-items: center;\n  animation: ", " 0.5s 0.25s ease forwards;\n  background: ", ";\n  border-left: 8px solid ", ";\n  border-radius: ", " ", " 0 0;\n  color: ", ";\n  display: flex;\n  font-size: ", ";\n  min-height: ", ";\n  max-width: calc(100% - (", " * 2));\n  padding-left: ", ";\n  transform: perspective(1000px) rotateX(90deg);\n  transform-origin: bottom center;\n\n  svg {\n    height: auto;\n    width: calc(", " * 0.4);\n  }\n\n  &:not(:first-of-type) {\n    border-radius: ", ";\n    margin-bottom: ", ";\n  }\n"]);

  _templateObject2$1 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject$7() {
  var data = _taggedTemplateLiteral(["\n  100% {\n     transform: perspective(1000px) rotateX(0);\n  }\n"]);

  _templateObject$7 = function _templateObject() {
    return data;
  };

  return data;
}
var toastEntryAnimation = core.keyframes(_templateObject$7());
var toastCss = core.css(_templateObject2$1(), toastEntryAnimation, colors.grey[90], colors.green[50], S[2], S[2], colors.green[5], b[1], dimensions.toast.minHeight, space[7], space[4], dimensions.toast.minHeight, S[2], space[1]);
var messageCss = core.css(_templateObject3(), space[2], space[3]);
var statusCss = core.css(_templateObject4(), colors.green[50]);
var closeButtonCss$1 = core.css(_templateObject5(), colors.grey[40], dimensions.toast.minHeight, dimensions.toast.minHeight);
var toastColorByTone = {
  SUCCESS: colors.green[50],
  DANGER: colors.red[60]
};
var ToastIconByTone = {
  SUCCESS: md.MdDone,
  DANGER: md.MdWarning
};
var Toast = function Toast(_ref) {
  var message = _ref.message,
      tone = _ref.tone,
      closeButtonLabel = _ref.closeButtonLabel,
      onClose = _ref.onClose;
  var IconComponent = ToastIconByTone[tone];
  return core.jsx(Alert, {
    css: [toastCss, core.css({
      borderLeftColor: toastColorByTone[tone]
    })],
    "data-testid": "toast",
    type: tone === "DANGER" ? "assertive" : "polite"
  }, core.jsx("span", {
    css: [statusCss, core.css({
      color: toastColorByTone[tone]
    })]
  }, core.jsx(IconComponent, null)), core.jsx("div", {
    css: messageCss
  }, message), core.jsx("button", {
    css: closeButtonCss$1,
    type: "button",
    onClick: onClose,
    "aria-label": closeButtonLabel
  }, core.jsx(md.MdClose, null)));
};
Toast.propTypes = {
  message: _pt__default.node.isRequired,
  onClose: _pt__default.func.isRequired,
  closeButtonLabel: _pt__default.string.isRequired
};
Toast.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "Toast"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Toast/Toast.tsx"] = {
    name: "Toast",
    docgenInfo: Toast.__docgenInfo,
    path: "src/components/Toast/Toast.tsx"
  };
}

var ToastContext = React__default.createContext({
  showToast: function showToast() {
    return undefined;
  }
});
function useToastContext() {
  var context = React__default.useContext(ToastContext);

  if (!context) {
    throw new Error("Toast hooks cannot be used outside the ToastProvider component");
  }

  return context;
}

function _templateObject$8() {
  var data = _taggedTemplateLiteral(["\n  margin-bottom: 8px;\n"]);

  _templateObject$8 = function _templateObject() {
    return data;
  };

  return data;
}
var messageCss$1 = core.css(_templateObject$8());
var MessageWithLink = function MessageWithLink(_ref) {
  var children = _ref.children,
      linkLabel = _ref.linkLabel,
      linkProps = _objectWithoutProperties(_ref, ["children", "linkLabel"]);

  return core.jsx(React__default.Fragment, null, core.jsx("div", {
    css: messageCss$1
  }, children), core.jsx(Link // we need to cast to "any" because TS claims that "href" is required for <Link /> even though it's not
  , linkProps, linkLabel));
};
MessageWithLink.propTypes = {
  linkLabel: _pt__default.node.isRequired,
  href: _pt__default.string,
  target: _pt__default.string.isRequired,
  to: _pt__default.string
};
MessageWithLink.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "MessageWithLink"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Toast/MessageWithLink.tsx"] = {
    name: "MessageWithLink",
    docgenInfo: MessageWithLink.__docgenInfo,
    path: "src/components/Toast/MessageWithLink.tsx"
  };
}

var DEFAULT_TIMEOUT = 5000;
var DEFAULT_TONE = "SUCCESS";

var useShowToast = function useShowToast() {
  var _useToastContext = useToastContext(),
      showToast = _useToastContext.showToast;

  return showToast;
};
var useShowSuccessToast = function useShowSuccessToast() {
  var showToast = useShowToast();
  return React.useCallback(function (message) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    showToast(message, _objectSpread2({}, options, {
      tone: "SUCCESS"
    }));
  }, [showToast]);
};
var useShowErrorToast = function useShowErrorToast() {
  var showToast = useShowToast();
  return React.useCallback(function (message) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    showToast(message, _objectSpread2({}, options, {
      tone: "DANGER",
      timeout: 0
    }));
  }, [showToast]);
};
var useShowErrorAlert = function useShowErrorAlert() {
  var showToast = useShowErrorToast();
  return React.useCallback(function (message, linkProps) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    showToast( /*#__PURE__*/React__default.createElement(MessageWithLink, linkProps, message), options);
  }, [showToast]);
};
var useToastActions = function useToastActions() {
  var _useState = React.useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      toasts = _useState2[0],
      setToasts = _useState2[1];

  var timeoutsRef = React.useRef(new Map());
  var removeToast = React.useCallback(function (toastId) {
    setToasts(function (prevToasts) {
      return prevToasts.filter(function (_ref) {
        var id = _ref.id;
        return id !== toastId;
      });
    });
    window.clearTimeout(timeoutsRef.current.get(toastId));
    timeoutsRef.current["delete"](toastId);
  }, []);
  var showToast = React.useCallback(function (message) {
    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref2$tone = _ref2.tone,
        tone = _ref2$tone === void 0 ? DEFAULT_TONE : _ref2$tone,
        _ref2$timeout = _ref2.timeout,
        timeout = _ref2$timeout === void 0 ? DEFAULT_TIMEOUT : _ref2$timeout;

    var toastId = Symbol("toast");
    setToasts(function (prevToasts) {
      return [].concat(_toConsumableArray(prevToasts), [{
        id: toastId,
        message: message,
        tone: tone
      }]);
    });

    if (timeout > 0) {
      var timeOutId = window.setTimeout(function () {
        removeToast(toastId);
      }, timeout);
      timeoutsRef.current.set(toastId, timeOutId);
    }
  }, []);
  return {
    toasts: toasts,
    showToast: showToast,
    removeToast: removeToast
  };
};

function _templateObject$9() {
  var data = _taggedTemplateLiteral(["\n  align-items: center;\n  bottom: 0;\n  display: flex;\n  flex-direction: column-reverse;\n  left: 50%;\n  position: fixed;\n  transform: translate(-50%, 0);\n  width: 100%;\n  z-index: ", ";\n"]);

  _templateObject$9 = function _templateObject() {
    return data;
  };

  return data;
}
var ToastConsumer = ToastContext.Consumer;
var containerCss = core.css(_templateObject$9(), zIndices.base);
var ToastProvider = function ToastProvider(_ref) {
  var children = _ref.children,
      _ref$closeButtonLabel = _ref.closeButtonLabel,
      closeButtonLabel = _ref$closeButtonLabel === void 0 ? "Close" : _ref$closeButtonLabel;

  var _useToastActions = useToastActions(),
      toasts = _useToastActions.toasts,
      showToast = _useToastActions.showToast,
      removeToast = _useToastActions.removeToast;

  var contextValue = React__default.useMemo(function () {
    return {
      showToast: showToast
    };
  }, [showToast]);
  return core.jsx(ToastContext.Provider, {
    value: contextValue
  }, children, core.jsx("div", {
    css: containerCss
  }, toasts.map(function (toast, index) {
    return core.jsx(Toast, _extends({
      key: "toast-".concat(index) // this is probably not the best, but we can't use symbol as key :(

    }, toast, {
      onClose: function onClose() {
        return removeToast(toast.id);
      },
      closeButtonLabel: closeButtonLabel || "close"
    }));
  })));
};
ToastProvider.propTypes = {
  closeButtonLabel: _pt__default.string
};
ToastProvider.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "ToastProvider",
  "props": {
    "closeButtonLabel": {
      "defaultValue": {
        "value": "`Close`",
        "computed": false
      },
      "required": false
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Toast/ToastProvider.tsx"] = {
    name: "ToastProvider",
    docgenInfo: ToastProvider.__docgenInfo,
    path: "src/components/Toast/ToastProvider.tsx"
  };
}

function BaseText(props) {
  var children = props.children,
      _props$as = props.as,
      Component = _props$as === void 0 ? "p" : _props$as,
      rest = _objectWithoutProperties(props, ["children", "as"]);

  return /*#__PURE__*/React__default.createElement(Component, rest, children);
}
BaseText.propTypes = {
  as: _pt__default.oneOf(["p", "span"])
};
BaseText.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "BaseText",
  "props": {
    "as": {
      "required": false,
      "tsType": {
        "name": "union",
        "raw": "\"p\" | \"span\"",
        "elements": [{
          "name": "literal",
          "value": "\"p\""
        }, {
          "name": "literal",
          "value": "\"span\""
        }]
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/BaseText/BaseText.tsx"] = {
    name: "BaseText",
    docgenInfo: BaseText.__docgenInfo,
    path: "src/components/BaseText/BaseText.tsx"
  };
}

var baseStyle = function baseStyle(tone) {
  return function (theme) {
    return {
      // TODO figure out a better way to do this
      // https://github.com/gatsby-inc/gatsby-interface/issues/324
      color: tone === "NEUTRAL" ? theme.tones[tone].dark : theme.tones[tone].text,
      fontFamily: theme.fonts.system,
      fontWeight: "normal"
    };
  };
};
var sizeStyles = {
  S: function S(theme) {
    return {
      fontSize: theme.fontSizes[1],
      lineHeight: theme.lineHeights["default"]
    };
  },
  M: function M(theme) {
    return {
      fontSize: theme.fontSizes[2],
      lineHeight: theme.lineHeights["default"]
    };
  },
  L: function L(theme) {
    return {
      fontSize: theme.fontSizes[3],
      lineHeight: theme.lineHeights["default"]
    };
  },
  XL: function XL(theme) {
    return {
      fontSize: theme.fontSizes[4],
      lineHeight: theme.lineHeights["default"]
    };
  },
  "2XL": function XL(theme) {
    return {
      fontSize: theme.fontSizes[5],
      lineHeight: theme.lineHeights["default"]
    };
  }
};
var variantStyles = {
  PRIMARY: function PRIMARY() {
    return {};
  },
  EMPHASIZED: function EMPHASIZED() {
    return {
      fontWeight: "bold"
    };
  },
  LEDE: function LEDE(theme) {
    return [sizeStyles["L"](theme), {
      margin: "".concat(theme.space[3], " 0 0")
    }];
  },
  EMPHASIZED_LEDE: function EMPHASIZED_LEDE(theme) {
    return [sizeStyles["2XL"](theme), {
      fontFamily: theme.fonts.heading,
      lineHeight: theme.lineHeights.dense,
      margin: "".concat(theme.space[5], " 0 0")
    }];
  },
  ERROR: function ERROR() {
    return {};
  }
};

function Text(_ref) {
  var _ref$tone = _ref.tone,
      tone = _ref$tone === void 0 ? "NEUTRAL" : _ref$tone,
      _ref$variant = _ref.variant,
      variant = _ref$variant === void 0 ? "PRIMARY" : _ref$variant,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? "M" : _ref$size,
      rest = _objectWithoutProperties(_ref, ["tone", "variant", "size"]);

  return core.jsx(BaseText, _extends({
    css: function css(theme) {
      return [baseStyle(tone)(theme), sizeStyles[size](theme), variantStyles[variant](theme)];
    }
  }, rest));
}

Text.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "Text",
  "props": {
    "tone": {
      "defaultValue": {
        "value": "`NEUTRAL`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "TextTone"
      },
      "description": ""
    },
    "variant": {
      "defaultValue": {
        "value": "`PRIMARY`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "TextVariant"
      },
      "description": ""
    },
    "size": {
      "defaultValue": {
        "value": "`M`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "TextSize"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Text/Text.tsx"] = {
    name: "Text",
    docgenInfo: Text.__docgenInfo,
    path: "src/components/Text/Text.tsx"
  };
}

function ToggleGutter(props) {
  return core.jsx("span", _extends({}, props, {
    "aria-hidden": true,
    css: function css(theme) {
      return [{
        background: theme.colors.grey[30],
        borderRadius: theme.radii[5],
        cursor: "pointer",
        display: "inline-block",
        height: "24px",
        padding: "3px",
        transition: "all .3s ease, background .5s",
        userSelect: "none",
        width: "48px",
        ":after": {
          background: theme.colors.white,
          position: "relative",
          display: "block",
          content: "\"\"",
          width: "18px",
          height: "18px",
          borderRadius: theme.radii[5],
          transition: "all 0.1s ease",
          left: 0
        },
        ":active": {
          ":after": {
            width: "24px"
          }
        }
      }];
    }
  }));
}
var ToggleGutterTagName = "span";
var toggleGutterFocusCss = function toggleGutterFocusCss(theme) {
  return {
    boxShadow: "0 0 0 3px ".concat(theme.colors.blue[30]),
    outline: "0"
  };
};
var toggleGutterCheckedCss = function toggleGutterCheckedCss() {
  var tone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "BRAND";
  return function (theme) {
    return {
      background: theme.tones[tone].medium,
      ":after": {
        left: "calc(100% - 18px)"
      },
      ":active": {
        ":after": {
          left: "calc(100% - 24px)"
        }
      }
    };
  };
};
ToggleGutter.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "ToggleGutter"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Toggle/ToggleGutter.tsx"] = {
    name: "ToggleGutter",
    docgenInfo: ToggleGutter.__docgenInfo,
    path: "src/components/Toggle/ToggleGutter.tsx"
  };
}

var toggleLabelCss = function toggleLabelCss(theme) {
  return {
    alignItems: "center",
    display: "flex",
    color: theme.colors.grey[90],
    cursor: "pointer",
    fontFamily: theme.fonts.system
  };
};

var BaseToggle = React__default.forwardRef(function BaseToggle(_ref, ref) {
  var tone = _ref.tone,
      className = _ref.className,
      style = _ref.style,
      rest = _objectWithoutProperties(_ref, ["tone", "className", "style"]);

  return core.jsx(React__default.Fragment, null, core.jsx("input", _extends({
    ref: ref,
    type: "checkbox",
    value: "true",
    css: function css(theme) {
      var _ref2;

      return [visuallyHiddenCss, (_ref2 = {}, _defineProperty(_ref2, "&:checked + ".concat(ToggleGutterTagName), toggleGutterCheckedCss(tone)(theme)), _defineProperty(_ref2, "&:focus + ".concat(ToggleGutterTagName), toggleGutterFocusCss(theme)), _ref2)];
    }
  }, rest)), core.jsx(ToggleGutter, {
    className: className,
    style: style
  }));
});
var ToggleCheckbox = React__default.forwardRef(function ToggleCheckbox(_ref3, ref) {
  var id = _ref3.id,
      label = _ref3.label,
      _ref3$labelPosition = _ref3.labelPosition,
      labelPosition = _ref3$labelPosition === void 0 ? "end" : _ref3$labelPosition,
      className = _ref3.className,
      style = _ref3.style,
      rest = _objectWithoutProperties(_ref3, ["id", "label", "labelPosition", "className", "style"]);

  return core.jsx("label", {
    className: className,
    style: style,
    htmlFor: id,
    css: function css(theme) {
      return [{
        display: "flex",
        alignItems: "center"
      }, toggleLabelCss(theme)];
    }
  }, core.jsx(BaseToggle, _extends({
    ref: ref,
    id: id
  }, rest, {
    css: function css(theme) {
      return labelPosition === "end" ? {
        marginRight: theme.space[3]
      } : {
        marginLeft: theme.space[3],
        order: 1
      };
    }
  })), label);
});

function ToggleSwitch(_ref) {
  var id = _ref.id,
      valueOn = _ref.valueOn,
      valueOff = _ref.valueOff,
      labelOn = _ref.labelOn,
      labelOff = _ref.labelOff,
      _ref$value = _ref.value,
      value = _ref$value === void 0 ? valueOff : _ref$value,
      tone = _ref.tone,
      className = _ref.className,
      style = _ref.style,
      rest = _objectWithoutProperties(_ref, ["id", "valueOn", "valueOff", "labelOn", "labelOff", "value", "tone", "className", "style"]);

  var inputOnRef = React__default.useRef(null);
  var inputOffRef = React__default.useRef(null);
  var optionOnId = "".concat(id, "__on");
  var optionOffId = "".concat(id, "__off");
  var isOn = value === valueOn;

  var toggle = function toggle() {
    var inputOn = inputOnRef.current;
    var inputOff = inputOffRef.current;

    if (!inputOn || !inputOff) {
      return;
    }

    if (isOn) {
      inputOff.focus();
      inputOff.click();
    } else {
      inputOn.focus();
      inputOn.click();
    }
  };

  return core.jsx("div", {
    id: id,
    className: className,
    style: style,
    css: function css(theme) {
      return [_defineProperty({
        display: "flex",
        alignItems: "center"
      }, "&:focus-within > ".concat(ToggleGutterTagName), toggleGutterFocusCss(theme)), toggleLabelCss(theme)];
    },
    onClick: function onClick(e) {
      if (!inputOnRef.current || !inputOffRef.current) {
        return;
      }

      var target = e.target;

      if (target.tagName === "LABEL") {
        var inputOn = inputOnRef.current;
        var inputOff = inputOffRef.current;
        var labelFor = target.htmlFor;

        if (labelFor === optionOnId && isOn) {
          e.preventDefault();
          inputOff.focus();
          inputOff.click();
        }

        if (labelFor === optionOffId && !isOn) {
          e.preventDefault();
          inputOn.focus();
          inputOn.click();
        }
      } else if (target.tagName === ToggleGutterTagName.toUpperCase()) {
        toggle();
      }
    },
    onKeyPress: function onKeyPress(e) {
      if (e.key !== " ") {
        return;
      }

      toggle();
    }
  }, core.jsx("input", _extends({
    type: "radio",
    id: optionOffId,
    name: id,
    value: valueOff,
    checked: !isOn,
    css: visuallyHiddenCss,
    ref: inputOffRef
  }, rest)), core.jsx("label", {
    htmlFor: optionOffId
  }, labelOff), core.jsx(ToggleGutter, {
    css: function css(theme) {
      return [{
        marginLeft: theme.space[3],
        marginRight: theme.space[3]
      }, isOn && toggleGutterCheckedCss(tone)(theme)];
    }
  }), core.jsx("input", _extends({
    type: "radio",
    id: optionOnId,
    name: id,
    value: valueOn,
    checked: isOn,
    css: visuallyHiddenCss,
    ref: inputOnRef
  }, rest)), core.jsx("label", {
    htmlFor: optionOnId
  }, labelOn));
}
ToggleSwitch.propTypes = {
  id: _pt__default.string.isRequired,
  value: _pt__default.string.isRequired,
  valueOn: _pt__default.string.isRequired,
  valueOff: _pt__default.string.isRequired,
  labelOn: _pt__default.node.isRequired,
  labelOff: _pt__default.node.isRequired,
  className: _pt__default.string
};
ToggleSwitch.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "ToggleSwitch",
  "props": {
    "value": {
      "defaultValue": {
        "value": "valueOff",
        "computed": true
      },
      "required": false,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "id": {
      "required": true,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "valueOn": {
      "required": true,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "valueOff": {
      "required": true,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "labelOn": {
      "required": true,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    },
    "labelOff": {
      "required": true,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    },
    "tone": {
      "required": false,
      "tsType": {
        "name": "AtomTone"
      },
      "description": ""
    },
    "className": {
      "required": false,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "style": {
      "required": false,
      "tsType": {
        "name": "ReactCSSProperties",
        "raw": "React.CSSProperties"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Toggle/ToggleSwitch.tsx"] = {
    name: "ToggleSwitch",
    docgenInfo: ToggleSwitch.__docgenInfo,
    path: "src/components/Toggle/ToggleSwitch.tsx"
  };
}

function Breadcrumb(_ref) {
  var children = _ref.children,
      rest = _objectWithoutProperties(_ref, ["children"]);

  return core.jsx("nav", _extends({
    "aria-label": "breadcrumb"
  }, rest), core.jsx("ol", {
    css: {
      listStyle: "none",
      margin: 0,
      padding: 0,
      display: "flex",
      flexWrap: "wrap"
    }
  }, children));
}
Breadcrumb.Item = BreadcrumbItem;

var breadcrumbItemCss = function breadcrumbItemCss(theme) {
  return {
    display: "flex",
    alignItems: "center",
    color: theme.colors.purple[50],
    fontFamily: theme.fonts.heading,
    fontSize: theme.fontSizes[3]
  };
};

function BreadcrumbItem(_ref2) {
  var to = _ref2.to,
      active = _ref2.active,
      onClick = _ref2.onClick,
      children = _ref2.children,
      rest = _objectWithoutProperties(_ref2, ["to", "active", "onClick", "children"]);

  return core.jsx("li", _extends({
    css: function css(theme) {
      return [breadcrumbItemCss(theme), active && {
        color: theme.colors.grey[90]
      }];
    }
  }, rest), to ? core.jsx(React.Fragment, null, core.jsx(gatsby.Link, {
    to: to,
    onClick: onClick,
    css: {
      textDecoration: "none",
      color: "inherit"
    }
  }, children), core.jsx(BreadcrumbArrow, null)) : children);
}

BreadcrumbItem.propTypes = {
  to: _pt__default.string,
  active: _pt__default.bool,
  onClick: _pt__default.func
};
BreadcrumbItem.displayName = "Breadcrumb.Item";

var breadcrumbArrowCss = function breadcrumbArrowCss(theme) {
  return {
    color: theme.colors.grey[60],
    marginRight: theme.space[4],
    marginLeft: theme.space[4],
    verticalAlign: "middle"
  };
};

function BreadcrumbArrow(props) {
  return core.jsx("svg", _extends({
    width: "6",
    height: "9",
    viewBox: "0 0 6 9",
    fill: "currentColor",
    css: breadcrumbArrowCss
  }, props), core.jsx("path", {
    d: "M6 4.5L1.5 8.39711L1.5 0.602886L6 4.5Z"
  }));
}

Breadcrumb.__docgenInfo = {
  "description": "",
  "methods": [{
    "name": "Item",
    "docblock": null,
    "modifiers": ["static"],
    "params": [{
      "name": "{\n  to,\n  active,\n  onClick,\n  children,\n  ...rest\n}: BreadcrumbItemProps",
      "type": {
        "name": "intersection",
        "raw": "PropsOf<\"li\"> & {\n  to?: string\n  active?: boolean\n  onClick?: React.MouseEventHandler<HTMLAnchorElement>\n}",
        "elements": [{
          "name": "PropsOf",
          "elements": [{
            "name": "literal",
            "value": "\"li\""
          }],
          "raw": "PropsOf<\"li\">"
        }, {
          "name": "signature",
          "type": "object",
          "raw": "{\n  to?: string\n  active?: boolean\n  onClick?: React.MouseEventHandler<HTMLAnchorElement>\n}",
          "signature": {
            "properties": [{
              "key": "to",
              "value": {
                "name": "string",
                "required": false
              }
            }, {
              "key": "active",
              "value": {
                "name": "boolean",
                "required": false
              }
            }, {
              "key": "onClick",
              "value": {
                "name": "ReactMouseEventHandler",
                "raw": "React.MouseEventHandler<HTMLAnchorElement>",
                "elements": [{
                  "name": "HTMLAnchorElement"
                }],
                "required": false
              }
            }]
          }
        }],
        "alias": "BreadcrumbItemProps"
      }
    }],
    "returns": null
  }],
  "displayName": "Breadcrumb"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Breadcrumb/Breadcrumb.tsx"] = {
    name: "Breadcrumb",
    docgenInfo: Breadcrumb.__docgenInfo,
    path: "src/components/Breadcrumb/Breadcrumb.tsx"
  };
}

/*
 * Welcome to @reach/auto-id!

 * Let's see if we can make sense of why this hook exists and its
 * implementation.
 *
 * Some background:
 *   1. Accessibiliy APIs rely heavily on element IDs
 *   2. Requiring developers to put IDs on every element in Reach UI is both
 *      cumbersome and error-prone
 *   3. With a component model, we can generate IDs for them!
 *
 * Solution 1: Generate random IDs.
 *
 * This works great as long as you don't server render your app. When React (in
 * the client) tries to reuse the markup from the server, the IDs won't match
 * and React will then recreate the entire DOM tree.
 *
 * Solution 2: Increment an integer
 *
 * This sounds great. Since we're rendering the exact same tree on the server
 * and client, we can increment a counter and get a deterministic result between
 * client and server. Also, JS integers can go up to nine-quadrillion. I'm
 * pretty sure the tab will be closed before an app never needs
 * 10 quadrillion IDs!
 *
 * Problem solved, right?
 *
 * Ah, but there's a catch! React's concurrent rendering makes this approach
 * non-deterministic. While the client and server will end up with the same
 * elements in the end, depending on suspense boundaries (and possibly some user
 * input during the initial render) the incrementing integers won't always match
 * up.
 *
 * Solution 3: Don't use IDs at all on the server; patch after first render.
 *
 * What we've done here is solution 2 with some tricks. With this approach, the
 * ID returned is an empty string on the first render. This way the server and
 * client have the same markup no matter how wild the concurrent rendering may
 * have gotten.
 *
 * After the render, we patch up the components with an incremented ID. This
 * causes a double render on any components with `useId`. Shouldn't be a problem
 * since the components using this hook should be small, and we're only updating
 * the ID attribute on the DOM, nothing big is happening.
 *
 * It doesn't have to be an incremented number, though--we could do generate
 * random strings instead, but incrementing a number is probably the cheapest
 * thing we can do.
 *
 * Additionally, we only do this patchup on the very first client render ever.
 * Any calls to `useId` that happen dynamically in the client will be
 * populated immediately with a value. So, we only get the double render after
 * server hydration and never again, SO BACK OFF ALRIGHT?
 */
var serverHandoffComplete = false;
var id = 0;

var genId = function genId() {
  return ++id;
};
/**
 * useId
 *
 * Autogenerate IDs to facilitate WAI-ARIA and server rendering.
 *
 * Note: The returned ID will initially be `null` and will update after a
 * component mounts. Users may need to supply their own ID if they need
 * consistent values for SSR.
 *
 * @see Docs https://reacttraining.com/reach-ui/auto-id
 */


var useId = function useId(idFromProps) {
  /*
   * If this instance isn't part of the initial render, we don't have to do the
   * double render/patch-up dance. We can just generate the ID and return it.
   */
  var initialId = idFromProps || (serverHandoffComplete ? genId() : null);

  var _useState = React.useState(initialId),
      id = _useState[0],
      setId = _useState[1];

  useIsomorphicLayoutEffect(function () {
    if (id === null) {
      /*
       * Patch the ID after render. We do this in `useLayoutEffect` to avoid any
       * rendering flicker, though it'll make the first render slower (unlikely
       * to matter, but you're welcome to measure your app and let us know if
       * it's a problem).
       */
      setId(genId());
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, []);
  React.useEffect(function () {
    if (serverHandoffComplete === false) {
      /*
       * Flag all future uses of `useId` to skip the update dance. This is in
       * `useEffect` because it goes after `useLayoutEffect`, ensuring we don't
       * accidentally bail out of the patch-up dance prematurely.
       */
      serverHandoffComplete = true;
    }
  }, []);
  return id != null ? String(id) : undefined;
};

var props = ['bottom', 'height', 'left', 'right', 'top', 'width'];

var rectChanged = function rectChanged(a, b) {
  if (a === void 0) {
    a = {};
  }

  if (b === void 0) {
    b = {};
  }

  return props.some(function (prop) {
    return a[prop] !== b[prop];
  });
};

var observedNodes =
/*#__PURE__*/
new Map();
var rafId;

var run = function run() {
  var changedStates = [];
  observedNodes.forEach(function (state, node) {
    var newRect = node.getBoundingClientRect();

    if (rectChanged(newRect, state.rect)) {
      state.rect = newRect;
      changedStates.push(state);
    }
  });
  changedStates.forEach(function (state) {
    state.callbacks.forEach(function (cb) {
      return cb(state.rect);
    });
  });
  rafId = window.requestAnimationFrame(run);
};

function observeRect(node, cb) {
  return {
    observe: function observe() {
      var wasEmpty = observedNodes.size === 0;

      if (observedNodes.has(node)) {
        observedNodes.get(node).callbacks.push(cb);
      } else {
        observedNodes.set(node, {
          rect: undefined,
          hasRectChanged: false,
          callbacks: [cb]
        });
      }

      if (wasEmpty) run();
    },
    unobserve: function unobserve() {
      var state = observedNodes.get(node);

      if (state) {
        // Remove the callback
        var index = state.callbacks.indexOf(cb);
        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference

        if (!state.callbacks.length) observedNodes["delete"](node); // Stop the loop

        if (!observedNodes.size) cancelAnimationFrame(rafId);
      }
    }
  };
}

/**
 * Welcome to @reach/rect!
 *
 * Measures DOM elements (aka. bounding client rect).
 *
 * @see getBoundingClientRect https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
 * @see Docs                  https://reacttraining.com/reach-ui/rect
 * @see Source                https://github.com/reach/reach-ui/tree/master/packages/rect
 */

/**
 * Rect
 *
 * @param props
 */

var Rect = function Rect(_ref) {
  var onChange = _ref.onChange,
      _ref$observe = _ref.observe,
      observe = _ref$observe === void 0 ? true : _ref$observe,
      children = _ref.children;
  var ref = React.useRef(null);
  var rect = useRect(ref, observe, onChange);
  return children({
    ref: ref,
    rect: rect
  });
};

if (process.env.NODE_ENV !== "production") {
  Rect.displayName = "Rect";
  Rect.propTypes = {
    children: _pt__default.func.isRequired,
    observe: _pt__default.bool,
    onChange: _pt__default.func
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * useRect
 *
 * @param nodeRef
 * @param observe
 * @param onChange
 */


function useRect(nodeRef, observe, onChange) {
  if (observe === void 0) {
    observe = true;
  }

  var initialRectSet = React.useRef(false);

  var _useState = React.useState(null),
      rect = _useState[0],
      setRect = _useState[1];

  var observerRef = React.useRef(null);
  useIsomorphicLayoutEffect(function () {
    var cleanup = function cleanup() {
      observerRef.current && observerRef.current.unobserve();
    };

    if (!nodeRef.current) {
      console.warn("You need to place the ref");
      return cleanup;
    }

    if (!observerRef.current) {
      observerRef.current = observeRect(nodeRef.current, function (rect) {
        onChange && onChange(rect);
        setRect(rect);
      });
    }

    if (!initialRectSet.current) {
      initialRectSet.current = true;
      setRect(nodeRef.current.getBoundingClientRect());
    }

    observe && observerRef.current.observe();
    return cleanup; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [observe, onChange]);
  return rect;
}

function _extends$4() {
  _extends$4 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$4.apply(this, arguments);
}

function _objectWithoutPropertiesLoose$6(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var _on, _on2, _on3, _on4, _on5, _states;
var MOUSE_REST_TIMEOUT = 100;
var LEAVE_TIMEOUT = 500; ////////////////////////////////////////////////////////////////////////////////
// States
// Nothing goin' on

var IDLE = "IDLE"; // We're considering showing the tooltip, but we're gonna wait a sec

var FOCUSED = "FOCUSED"; // It's on!

var VISIBLE = "VISIBLE"; // Focus has left, but we want to keep it visible for a sec

var LEAVING_VISIBLE = "LEAVING_VISIBLE"; // The user clicked the tool, so we want to hide the thing, we can't just use
// IDLE because we need to ignore mousemove, etc.

var DISMISSED = "DISMISSED"; ////////////////////////////////////////////////////////////////////////////////
// Events

var BLUR = "BLUR";
var FOCUS = "FOCUS";
var GLOBAL_MOUSE_MOVE = "GLOBAL_MOUSE_MOVE";
var MOUSE_DOWN = "MOUSE_DOWN";
var MOUSE_ENTER = "MOUSE_ENTER";
var MOUSE_LEAVE = "MOUSE_LEAVE";
var MOUSE_MOVE = "MOUSE_MOVE";
var REST = "REST";
var SELECT_WITH_KEYBOARD = "SELECT_WITH_KEYBOARD";
var TIME_COMPLETE = "TIME_COMPLETE";
var chart = {
  initial: IDLE,
  states: (_states = {}, _states[IDLE] = {
    enter: clearContextId,
    on: (_on = {}, _on[MOUSE_ENTER] = FOCUSED, _on[FOCUS] = VISIBLE, _on)
  }, _states[FOCUSED] = {
    enter: startRestTimer,
    leave: clearRestTimer,
    on: (_on2 = {}, _on2[MOUSE_MOVE] = FOCUSED, _on2[MOUSE_LEAVE] = IDLE, _on2[MOUSE_DOWN] = DISMISSED, _on2[BLUR] = IDLE, _on2[REST] = VISIBLE, _on2)
  }, _states[VISIBLE] = {
    on: (_on3 = {}, _on3[FOCUS] = FOCUSED, _on3[MOUSE_ENTER] = FOCUSED, _on3[MOUSE_LEAVE] = LEAVING_VISIBLE, _on3[BLUR] = LEAVING_VISIBLE, _on3[MOUSE_DOWN] = DISMISSED, _on3[SELECT_WITH_KEYBOARD] = DISMISSED, _on3[GLOBAL_MOUSE_MOVE] = LEAVING_VISIBLE, _on3)
  }, _states[LEAVING_VISIBLE] = {
    enter: startLeavingVisibleTimer,
    leave: function leave() {
      clearLeavingVisibleTimer();
      clearContextId();
    },
    on: (_on4 = {}, _on4[MOUSE_ENTER] = VISIBLE, _on4[FOCUS] = VISIBLE, _on4[TIME_COMPLETE] = IDLE, _on4)
  }, _states[DISMISSED] = {
    leave: function leave() {
      // allows us to come on back later w/o entering something else first
      context.id = null;
    },
    on: (_on5 = {}, _on5[MOUSE_LEAVE] = IDLE, _on5[BLUR] = IDLE, _on5)
  }, _states)
};
/*
 * Chart context allows us to persist some data around, in Tooltip all we use
 * is the id of the current tooltip being interacted with.
 */

var context = {
  id: null
};
var state = chart.initial; ////////////////////////////////////////////////////////////////////////////////
// Subscriptions:
//
// We could require apps to render a <TooltipProvider> around the app and use
// React context to notify Tooltips of changes to our state machine, instead
// we manage subscriptions ourselves and simplify the Tooltip API.
//
// Maybe if default context could take a hook (instead of just a static value)
// that was rendered at the root for us, that'd be cool! But it doesn't.

var subscriptions = [];

function subscribe(fn) {
  subscriptions.push(fn);
  return function () {
    subscriptions.splice(subscriptions.indexOf(fn), 1);
  };
}

function notify() {
  subscriptions.forEach(function (fn) {
    return fn(state, context);
  });
} ////////////////////////////////////////////////////////////////////////////////
// Timeouts:
// Manages when the user "rests" on an element. Keeps the interface from being
// flashing tooltips all the time as the user moves the mouse around the screen.


var restTimeout;

function startRestTimer() {
  window.clearTimeout(restTimeout);
  restTimeout = window.setTimeout(function () {
    return transition(REST);
  }, MOUSE_REST_TIMEOUT);
}

function clearRestTimer() {
  window.clearTimeout(restTimeout);
} // Manages the delay to hide the tooltip after rest leaves.


var leavingVisibleTimer;

function startLeavingVisibleTimer() {
  window.clearTimeout(leavingVisibleTimer);
  leavingVisibleTimer = window.setTimeout(function () {
    return transition(TIME_COMPLETE);
  }, LEAVE_TIMEOUT);
}

function clearLeavingVisibleTimer() {
  window.clearTimeout(leavingVisibleTimer);
} // allows us to come on back later w/o entering something else first after the
// user leaves or dismisses


function clearContextId() {
  context.id = null;
} ////////////////////////////////////////////////////////////////////////////////

/**
 * useTooltip
 *
 * @param params
 */


function useTooltip(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      idProp = _ref.id,
      onMouseEnter = _ref.onMouseEnter,
      onMouseMove = _ref.onMouseMove,
      onMouseLeave = _ref.onMouseLeave,
      onFocus = _ref.onFocus,
      onBlur = _ref.onBlur,
      onKeyDown = _ref.onKeyDown,
      onMouseDown = _ref.onMouseDown,
      forwardedRef = _ref.ref,
      DEBUG_STYLE = _ref.DEBUG_STYLE;

  var id = String(useId(idProp));

  var _useState = React.useState(DEBUG_STYLE ? true : id === null ? false : context.id === id && state === VISIBLE),
      isVisible = _useState[0],
      setIsVisible = _useState[1]; // hopefully they always pass a ref if they ever pass one


  var ownRef = React.useRef(null);
  var ref = useForkedRef(forwardedRef, ownRef); // TODO: Fix in utils

  var triggerRect = useRect(ownRef, isVisible);
  React.useEffect(function () {
    return subscribe(function () {
      if (context.id === id && (state === VISIBLE || state === LEAVING_VISIBLE)) {
        setIsVisible(true);
      } else {
        setIsVisible(false);
      }
    });
  }, [id]);
  React.useEffect(function () {
    return checkStyles("tooltip");
  }, []);
  React.useEffect(function () {
    var ownerDocument = getOwnerDocument(ownRef.current) || document;

    function listener(event) {
      if ((event.key === "Escape" || event.key === "Esc") && state === VISIBLE) {
        transition(SELECT_WITH_KEYBOARD);
      }
    }

    ownerDocument.addEventListener("keydown", listener);
    return function () {
      return ownerDocument.removeEventListener("keydown", listener);
    };
  }, []);

  function handleMouseEnter() {
    transition(MOUSE_ENTER, {
      id: id
    });
  }

  function handleMouseMove() {
    transition(MOUSE_MOVE, {
      id: id
    });
  }

  function handleFocus() {
    // @ts-ignore
    if (window.__REACH_DISABLE_TOOLTIPS) {
      return;
    }

    transition(FOCUS, {
      id: id
    });
  }

  function handleMouseLeave() {
    transition(MOUSE_LEAVE);
  }

  function handleBlur() {
    // Allow quick click from one tool to another
    if (context.id !== id) return;
    transition(BLUR);
  }

  function handleMouseDown() {
    // Allow quick click from one tool to another
    if (context.id !== id) return;
    transition(MOUSE_DOWN);
  }

  function handleKeyDown(event) {
    if (event.key === "Enter" || event.key === " ") {
      transition(SELECT_WITH_KEYBOARD);
    }
  }

  var trigger = {
    // The element that triggers the tooltip references the tooltip element with
    // `aria-describedby`.
    // https://www.w3.org/TR/wai-aria-practices-1.2/#tooltip
    "aria-describedby": isVisible ? makeId("tooltip", id) : undefined,
    "data-reach-tooltip-trigger": "",
    ref: ref,
    onMouseEnter: wrapEvent(onMouseEnter, handleMouseEnter),
    onMouseMove: wrapEvent(onMouseMove, handleMouseMove),
    onFocus: wrapEvent(onFocus, handleFocus),
    onBlur: wrapEvent(onBlur, handleBlur),
    onMouseLeave: wrapEvent(onMouseLeave, handleMouseLeave),
    onKeyDown: wrapEvent(onKeyDown, handleKeyDown),
    onMouseDown: wrapEvent(onMouseDown, handleMouseDown)
  };
  var tooltip = {
    id: id,
    triggerRect: triggerRect,
    isVisible: isVisible
  };
  return [trigger, tooltip, isVisible];
} ////////////////////////////////////////////////////////////////////////////////

/**
 * Tooltip
 *
 * @see Docs https://reacttraining.com/reach-ui/tooltip#tooltip
 */

var Tooltip = /*#__PURE__*/forwardRefWithAs(function (_ref2, forwardedRef) {
  var children = _ref2.children,
      label = _ref2.label,
      DEPRECATED_ariaLabel = _ref2.ariaLabel,
      id = _ref2.id,
      DEBUG_STYLE = _ref2.DEBUG_STYLE,
      props = _objectWithoutPropertiesLoose$6(_ref2, ["children", "label", "ariaLabel", "id", "DEBUG_STYLE"]);

  var child = React.Children.only(children);
  process.env.NODE_ENV !== "production" ? warning_1(!DEPRECATED_ariaLabel, "The `ariaLabel prop is deprecated and will be removed from @reach/tooltip in a future version. Please use `aria-label` instead.") : void 0; // We need to pass some properties from the child into useTooltip
  // to make sure users can maintain control over the trigger's ref and events

  var _useTooltip = useTooltip({
    id: id,
    onMouseEnter: child.props.onMouseEnter,
    onMouseMove: child.props.onMouseMove,
    onMouseLeave: child.props.onMouseLeave,
    onFocus: child.props.onFocus,
    onBlur: child.props.onBlur,
    onKeyDown: child.props.onKeyDown,
    onMouseDown: child.props.onMouseDown,
    ref: child.ref,
    DEBUG_STYLE: DEBUG_STYLE
  }),
      trigger = _useTooltip[0],
      tooltip = _useTooltip[1];

  return React__default.createElement(React.Fragment, null, React.cloneElement(child, trigger), React__default.createElement(TooltipPopup, Object.assign({
    ref: forwardedRef,
    label: label,
    "aria-label": DEPRECATED_ariaLabel
  }, tooltip, props)));
});

if (process.env.NODE_ENV !== "production") {
  Tooltip.displayName = "Tooltip";
  Tooltip.propTypes = {
    children: _pt__default.node.isRequired,
    label: _pt__default.node.isRequired,
    ariaLabel: _pt__default.string
  };
}

/**
 * TooltipPopup
 *
 * @see Docs https://reacttraining.com/reach-ui/tooltip#tooltippopup
 */

var TooltipPopup = /*#__PURE__*/forwardRefWithAs(function TooltipPopup(_ref3, forwardRef) {
  var label = _ref3.label,
      DEPRECATED_ariaLabel = _ref3.ariaLabel,
      isVisible = _ref3.isVisible,
      id = _ref3.id,
      props = _objectWithoutPropertiesLoose$6(_ref3, ["label", "ariaLabel", "isVisible", "id"]);

  return isVisible ? React__default.createElement(Portal, null, React__default.createElement(TooltipContent, Object.assign({
    ref: forwardRef,
    label: label,
    "aria-label": DEPRECATED_ariaLabel,
    isVisible: isVisible
  }, props, {
    id: makeId("tooltip", String(id))
  }))) : null;
});

if (process.env.NODE_ENV !== "production") {
  TooltipPopup.displayName = "TooltipPopup";
  TooltipPopup.propTypes = {
    label: _pt__default.node.isRequired,
    ariaLabel: _pt__default.string,
    position: _pt__default.func
  };
}
/**
 * TooltipContent
 *
 * We need a separate component so that useRect works inside the portal.
 *
 * @see Docs https://reacttraining.com/reach-ui/tooltip#tooltipcontent
 */


var TooltipContent = /*#__PURE__*/forwardRefWithAs(function TooltipContent(_ref4, forwardedRef) {
  var ariaLabel = _ref4.ariaLabel,
      realAriaLabel = _ref4["aria-label"],
      _ref4$as = _ref4.as,
      Comp = _ref4$as === void 0 ? "div" : _ref4$as,
      id = _ref4.id,
      isVisible = _ref4.isVisible,
      label = _ref4.label,
      _ref4$position = _ref4.position,
      position = _ref4$position === void 0 ? positionDefault : _ref4$position,
      style = _ref4.style,
      triggerRect = _ref4.triggerRect,
      props = _objectWithoutPropertiesLoose$6(_ref4, ["ariaLabel", "aria-label", "as", "id", "isVisible", "label", "position", "style", "triggerRect"]);

  // The element that serves as the tooltip container has role tooltip.
  // https://www.w3.org/TR/wai-aria-practices-1.2/#tooltip
  // When an app passes an `aria-label`, we actually want to implement
  // `role="tooltip"` on a visually hidden element inside of the trigger.
  // In these cases we want the screen reader user to know both the content in
  // the tooltip, but also the content in the badge. For screen reader users,
  // the only content announced to them is whatever is in the tooltip.
  var hasAriaLabel = (realAriaLabel || ariaLabel) != null;
  var ownRef = React.useRef(null);
  var ref = useForkedRef(forwardedRef, ownRef);
  var tooltipRect = useRect(ownRef, isVisible);
  return React__default.createElement(React.Fragment, null, React__default.createElement(Comp, Object.assign({
    role: hasAriaLabel ? undefined : "tooltip"
  }, props, {
    ref: ref,
    "data-reach-tooltip": "",
    id: hasAriaLabel ? undefined : id,
    style: _extends$4(_extends$4({}, style), getStyles$1(position, triggerRect, tooltipRect))
  }), label), hasAriaLabel && React__default.createElement(VisuallyHidden, {
    role: "tooltip",
    id: id
  }, realAriaLabel || ariaLabel));
});

if (process.env.NODE_ENV !== "production") {
  TooltipContent.displayName = "TooltipContent";
  TooltipContent.propTypes = {};
} ////////////////////////////////////////////////////////////////////////////////
// feels awkward when it's perfectly aligned w/ the trigger


var OFFSET = 8;

function getStyles$1(position, triggerRect, tooltipRect) {
  var haventMeasuredTooltipYet = !tooltipRect;

  if (haventMeasuredTooltipYet) {
    return {
      visibility: "hidden"
    };
  }

  return position(triggerRect, tooltipRect);
}

var positionDefault = function positionDefault(triggerRect, tooltipRect) {
  var _getDocumentDimension = getDocumentDimensions(),
      windowWidth = _getDocumentDimension.width,
      windowHeight = _getDocumentDimension.height;

  if (!triggerRect || !tooltipRect) {
    return {};
  }

  var collisions = {
    top: triggerRect.top - tooltipRect.height < 0,
    right: windowWidth < triggerRect.left + tooltipRect.width,
    bottom: windowHeight < triggerRect.bottom + tooltipRect.height + OFFSET,
    left: triggerRect.left - tooltipRect.width < 0
  };
  var directionRight = collisions.right && !collisions.left;
  var directionUp = collisions.bottom && !collisions.top;
  return {
    left: directionRight ? triggerRect.right - tooltipRect.width + window.pageXOffset + "px" : triggerRect.left + window.pageXOffset + "px",
    top: directionUp ? triggerRect.top - OFFSET - tooltipRect.height + window.pageYOffset + "px" : triggerRect.top + OFFSET + triggerRect.height + window.pageYOffset + "px"
  };
}; ////////////////////////////////////////////////////////////////////////////////

/**
 * Finds the next state from the current state + action. If the chart doesn't
 * describe that transition, it will throw.
 *
 * It also manages lifecycles of the machine, (enter/leave hooks on the state
 * chart)
 *
 * @param event
 * @param payload
 */


var transition = function transition(event, payload) {
  var stateDef = chart.states[state];
  var nextState = stateDef && stateDef.on && stateDef.on[event]; // Really useful for debugging
  // console.log({ event, state, nextState, contextId: context.id });
  // !nextState && console.log('no transition taken')

  if (!nextState) {
    return;
  }

  if (stateDef && stateDef.leave) {
    stateDef.leave();
  }

  if (payload) {
    context = payload;
  }

  var nextDef = chart.states[nextState];

  if (nextDef && nextDef.enter) {
    nextDef.enter();
  }

  state = nextState;
  notify();
};

function _extends$5() {
  _extends$5 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$5.apply(this, arguments);
}

function _objectWithoutPropertiesLoose$7(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

const is = {
  arr: Array.isArray,
  obj: a => Object.prototype.toString.call(a) === '[object Object]',
  fun: a => typeof a === 'function',
  str: a => typeof a === 'string',
  num: a => typeof a === 'number',
  und: a => a === void 0,
  nul: a => a === null,
  set: a => a instanceof Set,
  map: a => a instanceof Map,

  equ(a, b) {
    if (typeof a !== typeof b) return false;
    if (is.str(a) || is.num(a)) return a === b;
    if (is.obj(a) && is.obj(b) && Object.keys(a).length + Object.keys(b).length === 0) return true;
    let i;

    for (i in a) if (!(i in b)) return false;

    for (i in b) if (a[i] !== b[i]) return false;

    return is.und(i) ? a === b : true;
  }

};
function merge$1(target, lowercase) {
  if (lowercase === void 0) {
    lowercase = true;
  }

  return object => (is.arr(object) ? object : Object.keys(object)).reduce((acc, element) => {
    const key = lowercase ? element[0].toLowerCase() + element.substring(1) : element;
    acc[key] = target(key);
    return acc;
  }, target);
}
function useForceUpdate() {
  const _useState = React.useState(false),
        f = _useState[1];

  const forceUpdate = React.useCallback(() => f(v => !v), []);
  return forceUpdate;
}
function withDefault(value, defaultValue) {
  return is.und(value) || is.nul(value) ? defaultValue : value;
}
function toArray$1(a) {
  return !is.und(a) ? is.arr(a) ? a : [a] : [];
}
function callProp(obj) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return is.fun(obj) ? obj(...args) : obj;
}

function getForwardProps(props) {
  const to = props.to,
        from = props.from,
        config = props.config,
        onStart = props.onStart,
        onRest = props.onRest,
        onFrame = props.onFrame,
        children = props.children,
        reset = props.reset,
        reverse = props.reverse,
        force = props.force,
        immediate = props.immediate,
        delay = props.delay,
        attach = props.attach,
        destroyed = props.destroyed,
        interpolateTo = props.interpolateTo,
        ref = props.ref,
        lazy = props.lazy,
        forward = _objectWithoutPropertiesLoose$7(props, ["to", "from", "config", "onStart", "onRest", "onFrame", "children", "reset", "reverse", "force", "immediate", "delay", "attach", "destroyed", "interpolateTo", "ref", "lazy"]);

  return forward;
}

function interpolateTo(props) {
  const forward = getForwardProps(props);
  if (is.und(forward)) return _extends$5({
    to: forward
  }, props);
  const rest = Object.keys(props).reduce((a, k) => !is.und(forward[k]) ? a : _extends$5({}, a, {
    [k]: props[k]
  }), {});
  return _extends$5({
    to: forward
  }, rest);
}
function handleRef(ref, forward) {
  if (forward) {
    // If it's a function, assume it's a ref callback
    if (is.fun(forward)) forward(ref);else if (is.obj(forward)) {
      forward.current = ref;
    }
  }

  return ref;
}

class Animated {
  constructor() {
    this.payload = void 0;
    this.children = [];
  }

  getAnimatedValue() {
    return this.getValue();
  }

  getPayload() {
    return this.payload || this;
  }

  attach() {}

  detach() {}

  getChildren() {
    return this.children;
  }

  addChild(child) {
    if (this.children.length === 0) this.attach();
    this.children.push(child);
  }

  removeChild(child) {
    const index = this.children.indexOf(child);
    this.children.splice(index, 1);
    if (this.children.length === 0) this.detach();
  }

}
class AnimatedArray extends Animated {
  constructor() {
    super(...arguments);
    this.payload = [];

    this.attach = () => this.payload.forEach(p => p instanceof Animated && p.addChild(this));

    this.detach = () => this.payload.forEach(p => p instanceof Animated && p.removeChild(this));
  }

}
class AnimatedObject extends Animated {
  constructor() {
    super(...arguments);
    this.payload = {};

    this.attach = () => Object.values(this.payload).forEach(s => s instanceof Animated && s.addChild(this));

    this.detach = () => Object.values(this.payload).forEach(s => s instanceof Animated && s.removeChild(this));
  }

  getValue(animated) {
    if (animated === void 0) {
      animated = false;
    }

    const payload = {};

    for (const key in this.payload) {
      const value = this.payload[key];
      if (animated && !(value instanceof Animated)) continue;
      payload[key] = value instanceof Animated ? value[animated ? 'getAnimatedValue' : 'getValue']() : value;
    }

    return payload;
  }

  getAnimatedValue() {
    return this.getValue(true);
  }

}

let applyAnimatedValues;
function injectApplyAnimatedValues(fn, transform) {
  applyAnimatedValues = {
    fn,
    transform
  };
}
let colorNames;
function injectColorNames(names) {
  colorNames = names;
}
let requestFrame = cb => typeof window !== 'undefined' ? window.requestAnimationFrame(cb) : -1;
let interpolation;
function injectStringInterpolator(fn) {
  interpolation = fn;
}
let now = () => Date.now();
let animatedApi = node => node.current;
let createAnimatedStyle;
function injectCreateAnimatedStyle(factory) {
  createAnimatedStyle = factory;
}

/**
 * Wraps the `style` property with `AnimatedStyle`.
 */

class AnimatedProps extends AnimatedObject {
  constructor(props, callback) {
    super();
    this.update = void 0;
    this.payload = !props.style ? props : _extends$5({}, props, {
      style: createAnimatedStyle(props.style)
    });
    this.update = callback;
    this.attach();
  }

}

const isFunctionComponent = val => is.fun(val) && !(val.prototype instanceof React__default.Component);

const createAnimatedComponent = Component => {
  const AnimatedComponent = React.forwardRef((props, ref) => {
    const forceUpdate = useForceUpdate();
    const mounted = React.useRef(true);
    const propsAnimated = React.useRef(null);
    const node = React.useRef(null);
    const attachProps = React.useCallback(props => {
      const oldPropsAnimated = propsAnimated.current;

      const callback = () => {
        let didUpdate = false;

        if (node.current) {
          didUpdate = applyAnimatedValues.fn(node.current, propsAnimated.current.getAnimatedValue());
        }

        if (!node.current || didUpdate === false) {
          // If no referenced node has been found, or the update target didn't have a
          // native-responder, then forceUpdate the animation ...
          forceUpdate();
        }
      };

      propsAnimated.current = new AnimatedProps(props, callback);
      oldPropsAnimated && oldPropsAnimated.detach();
    }, []);
    React.useEffect(() => () => {
      mounted.current = false;
      propsAnimated.current && propsAnimated.current.detach();
    }, []);
    React.useImperativeHandle(ref, () => animatedApi(node));
    attachProps(props);

    const _getValue = propsAnimated.current.getValue(),
          scrollTop = _getValue.scrollTop,
          scrollLeft = _getValue.scrollLeft,
          animatedProps = _objectWithoutPropertiesLoose$7(_getValue, ["scrollTop", "scrollLeft"]); // Functions cannot have refs, see:
    // See: https://github.com/react-spring/react-spring/issues/569


    const refFn = isFunctionComponent(Component) ? undefined : childRef => node.current = handleRef(childRef, ref);
    return React__default.createElement(Component, _extends$5({}, animatedProps, {
      ref: refFn
    }));
  });
  return AnimatedComponent;
};

let active = false;
const controllers = new Set();

const update = () => {
  if (!active) return false;
  let time = now();

  for (let controller of controllers) {
    let isActive = false;

    for (let configIdx = 0; configIdx < controller.configs.length; configIdx++) {
      let config = controller.configs[configIdx];
      let endOfAnimation, lastTime;

      for (let valIdx = 0; valIdx < config.animatedValues.length; valIdx++) {
        let animation = config.animatedValues[valIdx]; // If an animation is done, skip, until all of them conclude

        if (animation.done) continue;
        let from = config.fromValues[valIdx];
        let to = config.toValues[valIdx];
        let position = animation.lastPosition;
        let isAnimated = to instanceof Animated;
        let velocity = Array.isArray(config.initialVelocity) ? config.initialVelocity[valIdx] : config.initialVelocity;
        if (isAnimated) to = to.getValue(); // Conclude animation if it's either immediate, or from-values match end-state

        if (config.immediate) {
          animation.setValue(to);
          animation.done = true;
          continue;
        } // Break animation when string values are involved


        if (typeof from === 'string' || typeof to === 'string') {
          animation.setValue(to);
          animation.done = true;
          continue;
        }

        if (config.duration !== void 0) {
          /** Duration easing */
          position = from + config.easing((time - animation.startTime) / config.duration) * (to - from);
          endOfAnimation = time >= animation.startTime + config.duration;
        } else if (config.decay) {
          /** Decay easing */
          position = from + velocity / (1 - 0.998) * (1 - Math.exp(-(1 - 0.998) * (time - animation.startTime)));
          endOfAnimation = Math.abs(animation.lastPosition - position) < 0.1;
          if (endOfAnimation) to = position;
        } else {
          /** Spring easing */
          lastTime = animation.lastTime !== void 0 ? animation.lastTime : time;
          velocity = animation.lastVelocity !== void 0 ? animation.lastVelocity : config.initialVelocity; // If we lost a lot of frames just jump to the end.

          if (time > lastTime + 64) lastTime = time; // http://gafferongames.com/game-physics/fix-your-timestep/

          let numSteps = Math.floor(time - lastTime);

          for (let i = 0; i < numSteps; ++i) {
            let force = -config.tension * (position - to);
            let damping = -config.friction * velocity;
            let acceleration = (force + damping) / config.mass;
            velocity = velocity + acceleration * 1 / 1000;
            position = position + velocity * 1 / 1000;
          } // Conditions for stopping the spring animation


          let isOvershooting = config.clamp && config.tension !== 0 ? from < to ? position > to : position < to : false;
          let isVelocity = Math.abs(velocity) <= config.precision;
          let isDisplacement = config.tension !== 0 ? Math.abs(to - position) <= config.precision : true;
          endOfAnimation = isOvershooting || isVelocity && isDisplacement;
          animation.lastVelocity = velocity;
          animation.lastTime = time;
        } // Trails aren't done until their parents conclude


        if (isAnimated && !config.toValues[valIdx].done) endOfAnimation = false;

        if (endOfAnimation) {
          // Ensure that we end up with a round value
          if (animation.value !== to) position = to;
          animation.done = true;
        } else isActive = true;

        animation.setValue(position);
        animation.lastPosition = position;
      } // Keep track of updated values only when necessary


      if (controller.props.onFrame) controller.values[config.name] = config.interpolation.getValue();
    } // Update callbacks in the end of the frame


    if (controller.props.onFrame) controller.props.onFrame(controller.values); // Either call onEnd or next frame

    if (!isActive) {
      controllers.delete(controller);
      controller.stop(true);
    }
  } // Loop over as long as there are controllers ...


  if (controllers.size) {
    requestFrame(update);
  } else {
    active = false;
  }

  return active;
};

const start = controller => {
  if (!controllers.has(controller)) controllers.add(controller);

  if (!active) {
    active = true;
    requestFrame(update);
  }
};

const stop = controller => {
  if (controllers.has(controller)) controllers.delete(controller);
};

function createInterpolator(range, output, extrapolate) {
  if (typeof range === 'function') {
    return range;
  }

  if (Array.isArray(range)) {
    return createInterpolator({
      range,
      output: output,
      extrapolate
    });
  }

  if (interpolation && typeof range.output[0] === 'string') {
    return interpolation(range);
  }

  const config = range;
  const outputRange = config.output;
  const inputRange = config.range || [0, 1];
  const extrapolateLeft = config.extrapolateLeft || config.extrapolate || 'extend';
  const extrapolateRight = config.extrapolateRight || config.extrapolate || 'extend';

  const easing = config.easing || (t => t);

  return input => {
    const range = findRange(input, inputRange);
    return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight, config.map);
  };
}

function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
  let result = map ? map(input) : input; // Extrapolate

  if (result < inputMin) {
    if (extrapolateLeft === 'identity') return result;else if (extrapolateLeft === 'clamp') result = inputMin;
  }

  if (result > inputMax) {
    if (extrapolateRight === 'identity') return result;else if (extrapolateRight === 'clamp') result = inputMax;
  }

  if (outputMin === outputMax) return outputMin;
  if (inputMin === inputMax) return input <= inputMin ? outputMin : outputMax; // Input Range

  if (inputMin === -Infinity) result = -result;else if (inputMax === Infinity) result = result - inputMin;else result = (result - inputMin) / (inputMax - inputMin); // Easing

  result = easing(result); // Output Range

  if (outputMin === -Infinity) result = -result;else if (outputMax === Infinity) result = result + outputMin;else result = result * (outputMax - outputMin) + outputMin;
  return result;
}

function findRange(input, inputRange) {
  for (var i = 1; i < inputRange.length - 1; ++i) if (inputRange[i] >= input) break;

  return i - 1;
}

class AnimatedInterpolation extends AnimatedArray {
  constructor(parents, range, output, extrapolate) {
    super();
    this.calc = void 0;
    this.payload = parents instanceof AnimatedArray && !(parents instanceof AnimatedInterpolation) ? parents.getPayload() : Array.isArray(parents) ? parents : [parents];
    this.calc = createInterpolator(range, output, extrapolate);
  }

  getValue() {
    return this.calc(...this.payload.map(value => value.getValue()));
  }

  updateConfig(range, output, extrapolate) {
    this.calc = createInterpolator(range, output, extrapolate);
  }

  interpolate(range, output, extrapolate) {
    return new AnimatedInterpolation(this, range, output, extrapolate);
  }

}

/**
 * Animated works by building a directed acyclic graph of dependencies
 * transparently when you render your Animated components.
 *
 *               new Animated.Value(0)
 *     .interpolate()        .interpolate()    new Animated.Value(1)
 *         opacity               translateY      scale
 *          style                         transform
 *         View#234                         style
 *                                         View#123
 *
 * A) Top Down phase
 * When an AnimatedValue is updated, we recursively go down through this
 * graph in order to find leaf nodes: the views that we flag as needing
 * an update.
 *
 * B) Bottom Up phase
 * When a view is flagged as needing an update, we recursively go back up
 * in order to build the new value that it needs. The reason why we need
 * this two-phases process is to deal with composite props such as
 * transform which can receive values from multiple parents.
 */
function addAnimatedStyles(node, styles) {
  if ('update' in node) {
    styles.add(node);
  } else {
    node.getChildren().forEach(child => addAnimatedStyles(child, styles));
  }
}

class AnimatedValue extends Animated {
  constructor(_value) {
    var _this;

    super();
    _this = this;
    this.animatedStyles = new Set();
    this.value = void 0;
    this.startPosition = void 0;
    this.lastPosition = void 0;
    this.lastVelocity = void 0;
    this.startTime = void 0;
    this.lastTime = void 0;
    this.done = false;

    this.setValue = function (value, flush) {
      if (flush === void 0) {
        flush = true;
      }

      _this.value = value;
      if (flush) _this.flush();
    };

    this.value = _value;
    this.startPosition = _value;
    this.lastPosition = _value;
  }

  flush() {
    if (this.animatedStyles.size === 0) {
      addAnimatedStyles(this, this.animatedStyles);
    }

    this.animatedStyles.forEach(animatedStyle => animatedStyle.update());
  }

  clearStyles() {
    this.animatedStyles.clear();
  }

  getValue() {
    return this.value;
  }

  interpolate(range, output, extrapolate) {
    return new AnimatedInterpolation(this, range, output, extrapolate);
  }

}

class AnimatedValueArray extends AnimatedArray {
  constructor(values) {
    super();
    this.payload = values.map(n => new AnimatedValue(n));
  }

  setValue(value, flush) {
    if (flush === void 0) {
      flush = true;
    }

    if (Array.isArray(value)) {
      if (value.length === this.payload.length) {
        value.forEach((v, i) => this.payload[i].setValue(v, flush));
      }
    } else {
      this.payload.forEach(p => p.setValue(value, flush));
    }
  }

  getValue() {
    return this.payload.map(v => v.getValue());
  }

  interpolate(range, output) {
    return new AnimatedInterpolation(this, range, output);
  }

}

let G = 0;

class Controller {
  constructor() {
    this.id = void 0;
    this.idle = true;
    this.hasChanged = false;
    this.guid = 0;
    this.local = 0;
    this.props = {};
    this.merged = {};
    this.animations = {};
    this.interpolations = {};
    this.values = {};
    this.configs = [];
    this.listeners = [];
    this.queue = [];
    this.localQueue = void 0;

    this.getValues = () => this.interpolations;

    this.id = G++;
  }
  /** update(props)
   *  This function filters input props and creates an array of tasks which are executed in .start()
   *  Each task is allowed to carry a delay, which means it can execute asnychroneously */


  update(args) {
    //this._id = n + this.id
    if (!args) return this; // Extract delay and the to-prop from props

    const _ref = interpolateTo(args),
          _ref$delay = _ref.delay,
          delay = _ref$delay === void 0 ? 0 : _ref$delay,
          to = _ref.to,
          props = _objectWithoutPropertiesLoose$7(_ref, ["delay", "to"]);

    if (is.arr(to) || is.fun(to)) {
      // If config is either a function or an array queue it up as is
      this.queue.push(_extends$5({}, props, {
        delay,
        to
      }));
    } else if (to) {
      // Otherwise go through each key since it could be delayed individually
      let ops = {};
      Object.entries(to).forEach((_ref2) => {
        let k = _ref2[0],
            v = _ref2[1];

        // Fetch delay and create an entry, consisting of the to-props, the delay, and basic props
        const entry = _extends$5({
          to: {
            [k]: v
          },
          delay: callProp(delay, k)
        }, props);

        const previous = ops[entry.delay] && ops[entry.delay].to;
        ops[entry.delay] = _extends$5({}, ops[entry.delay], entry, {
          to: _extends$5({}, previous, entry.to)
        });
      });
      this.queue = Object.values(ops);
    } // Sort queue, so that async calls go last


    this.queue = this.queue.sort((a, b) => a.delay - b.delay); // Diff the reduced props immediately (they'll contain the from-prop and some config)

    this.diff(props);
    return this;
  }
  /** start(onEnd)
   *  This function either executes a queue, if present, or starts the frameloop, which animates */


  start(onEnd) {
    // If a queue is present we must excecute it
    if (this.queue.length) {
      this.idle = false; // Updates can interrupt trailing queues, in that case we just merge values

      if (this.localQueue) {
        this.localQueue.forEach((_ref3) => {
          let _ref3$from = _ref3.from,
              from = _ref3$from === void 0 ? {} : _ref3$from,
              _ref3$to = _ref3.to,
              to = _ref3$to === void 0 ? {} : _ref3$to;
          if (is.obj(from)) this.merged = _extends$5({}, from, this.merged);
          if (is.obj(to)) this.merged = _extends$5({}, this.merged, to);
        });
      } // The guid helps us tracking frames, a new queue over an old one means an override
      // We discard async calls in that case


      const local = this.local = ++this.guid;
      const queue = this.localQueue = this.queue;
      this.queue = []; // Go through each entry and execute it

      queue.forEach((_ref4, index) => {
        let delay = _ref4.delay,
            props = _objectWithoutPropertiesLoose$7(_ref4, ["delay"]);

        const cb = finished => {
          if (index === queue.length - 1 && local === this.guid && finished) {
            this.idle = true;
            if (this.props.onRest) this.props.onRest(this.merged);
          }

          if (onEnd) onEnd();
        }; // Entries can be delayed, ansyc or immediate


        let async = is.arr(props.to) || is.fun(props.to);

        if (delay) {
          setTimeout(() => {
            if (local === this.guid) {
              if (async) this.runAsync(props, cb);else this.diff(props).start(cb);
            }
          }, delay);
        } else if (async) this.runAsync(props, cb);else this.diff(props).start(cb);
      });
    } // Otherwise we kick of the frameloop
    else {
        if (is.fun(onEnd)) this.listeners.push(onEnd);
        if (this.props.onStart) this.props.onStart();
        start(this);
      }

    return this;
  }

  stop(finished) {
    this.listeners.forEach(onEnd => onEnd(finished));
    this.listeners = [];
    return this;
  }
  /** Pause sets onEnd listeners free, but also removes the controller from the frameloop */


  pause(finished) {
    this.stop(true);
    if (finished) stop(this);
    return this;
  }

  runAsync(_ref5, onEnd) {
    var _this = this;

    let delay = _ref5.delay,
        props = _objectWithoutPropertiesLoose$7(_ref5, ["delay"]);

    const local = this.local; // If "to" is either a function or an array it will be processed async, therefor "to" should be empty right now
    // If the view relies on certain values "from" has to be present

    let queue = Promise.resolve(undefined);

    if (is.arr(props.to)) {
      for (let i = 0; i < props.to.length; i++) {
        const index = i;

        const fresh = _extends$5({}, props, interpolateTo(props.to[index]));

        if (is.arr(fresh.config)) fresh.config = fresh.config[index];
        queue = queue.then(() => {
          //this.stop()
          if (local === this.guid) return new Promise(r => this.diff(fresh).start(r));
        });
      }
    } else if (is.fun(props.to)) {
      let index = 0;
      let last;
      queue = queue.then(() => props.to( // next(props)
      p => {
        const fresh = _extends$5({}, props, interpolateTo(p));

        if (is.arr(fresh.config)) fresh.config = fresh.config[index];
        index++; //this.stop()

        if (local === this.guid) return last = new Promise(r => this.diff(fresh).start(r));
        return;
      }, // cancel()
      function (finished) {
        if (finished === void 0) {
          finished = true;
        }

        return _this.stop(finished);
      }).then(() => last));
    }

    queue.then(onEnd);
  }

  diff(props) {
    this.props = _extends$5({}, this.props, props);
    let _this$props = this.props,
        _this$props$from = _this$props.from,
        from = _this$props$from === void 0 ? {} : _this$props$from,
        _this$props$to = _this$props.to,
        to = _this$props$to === void 0 ? {} : _this$props$to,
        _this$props$config = _this$props.config,
        config = _this$props$config === void 0 ? {} : _this$props$config,
        reverse = _this$props.reverse,
        attach = _this$props.attach,
        reset = _this$props.reset,
        immediate = _this$props.immediate; // Reverse values when requested

    if (reverse) {
      var _ref6 = [to, from];
      from = _ref6[0];
      to = _ref6[1];
    } // This will collect all props that were ever set, reset merged props when necessary


    this.merged = _extends$5({}, from, this.merged, to);
    this.hasChanged = false; // Attachment handling, trailed springs can "attach" themselves to a previous spring

    let target = attach && attach(this); // Reduces input { name: value } pairs into animated values

    this.animations = Object.entries(this.merged).reduce((acc, _ref7) => {
      let name = _ref7[0],
          value = _ref7[1];
      // Issue cached entries, except on reset
      let entry = acc[name] || {}; // Figure out what the value is supposed to be

      const isNumber = is.num(value);
      const isString = is.str(value) && !value.startsWith('#') && !/\d/.test(value) && !colorNames[value];
      const isArray = is.arr(value);
      const isInterpolation = !isNumber && !isArray && !isString;
      let fromValue = !is.und(from[name]) ? from[name] : value;
      let toValue = isNumber || isArray ? value : isString ? value : 1;
      let toConfig = callProp(config, name);
      if (target) toValue = target.animations[name].parent;
      let parent = entry.parent,
          interpolation$$1 = entry.interpolation,
          toValues = toArray$1(target ? toValue.getPayload() : toValue),
          animatedValues;
      let newValue = value;
      if (isInterpolation) newValue = interpolation({
        range: [0, 1],
        output: [value, value]
      })(1);
      let currentValue = interpolation$$1 && interpolation$$1.getValue(); // Change detection flags

      const isFirst = is.und(parent);
      const isActive = !isFirst && entry.animatedValues.some(v => !v.done);
      const currentValueDiffersFromGoal = !is.equ(newValue, currentValue);
      const hasNewGoal = !is.equ(newValue, entry.previous);
      const hasNewConfig = !is.equ(toConfig, entry.config); // Change animation props when props indicate a new goal (new value differs from previous one)
      // and current values differ from it. Config changes trigger a new update as well (though probably shouldn't?)

      if (reset || hasNewGoal && currentValueDiffersFromGoal || hasNewConfig) {
        // Convert regular values into animated values, ALWAYS re-use if possible
        if (isNumber || isString) parent = interpolation$$1 = entry.parent || new AnimatedValue(fromValue);else if (isArray) parent = interpolation$$1 = entry.parent || new AnimatedValueArray(fromValue);else if (isInterpolation) {
          let prev = entry.interpolation && entry.interpolation.calc(entry.parent.value);
          prev = prev !== void 0 && !reset ? prev : fromValue;

          if (entry.parent) {
            parent = entry.parent;
            parent.setValue(0, false);
          } else parent = new AnimatedValue(0);

          const range = {
            output: [prev, value]
          };

          if (entry.interpolation) {
            interpolation$$1 = entry.interpolation;
            entry.interpolation.updateConfig(range);
          } else interpolation$$1 = parent.interpolate(range);
        }
        toValues = toArray$1(target ? toValue.getPayload() : toValue);
        animatedValues = toArray$1(parent.getPayload());
        if (reset && !isInterpolation) parent.setValue(fromValue, false);
        this.hasChanged = true; // Reset animated values

        animatedValues.forEach(value => {
          value.startPosition = value.value;
          value.lastPosition = value.value;
          value.lastVelocity = isActive ? value.lastVelocity : undefined;
          value.lastTime = isActive ? value.lastTime : undefined;
          value.startTime = now();
          value.done = false;
          value.animatedStyles.clear();
        }); // Set immediate values

        if (callProp(immediate, name)) {
          parent.setValue(isInterpolation ? toValue : value, false);
        }

        return _extends$5({}, acc, {
          [name]: _extends$5({}, entry, {
            name,
            parent,
            interpolation: interpolation$$1,
            animatedValues,
            toValues,
            previous: newValue,
            config: toConfig,
            fromValues: toArray$1(parent.getValue()),
            immediate: callProp(immediate, name),
            initialVelocity: withDefault(toConfig.velocity, 0),
            clamp: withDefault(toConfig.clamp, false),
            precision: withDefault(toConfig.precision, 0.01),
            tension: withDefault(toConfig.tension, 170),
            friction: withDefault(toConfig.friction, 26),
            mass: withDefault(toConfig.mass, 1),
            duration: toConfig.duration,
            easing: withDefault(toConfig.easing, t => t),
            decay: toConfig.decay
          })
        });
      } else {
        if (!currentValueDiffersFromGoal) {
          // So ... the current target value (newValue) appears to be different from the previous value,
          // which normally constitutes an update, but the actual value (currentValue) matches the target!
          // In order to resolve this without causing an animation update we silently flag the animation as done,
          // which it technically is. Interpolations also needs a config update with their target set to 1.
          if (isInterpolation) {
            parent.setValue(1, false);
            interpolation$$1.updateConfig({
              output: [newValue, newValue]
            });
          }

          parent.done = true;
          this.hasChanged = true;
          return _extends$5({}, acc, {
            [name]: _extends$5({}, acc[name], {
              previous: newValue
            })
          });
        }

        return acc;
      }
    }, this.animations);

    if (this.hasChanged) {
      // Make animations available to frameloop
      this.configs = Object.values(this.animations);
      this.values = {};
      this.interpolations = {};

      for (let key in this.animations) {
        this.interpolations[key] = this.animations[key].interpolation;
        this.values[key] = this.animations[key].interpolation.getValue();
      }
    }

    return this;
  }

  destroy() {
    this.stop();
    this.props = {};
    this.merged = {};
    this.animations = {};
    this.interpolations = {};
    this.values = {};
    this.configs = [];
    this.local = 0;
  }

}

/** API
 * const transitions = useTransition(items, itemKeys, { ... })
 * const [transitions, update] = useTransition(items, itemKeys, () => ({ ... }))
 */

let guid = 0;
const ENTER = 'enter';
const LEAVE = 'leave';
const UPDATE = 'update';

const mapKeys = (items, keys) => (typeof keys === 'function' ? items.map(keys) : toArray$1(keys)).map(String);

const get$1 = props => {
  let items = props.items,
      _props$keys = props.keys,
      keys = _props$keys === void 0 ? item => item : _props$keys,
      rest = _objectWithoutPropertiesLoose$7(props, ["items", "keys"]);

  items = toArray$1(items !== void 0 ? items : null);
  return _extends$5({
    items,
    keys: mapKeys(items, keys)
  }, rest);
};

function useTransition(input, keyTransform, config) {
  const props = _extends$5({
    items: input,
    keys: keyTransform || (i => i)
  }, config);

  const _get = get$1(props),
        _get$lazy = _get.lazy,
        lazy = _get$lazy === void 0 ? false : _get$lazy,
        _get$unique = _get.unique,
        _get$reset = _get.reset,
        reset = _get$reset === void 0 ? false : _get$reset,
        enter = _get.enter,
        leave = _get.leave,
        update = _get.update,
        onDestroyed = _get.onDestroyed,
        keys = _get.keys,
        items = _get.items,
        onFrame = _get.onFrame,
        _onRest = _get.onRest,
        onStart = _get.onStart,
        ref = _get.ref,
        extra = _objectWithoutPropertiesLoose$7(_get, ["lazy", "unique", "reset", "enter", "leave", "update", "onDestroyed", "keys", "items", "onFrame", "onRest", "onStart", "ref"]);

  const forceUpdate = useForceUpdate();
  const mounted = React.useRef(false);
  const state = React.useRef({
    mounted: false,
    first: true,
    deleted: [],
    current: {},
    transitions: [],
    prevProps: {},
    paused: !!props.ref,
    instances: !mounted.current && new Map(),
    forceUpdate
  });
  React.useImperativeHandle(props.ref, () => ({
    start: () => Promise.all(Array.from(state.current.instances).map((_ref) => {
      let c = _ref[1];
      return new Promise(r => c.start(r));
    })),
    stop: finished => Array.from(state.current.instances).forEach((_ref2) => {
      let c = _ref2[1];
      return c.stop(finished);
    }),

    get controllers() {
      return Array.from(state.current.instances).map((_ref3) => {
        let c = _ref3[1];
        return c;
      });
    }

  })); // Update state

  state.current = diffItems(state.current, props);

  if (state.current.changed) {
    // Update state
    state.current.transitions.forEach(transition => {
      const slot = transition.slot,
            from = transition.from,
            to = transition.to,
            config = transition.config,
            trail = transition.trail,
            key = transition.key,
            item = transition.item;
      if (!state.current.instances.has(key)) state.current.instances.set(key, new Controller()); // update the map object

      const ctrl = state.current.instances.get(key);

      const newProps = _extends$5({}, extra, {
        to,
        from,
        config,
        ref,
        onRest: values => {
          if (state.current.mounted) {
            if (transition.destroyed) {
              // If no ref is given delete destroyed items immediately
              if (!ref && !lazy) cleanUp(state, key);
              if (onDestroyed) onDestroyed(item);
            } // A transition comes to rest once all its springs conclude


            const curInstances = Array.from(state.current.instances);
            const active = curInstances.some((_ref4) => {
              let c = _ref4[1];
              return !c.idle;
            });
            if (!active && (ref || lazy) && state.current.deleted.length > 0) cleanUp(state);
            if (_onRest) _onRest(item, slot, values);
          }
        },
        onStart: onStart && (() => onStart(item, slot)),
        onFrame: onFrame && (values => onFrame(item, slot, values)),
        delay: trail,
        reset: reset && slot === ENTER // Update controller

      });

      ctrl.update(newProps);
      if (!state.current.paused) ctrl.start();
    });
  }

  React.useEffect(() => {
    state.current.mounted = mounted.current = true;
    return () => {
      state.current.mounted = mounted.current = false;
      Array.from(state.current.instances).map((_ref5) => {
        let c = _ref5[1];
        return c.destroy();
      });
      state.current.instances.clear();
    };
  }, []);
  return state.current.transitions.map((_ref6) => {
    let item = _ref6.item,
        slot = _ref6.slot,
        key = _ref6.key;
    return {
      item,
      key,
      state: slot,
      props: state.current.instances.get(key).getValues()
    };
  });
}

function cleanUp(state, filterKey) {
  const deleted = state.current.deleted;

  for (let _ref7 of deleted) {
    let key = _ref7.key;

    const filter = t => t.key !== key;

    if (is.und(filterKey) || filterKey === key) {
      state.current.instances.delete(key);
      state.current.transitions = state.current.transitions.filter(filter);
      state.current.deleted = state.current.deleted.filter(filter);
    }
  }

  state.current.forceUpdate();
}

function diffItems(_ref8, props) {
  let first = _ref8.first,
      prevProps = _ref8.prevProps,
      state = _objectWithoutPropertiesLoose$7(_ref8, ["first", "prevProps"]);

  let _get2 = get$1(props),
      items = _get2.items,
      keys = _get2.keys,
      initial = _get2.initial,
      from = _get2.from,
      enter = _get2.enter,
      leave = _get2.leave,
      update = _get2.update,
      _get2$trail = _get2.trail,
      trail = _get2$trail === void 0 ? 0 : _get2$trail,
      unique = _get2.unique,
      config = _get2.config,
      _get2$order = _get2.order,
      order = _get2$order === void 0 ? [ENTER, LEAVE, UPDATE] : _get2$order;

  let _get3 = get$1(prevProps),
      _keys = _get3.keys,
      _items = _get3.items;

  let current = _extends$5({}, state.current);

  let deleted = [...state.deleted]; // Compare next keys with current keys

  let currentKeys = Object.keys(current);
  let currentSet = new Set(currentKeys);
  let nextSet = new Set(keys);
  let added = keys.filter(item => !currentSet.has(item));
  let removed = state.transitions.filter(item => !item.destroyed && !nextSet.has(item.originalKey)).map(i => i.originalKey);
  let updated = keys.filter(item => currentSet.has(item));
  let delay = -trail;

  while (order.length) {
    const changeType = order.shift();

    switch (changeType) {
      case ENTER:
        {
          added.forEach((key, index) => {
            // In unique mode, remove fading out transitions if their key comes in again
            if (unique && deleted.find(d => d.originalKey === key)) deleted = deleted.filter(t => t.originalKey !== key);
            const keyIndex = keys.indexOf(key);
            const item = items[keyIndex];
            const slot = first && initial !== void 0 ? 'initial' : ENTER;
            current[key] = {
              slot,
              originalKey: key,
              key: unique ? String(key) : guid++,
              item,
              trail: delay = delay + trail,
              config: callProp(config, item, slot),
              from: callProp(first ? initial !== void 0 ? initial || {} : from : from, item),
              to: callProp(enter, item)
            };
          });
          break;
        }

      case LEAVE:
        {
          removed.forEach(key => {
            const keyIndex = _keys.indexOf(key);

            const item = _items[keyIndex];
            const slot = LEAVE;
            deleted.unshift(_extends$5({}, current[key], {
              slot,
              destroyed: true,
              left: _keys[Math.max(0, keyIndex - 1)],
              right: _keys[Math.min(_keys.length, keyIndex + 1)],
              trail: delay = delay + trail,
              config: callProp(config, item, slot),
              to: callProp(leave, item)
            }));
            delete current[key];
          });
          break;
        }

      case UPDATE:
        {
          updated.forEach(key => {
            const keyIndex = keys.indexOf(key);
            const item = items[keyIndex];
            const slot = UPDATE;
            current[key] = _extends$5({}, current[key], {
              item,
              slot,
              trail: delay = delay + trail,
              config: callProp(config, item, slot),
              to: callProp(update, item)
            });
          });
          break;
        }
    }
  }

  let out = keys.map(key => current[key]); // This tries to restore order for deleted items by finding their last known siblings
  // only using the left sibling to keep order placement consistent for all deleted items

  deleted.forEach((_ref9) => {
    let left = _ref9.left,
        right = _ref9.right,
        item = _objectWithoutPropertiesLoose$7(_ref9, ["left", "right"]);

    let pos; // Was it the element on the left, if yes, move there ...

    if ((pos = out.findIndex(t => t.originalKey === left)) !== -1) pos += 1; // And if nothing else helps, move it to the start \_()_/

    pos = Math.max(0, pos);
    out = [...out.slice(0, pos), item, ...out.slice(pos)];
  });
  return _extends$5({}, state, {
    changed: added.length || removed.length || updated.length,
    first: first && added.length === 0,
    transitions: out,
    current,
    deleted,
    prevProps: props
  });
}

class AnimatedStyle extends AnimatedObject {
  constructor(style) {
    if (style === void 0) {
      style = {};
    }

    super();

    if (style.transform && !(style.transform instanceof Animated)) {
      style = applyAnimatedValues.transform(style);
    }

    this.payload = style;
  }

}

// http://www.w3.org/TR/css3-color/#svg-color
const colors$1 = {
  transparent: 0x00000000,
  aliceblue: 0xf0f8ffff,
  antiquewhite: 0xfaebd7ff,
  aqua: 0x00ffffff,
  aquamarine: 0x7fffd4ff,
  azure: 0xf0ffffff,
  beige: 0xf5f5dcff,
  bisque: 0xffe4c4ff,
  black: 0x000000ff,
  blanchedalmond: 0xffebcdff,
  blue: 0x0000ffff,
  blueviolet: 0x8a2be2ff,
  brown: 0xa52a2aff,
  burlywood: 0xdeb887ff,
  burntsienna: 0xea7e5dff,
  cadetblue: 0x5f9ea0ff,
  chartreuse: 0x7fff00ff,
  chocolate: 0xd2691eff,
  coral: 0xff7f50ff,
  cornflowerblue: 0x6495edff,
  cornsilk: 0xfff8dcff,
  crimson: 0xdc143cff,
  cyan: 0x00ffffff,
  darkblue: 0x00008bff,
  darkcyan: 0x008b8bff,
  darkgoldenrod: 0xb8860bff,
  darkgray: 0xa9a9a9ff,
  darkgreen: 0x006400ff,
  darkgrey: 0xa9a9a9ff,
  darkkhaki: 0xbdb76bff,
  darkmagenta: 0x8b008bff,
  darkolivegreen: 0x556b2fff,
  darkorange: 0xff8c00ff,
  darkorchid: 0x9932ccff,
  darkred: 0x8b0000ff,
  darksalmon: 0xe9967aff,
  darkseagreen: 0x8fbc8fff,
  darkslateblue: 0x483d8bff,
  darkslategray: 0x2f4f4fff,
  darkslategrey: 0x2f4f4fff,
  darkturquoise: 0x00ced1ff,
  darkviolet: 0x9400d3ff,
  deeppink: 0xff1493ff,
  deepskyblue: 0x00bfffff,
  dimgray: 0x696969ff,
  dimgrey: 0x696969ff,
  dodgerblue: 0x1e90ffff,
  firebrick: 0xb22222ff,
  floralwhite: 0xfffaf0ff,
  forestgreen: 0x228b22ff,
  fuchsia: 0xff00ffff,
  gainsboro: 0xdcdcdcff,
  ghostwhite: 0xf8f8ffff,
  gold: 0xffd700ff,
  goldenrod: 0xdaa520ff,
  gray: 0x808080ff,
  green: 0x008000ff,
  greenyellow: 0xadff2fff,
  grey: 0x808080ff,
  honeydew: 0xf0fff0ff,
  hotpink: 0xff69b4ff,
  indianred: 0xcd5c5cff,
  indigo: 0x4b0082ff,
  ivory: 0xfffff0ff,
  khaki: 0xf0e68cff,
  lavender: 0xe6e6faff,
  lavenderblush: 0xfff0f5ff,
  lawngreen: 0x7cfc00ff,
  lemonchiffon: 0xfffacdff,
  lightblue: 0xadd8e6ff,
  lightcoral: 0xf08080ff,
  lightcyan: 0xe0ffffff,
  lightgoldenrodyellow: 0xfafad2ff,
  lightgray: 0xd3d3d3ff,
  lightgreen: 0x90ee90ff,
  lightgrey: 0xd3d3d3ff,
  lightpink: 0xffb6c1ff,
  lightsalmon: 0xffa07aff,
  lightseagreen: 0x20b2aaff,
  lightskyblue: 0x87cefaff,
  lightslategray: 0x778899ff,
  lightslategrey: 0x778899ff,
  lightsteelblue: 0xb0c4deff,
  lightyellow: 0xffffe0ff,
  lime: 0x00ff00ff,
  limegreen: 0x32cd32ff,
  linen: 0xfaf0e6ff,
  magenta: 0xff00ffff,
  maroon: 0x800000ff,
  mediumaquamarine: 0x66cdaaff,
  mediumblue: 0x0000cdff,
  mediumorchid: 0xba55d3ff,
  mediumpurple: 0x9370dbff,
  mediumseagreen: 0x3cb371ff,
  mediumslateblue: 0x7b68eeff,
  mediumspringgreen: 0x00fa9aff,
  mediumturquoise: 0x48d1ccff,
  mediumvioletred: 0xc71585ff,
  midnightblue: 0x191970ff,
  mintcream: 0xf5fffaff,
  mistyrose: 0xffe4e1ff,
  moccasin: 0xffe4b5ff,
  navajowhite: 0xffdeadff,
  navy: 0x000080ff,
  oldlace: 0xfdf5e6ff,
  olive: 0x808000ff,
  olivedrab: 0x6b8e23ff,
  orange: 0xffa500ff,
  orangered: 0xff4500ff,
  orchid: 0xda70d6ff,
  palegoldenrod: 0xeee8aaff,
  palegreen: 0x98fb98ff,
  paleturquoise: 0xafeeeeff,
  palevioletred: 0xdb7093ff,
  papayawhip: 0xffefd5ff,
  peachpuff: 0xffdab9ff,
  peru: 0xcd853fff,
  pink: 0xffc0cbff,
  plum: 0xdda0ddff,
  powderblue: 0xb0e0e6ff,
  purple: 0x800080ff,
  rebeccapurple: 0x663399ff,
  red: 0xff0000ff,
  rosybrown: 0xbc8f8fff,
  royalblue: 0x4169e1ff,
  saddlebrown: 0x8b4513ff,
  salmon: 0xfa8072ff,
  sandybrown: 0xf4a460ff,
  seagreen: 0x2e8b57ff,
  seashell: 0xfff5eeff,
  sienna: 0xa0522dff,
  silver: 0xc0c0c0ff,
  skyblue: 0x87ceebff,
  slateblue: 0x6a5acdff,
  slategray: 0x708090ff,
  slategrey: 0x708090ff,
  snow: 0xfffafaff,
  springgreen: 0x00ff7fff,
  steelblue: 0x4682b4ff,
  tan: 0xd2b48cff,
  teal: 0x008080ff,
  thistle: 0xd8bfd8ff,
  tomato: 0xff6347ff,
  turquoise: 0x40e0d0ff,
  violet: 0xee82eeff,
  wheat: 0xf5deb3ff,
  white: 0xffffffff,
  whitesmoke: 0xf5f5f5ff,
  yellow: 0xffff00ff,
  yellowgreen: 0x9acd32ff
};

// const INTEGER = '[-+]?\\d+';
const NUMBER = '[-+]?\\d*\\.?\\d+';
const PERCENTAGE = NUMBER + '%';

function call() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }

  return '\\(\\s*(' + parts.join(')\\s*,\\s*(') + ')\\s*\\)';
}

const rgb = new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER));
const rgba = new RegExp('rgba' + call(NUMBER, NUMBER, NUMBER, NUMBER));
const hsl = new RegExp('hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE));
const hsla = new RegExp('hsla' + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
const hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
const hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
const hex6 = /^#([0-9a-fA-F]{6})$/;
const hex8 = /^#([0-9a-fA-F]{8})$/;

/*
https://github.com/react-community/normalize-css-color

BSD 3-Clause License

Copyright (c) 2016, React Community
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function normalizeColor(color) {
  let match;

  if (typeof color === 'number') {
    return color >>> 0 === color && color >= 0 && color <= 0xffffffff ? color : null;
  } // Ordered based on occurrences on Facebook codebase


  if (match = hex6.exec(color)) return parseInt(match[1] + 'ff', 16) >>> 0;
  if (colors$1.hasOwnProperty(color)) return colors$1[color];

  if (match = rgb.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    0x000000ff) >>> // a
    0;
  }

  if (match = rgba.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    parse1(match[4])) >>> // a
    0;
  }

  if (match = hex3.exec(color)) {
    return parseInt(match[1] + match[1] + // r
    match[2] + match[2] + // g
    match[3] + match[3] + // b
    'ff', // a
    16) >>> 0;
  } // https://drafts.csswg.org/css-color-4/#hex-notation


  if (match = hex8.exec(color)) return parseInt(match[1], 16) >>> 0;

  if (match = hex4.exec(color)) {
    return parseInt(match[1] + match[1] + // r
    match[2] + match[2] + // g
    match[3] + match[3] + // b
    match[4] + match[4], // a
    16) >>> 0;
  }

  if (match = hsl.exec(color)) {
    return (hslToRgb(parse360(match[1]), // h
    parsePercentage(match[2]), // s
    parsePercentage(match[3]) // l
    ) | 0x000000ff) >>> // a
    0;
  }

  if (match = hsla.exec(color)) {
    return (hslToRgb(parse360(match[1]), // h
    parsePercentage(match[2]), // s
    parsePercentage(match[3]) // l
    ) | parse1(match[4])) >>> // a
    0;
  }

  return null;
}

function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}

function hslToRgb(h, s, l) {
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  const r = hue2rgb(p, q, h + 1 / 3);
  const g = hue2rgb(p, q, h);
  const b = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}

function parse255(str) {
  const int = parseInt(str, 10);
  if (int < 0) return 0;
  if (int > 255) return 255;
  return int;
}

function parse360(str) {
  const int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}

function parse1(str) {
  const num = parseFloat(str);
  if (num < 0) return 0;
  if (num > 1) return 255;
  return Math.round(num * 255);
}

function parsePercentage(str) {
  // parseFloat conveniently ignores the final %
  const int = parseFloat(str);
  if (int < 0) return 0;
  if (int > 100) return 1;
  return int / 100;
}

function colorToRgba(input) {
  let int32Color = normalizeColor(input);
  if (int32Color === null) return input;
  int32Color = int32Color || 0;
  let r = (int32Color & 0xff000000) >>> 24;
  let g = (int32Color & 0x00ff0000) >>> 16;
  let b = (int32Color & 0x0000ff00) >>> 8;
  let a = (int32Color & 0x000000ff) / 255;
  return `rgba(${r}, ${g}, ${b}, ${a})`;
} // Problem: https://github.com/animatedjs/animated/pull/102
// Solution: https://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly/658662


const stringShapeRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g; // Covers rgb, rgba, hsl, hsla
// Taken from https://gist.github.com/olmokramer/82ccce673f86db7cda5e

const colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi; // Covers color names (transparent, blue, etc.)

const colorNamesRegex = new RegExp(`(${Object.keys(colors$1).join('|')})`, 'g');
/**
 * Supports string shapes by extracting numbers so new values can be computed,
 * and recombines those values into new strings of the same shape.  Supports
 * things like:
 *
 *   rgba(123, 42, 99, 0.36)           // colors
 *   -45deg                            // values with units
 *   0 2px 2px 0px rgba(0, 0, 0, 0.12) // box shadows
 */

const createStringInterpolator = config => {
  // Replace colors with rgba
  const outputRange = config.output.map(rangeValue => rangeValue.replace(colorRegex, colorToRgba)).map(rangeValue => rangeValue.replace(colorNamesRegex, colorToRgba));
  const outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);
  outputRange.forEach(value => {
    value.match(stringShapeRegex).forEach((number, i) => outputRanges[i].push(+number));
  });
  const interpolations = outputRange[0].match(stringShapeRegex).map((_value, i) => createInterpolator(_extends$5({}, config, {
    output: outputRanges[i]
  })));
  return input => {
    let i = 0;
    return outputRange[0] // 'rgba(0, 100, 200, 0)'
    // ->
    // 'rgba(${interpolations[0](input)}, ${interpolations[1](input)}, ...'
    .replace(stringShapeRegex, () => interpolations[i++](input)) // rgba requires that the r,g,b are integers.... so we want to round them, but we *dont* want to
    // round the opacity (4th column).
    .replace(/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`);
  };
};

let isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

const prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);

const prefixes = ['Webkit', 'Ms', 'Moz', 'O'];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach(prefix => acc[prefixKey(prefix, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);

function dangerousStyleValue(name, value, isCustomProperty) {
  if (value == null || typeof value === 'boolean' || value === '') return '';
  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers

  return ('' + value).trim();
}

const attributeCache = {};
injectCreateAnimatedStyle(style => new AnimatedStyle(style));
injectStringInterpolator(createStringInterpolator);
injectColorNames(colors$1);
injectApplyAnimatedValues((instance, props) => {
  if (instance.nodeType && instance.setAttribute !== undefined) {
    const style = props.style,
          children = props.children,
          scrollTop = props.scrollTop,
          scrollLeft = props.scrollLeft,
          attributes = _objectWithoutPropertiesLoose$7(props, ["style", "children", "scrollTop", "scrollLeft"]);

    const filter = instance.nodeName === 'filter' || instance.parentNode && instance.parentNode.nodeName === 'filter';
    if (scrollTop !== void 0) instance.scrollTop = scrollTop;
    if (scrollLeft !== void 0) instance.scrollLeft = scrollLeft; // Set textContent, if children is an animatable value

    if (children !== void 0) instance.textContent = children; // Set styles ...

    for (let styleName in style) {
      if (!style.hasOwnProperty(styleName)) continue;
      var isCustomProperty = styleName.indexOf('--') === 0;
      var styleValue = dangerousStyleValue(styleName, style[styleName], isCustomProperty);
      if (styleName === 'float') styleName = 'cssFloat';
      if (isCustomProperty) instance.style.setProperty(styleName, styleValue);else instance.style[styleName] = styleValue;
    } // Set attributes ...


    for (let name in attributes) {
      // Attributes are written in dash case
      const dashCase = filter ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, n => '-' + n.toLowerCase()));
      if (typeof instance.getAttribute(dashCase) !== 'undefined') instance.setAttribute(dashCase, attributes[name]);
    }

    return;
  } else return false;
}, style => style);

const domElements = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG
'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];
// Extend animated with all the available THREE elements
const apply = merge$1(createAnimatedComponent, false);
const extendedAnimated = apply(domElements);

var useDOMNode = function useDOMNode(tag, isUnique) {
  var domElRef = React.useRef(undefined);
  React.useLayoutEffect(function () {
    if (tag) {
      if (isUnique) {
        domElRef.current = document.querySelector(tag);

        if (!domElRef.current) {
          domElRef.current = document.createElement(tag);
          document.body.appendChild(domElRef.current);
        }
      } else {
        domElRef.current = document.createElement(tag);
      }

      return function () {
        if (isUnique) {
          var domNodeToRemove = document.querySelector(tag);
          domNodeToRemove && document.body.removeChild(domNodeToRemove);
        }
      };
    }
  }, [tag, isUnique]);
  return domElRef;
};

var Portal$1 = function Portal(_ref) {
  var children = _ref.children,
      _ref$tag = _ref.tag,
      tag = _ref$tag === void 0 ? "gatsby-portal" : _ref$tag,
      target = _ref.target;
  var portalNodeRef = useDOMNode(tag);
  var portalRootRef = useDOMNode(target, true);

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      hasInitialized = _useState2[0],
      setHasInitialized = _useState2[1];

  React.useLayoutEffect(function () {
    if (portalNodeRef.current) {
      var hostNode = portalRootRef.current || document.body;
      hostNode.appendChild(portalNodeRef.current);
      setHasInitialized(true);
      return function () {
        return hostNode.removeChild(portalNodeRef.current);
      };
    }
  }, [tag, target]);
  return hasInitialized && portalNodeRef.current ? reactDom.createPortal(children, portalNodeRef.current) : null;
};

Portal$1.propTypes = {
  tag: _pt__default.string,
  target: _pt__default.string
};

var pointerPosition = {
  top: pointerPositionTop,
  bottom: pointerPositionBottom
};
function TooltipPointer(_ref) {
  var position = _ref.position,
      triggerRect = _ref.triggerRect,
      _ref$style = _ref.style,
      style = _ref$style === void 0 ? {} : _ref$style;
  var getPointerPosition = pointerPosition[position];
  var positionStyle = triggerRect ? getPointerPosition(triggerRect) : {};
  return /*#__PURE__*/React__default.createElement(Portal$1, null, /*#__PURE__*/React__default.createElement("div", {
    style: _objectSpread2({}, positionStyle, {
      position: "absolute",
      width: 0,
      height: 0
    }, style)
  }));
}
var TOOLTIP_POINTER_SIZE = 6;
var TOOLTIP_POINTER_ADJUST = 1;
var pointerBorderTransparent = "".concat(TOOLTIP_POINTER_SIZE, "px solid transparent");
var pointerBorderFilled = "".concat(TOOLTIP_POINTER_SIZE, "px solid black");

function pointerPositionBottom(triggerRect) {
  return {
    borderLeft: pointerBorderTransparent,
    borderRight: pointerBorderTransparent,
    borderBottom: pointerBorderFilled,
    left: getPositionOffsetLeft(triggerRect),
    top: triggerRect.bottom + window.scrollY + TOOLTIP_POINTER_ADJUST
  };
}

function pointerPositionTop(triggerRect) {
  return {
    borderLeft: pointerBorderTransparent,
    borderRight: pointerBorderTransparent,
    borderTop: pointerBorderFilled,
    left: getPositionOffsetLeft(triggerRect),
    top: triggerRect.top - TOOLTIP_POINTER_SIZE + window.scrollY - TOOLTIP_POINTER_ADJUST
  };
}

function getPositionOffsetLeft(triggerRect) {
  return triggerRect.left + triggerRect.width / 2 - TOOLTIP_POINTER_SIZE;
}

TooltipPointer.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "TooltipPointer",
  "props": {
    "style": {
      "defaultValue": {
        "value": "{}",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "ReactCSSProperties",
        "raw": "React.CSSProperties"
      },
      "description": ""
    },
    "triggerRect": {
      "required": true,
      "tsType": {
        "name": "DOMRect"
      },
      "description": ""
    },
    "position": {
      "required": true,
      "tsType": {
        "name": "TooltipPosition"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Tooltip/TooltipPointer.tsx"] = {
    name: "TooltipPointer",
    docgenInfo: TooltipPointer.__docgenInfo,
    path: "src/components/Tooltip/TooltipPointer.tsx"
  };
}

var tooltipPosition = {
  top: positionTop,
  bottom: positionBottom
};
var MIN_WINDOW_SPACING = 4;

function positionBottom(triggerRect, tooltipRect) {
  if (!triggerRect || !tooltipRect) {
    return {};
  }

  var baseTop = triggerRect.bottom + TOOLTIP_POINTER_SIZE;
  return {
    left: normalizeLeft(triggerRect, tooltipRect),
    width: normalizeWidth(triggerRect, tooltipRect),
    top: baseTop + window.scrollY
  };
}

function positionTop(triggerRect, tooltipRect) {
  if (!triggerRect || !tooltipRect) {
    return {};
  }

  var baseTop = triggerRect.top - tooltipRect.height - TOOLTIP_POINTER_SIZE;
  return {
    left: normalizeLeft(triggerRect, tooltipRect),
    width: normalizeWidth(triggerRect, tooltipRect),
    top: baseTop + window.scrollY
  };
}

function normalizeLeft(triggerRect, tooltipRect) {
  var triggerCenter = triggerRect.left + triggerRect.width / 2;
  var left = triggerCenter - tooltipRect.width / 2;
  var maxLeft = window.innerWidth - tooltipRect.width - MIN_WINDOW_SPACING; // Use min-max to avoid the tooltip overflowing the window boundaries

  var optimalLeft = Math.min(Math.max(2, left), maxLeft);
  return optimalLeft + window.scrollX;
}
/**
 * This helper makes sure that the tooltip fits the screen width
 */


function normalizeWidth(triggerRect, tooltipRect) {
  var maxAllowedWidth = window.innerWidth - 2 * MIN_WINDOW_SPACING;

  if (tooltipRect.width <= maxAllowedWidth) {
    return tooltipRect.width;
  }

  return maxAllowedWidth;
}

var baseCss$b = function baseCss(theme) {
  return {
    // defaults from @reach/tooltip
    zIndex: 1,
    pointerEvents: "none",
    position: "absolute",
    boxShadow: "2px 2px 10px hsla(0, 0%, 0%, 0.1)",
    // gatsby-interface styles
    background: theme.colors.black,
    color: theme.colors.whiteFade[80],
    fontSize: theme.fontSizes[1],
    border: "none",
    borderRadius: "2px",
    padding: "".concat(theme.space[2], " ").concat(theme.space[4]),
    transformOrigin: "center",
    whiteSpace: "normal"
  };
};

function TooltipContent$1(_ref) {
  var _ref$position = _ref.position,
      position = _ref$position === void 0 ? "top" : _ref$position,
      label = _ref.label,
      tooltipParams = _ref.tooltipParams,
      ariaLabel = _ref["aria-label"],
      style = _ref.style,
      rest = _objectWithoutProperties(_ref, ["position", "label", "tooltipParams", "aria-label", "style"]);

  return core.jsx(TooltipPopup, _extends({}, tooltipParams, rest, {
    label: core.jsx(React__default.Fragment, null, tooltipParams.triggerRect && core.jsx(TooltipPointer, {
      triggerRect: tooltipParams.triggerRect,
      position: position,
      style: style
    }), label),
    ariaLabel: ariaLabel,
    "aria-label": ariaLabel,
    css: baseCss$b,
    style: style,
    position: tooltipPosition[position]
  }));
}
TooltipContent$1.propTypes = {
  label: _pt__default.node.isRequired
};
TooltipContent$1.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "TooltipContent",
  "props": {
    "position": {
      "defaultValue": {
        "value": "\"top\"",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "TooltipPosition"
      },
      "description": ""
    },
    "label": {
      "required": true,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    },
    "tooltipParams": {
      "required": true,
      "tsType": {
        "name": "TooltipParams"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Tooltip/TooltipContent.tsx"] = {
    name: "TooltipContent",
    docgenInfo: TooltipContent$1.__docgenInfo,
    path: "src/components/Tooltip/TooltipContent.tsx"
  };
}

var AnimatedTooltipContent = extendedAnimated(TooltipContent$1);
var transitionConfig = {
  from: {
    opacity: 0,
    transform: "translateY(10px)"
  },
  enter: {
    opacity: 1,
    transform: "translateY(0px)"
  },
  leave: {
    opacity: 0,
    transform: "translateY(10px)"
  }
};
function Tooltip$1(_ref) {
  var children = _ref.children,
      id = _ref.id,
      label = _ref.label,
      rest = _objectWithoutProperties(_ref, ["children", "id", "label"]);

  // COPIED FROM @reach/tooltip source:
  //
  // We need to pass some properties from the child into useTooltip
  // to make sure users can maintain control over the trigger's ref and events
  var child = React__default.Children.only(children);

  var _useTooltip = useTooltip({
    id: id,
    onMouseEnter: child.props.onMouseEnter,
    onMouseMove: child.props.onMouseMove,
    onMouseLeave: child.props.onMouseLeave,
    onFocus: child.props.onFocus,
    onBlur: child.props.onBlur,
    onKeyDown: child.props.onKeyDown,
    onMouseDown: child.props.onMouseDown,
    ref: child.ref
  }),
      _useTooltip2 = _slicedToArray(_useTooltip, 3),
      trigger = _useTooltip2[0],
      tooltipParams = _useTooltip2[1],
      isVisible = _useTooltip2[2];

  var transitions = useTransition(isVisible ? tooltipParams : null, null, transitionConfig);
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, React__default.cloneElement(child, trigger), transitions.map(function (_ref2) {
    var tooltip = _ref2.item,
        transitionStyles = _ref2.props,
        key = _ref2.key;

    if (!tooltip) {
      return null;
    }

    return /*#__PURE__*/React__default.createElement(AnimatedTooltipContent, _extends({
      key: key,
      label: label,
      tooltipParams: tooltip,
      style: transitionStyles
    }, rest));
  }), /*#__PURE__*/React__default.createElement(DisableReachStyleCheck, {
    reachComponent: "tooltip"
  }));
}
Tooltip$1.propTypes = {
  label: _pt__default.node.isRequired,
  children: _pt__default.node.isRequired
};
Tooltip$1.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "Tooltip",
  "props": {
    "label": {
      "required": true,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    },
    "children": {
      "required": true,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    },
    "position": {
      "required": false,
      "tsType": {
        "name": "TooltipPosition"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Tooltip/Tooltip.tsx"] = {
    name: "Tooltip",
    docgenInfo: Tooltip$1.__docgenInfo,
    path: "src/components/Tooltip/Tooltip.tsx"
  };
}

function SidebarNav(_ref) {
  var options = _ref.options,
      rest = _objectWithoutProperties(_ref, ["options"]);

  return core.jsx("nav", _extends({
    "aria-label": "sidebar navigation",
    css: function css(theme) {
      return {
        paddingLeft: theme.space[8]
      };
    }
  }, rest), options && core.jsx(SidebarNavList, null, options.map(function (option) {
    return core.jsx(SidebarNavListItem, _extends({
      key: option.to
    }, option));
  })));
}
SidebarNav.propTypes = {
  options: _pt__default.arrayOf(_pt__default.oneOfType([_pt__default.shape({
    label: _pt__default.node.isRequired,
    to: _pt__default.string,
    active: _pt__default.bool,
    onClick: _pt__default.func
  }), _pt__default.shape({
    Icon: _pt__default.elementType,
    subItems: _pt__default.arrayOf(_pt__default.shape({
      label: _pt__default.node.isRequired,
      to: _pt__default.string,
      active: _pt__default.bool,
      onClick: _pt__default.func
    }))
  })]))
};

function SidebarNavList(props) {
  return core.jsx("ul", _extends({
    css: [{
      listStyle: "none",
      margin: 0,
      padding: 0
    }]
  }, props));
}

var baseNavItemCss = function baseNavItemCss(theme) {
  return {
    fontFamily: theme.fonts.body,
    fontSize: theme.fontSizes[1],
    fontWeight: theme.fontWeights.body,
    color: theme.colors.grey[60],
    marginBottom: "0",
    "&:first-of-type": {
      paddingTop: "0"
    },
    "&:last-of-type": {
      paddingBottom: "0"
    }
  };
};

var baseNavItemActiveCss = function baseNavItemActiveCss(theme) {
  return {
    color: theme.colors.purple[50],
    fontWeight: theme.fontWeights.semiBold
  };
};

var navItemIconCss = function navItemIconCss(theme) {
  return {
    color: theme.colors.grey[40],
    fontSize: theme.fontSizes[4],
    verticalAlign: "middle",
    position: "absolute",
    left: "-".concat(theme.space[8])
  };
};

var navItemActiveIconCss = function navItemActiveIconCss(theme) {
  return {
    color: theme.colors.purple[40]
  };
};

function SidebarNavListItem(_ref2) {
  var label = _ref2.label,
      to = _ref2.to,
      active = _ref2.active,
      onClick = _ref2.onClick,
      Icon = _ref2.Icon,
      subItems = _ref2.subItems,
      rest = _objectWithoutProperties(_ref2, ["label", "to", "active", "onClick", "Icon", "subItems"]);

  return core.jsx(SidebarBaseItem, _extends({
    css: function css(theme) {
      return [{
        position: "relative",
        padding: "".concat(theme.space[3], " 0")
      }];
    },
    label: core.jsx(React__default.Fragment, null, Icon && core.jsx(Icon, {
      css: function css(theme) {
        return [navItemIconCss(theme), active && navItemActiveIconCss(theme)];
      },
      size: "inherit"
    }), label),
    to: to,
    active: active,
    onClick: onClick,
    current: active ? "page" : undefined
  }, rest), subItems && active && core.jsx(SidebarNavList, {
    css: function css(theme) {
      return {
        paddingTop: theme.space[5],
        paddingBottom: theme.space[3]
      };
    }
  }, subItems.map(function (subItem) {
    return core.jsx(SidebarBaseItem, _extends({
      key: subItem.to,
      css: function css(theme) {
        return [{
          paddingTop: theme.space[3],
          paddingRight: theme.space[5],
          paddingBottom: theme.space[3],
          paddingLeft: "calc(".concat(theme.space[6], " + 1px)"),
          marginBottom: "0",
          marginLeft: "calc(-".concat(theme.space[6], " - 2px)"),
          borderLeft: "1px solid ".concat(theme.colors.grey[30])
        }, subItem.active && {
          borderLeftColor: theme.colors.purple[50]
        }];
      },
      current: subItem.active ? "location" : undefined
    }, subItem));
  })));
}

SidebarNavListItem.propTypes = {
  label: _pt__default.node.isRequired,
  to: _pt__default.string,
  active: _pt__default.bool,
  onClick: _pt__default.func,
  Icon: _pt__default.elementType,
  subItems: _pt__default.arrayOf(_pt__default.shape({
    label: _pt__default.node.isRequired,
    to: _pt__default.string,
    active: _pt__default.bool,
    onClick: _pt__default.func
  }))
};

var itemLinkCss$1 = function itemLinkCss(theme) {
  return {
    color: "inherit",
    lineHeight: theme.lineHeights.dense,
    textDecoration: "none"
  };
};

function SidebarBaseItem(_ref3) {
  var children = _ref3.children,
      label = _ref3.label,
      to = _ref3.to,
      active = _ref3.active,
      onClick = _ref3.onClick,
      current = _ref3.current,
      rest = _objectWithoutProperties(_ref3, ["children", "label", "to", "active", "onClick", "current"]);

  return core.jsx("li", _extends({
    css: function css(theme) {
      return [baseNavItemCss(theme), active && baseNavItemActiveCss(theme)];
    }
  }, rest), to ? core.jsx(gatsby.Link, {
    to: to,
    onClick: onClick,
    css: itemLinkCss$1,
    "aria-current": current
  }, label) : label, children);
}

SidebarBaseItem.propTypes = {
  label: _pt__default.node.isRequired,
  to: _pt__default.string,
  active: _pt__default.bool,
  onClick: _pt__default.func,
  current: _pt__default.oneOf(["page", "location"])
};
SidebarNav.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "SidebarNav",
  "props": {
    "options": {
      "required": false,
      "tsType": {
        "name": "Array",
        "elements": [{
          "name": "intersection",
          "raw": "SidebarNavItem & {\n  Icon?: React.ComponentType<any>\n  subItems?: SidebarNavItem[]\n}",
          "elements": [{
            "name": "signature",
            "type": "object",
            "raw": "{\n  label: React.ReactNode\n  to?: string\n  active?: boolean\n  onClick?: React.MouseEventHandler<HTMLAnchorElement>\n}",
            "signature": {
              "properties": [{
                "key": "label",
                "value": {
                  "name": "ReactReactNode",
                  "raw": "React.ReactNode",
                  "required": true
                }
              }, {
                "key": "to",
                "value": {
                  "name": "string",
                  "required": false
                }
              }, {
                "key": "active",
                "value": {
                  "name": "boolean",
                  "required": false
                }
              }, {
                "key": "onClick",
                "value": {
                  "name": "ReactMouseEventHandler",
                  "raw": "React.MouseEventHandler<HTMLAnchorElement>",
                  "elements": [{
                    "name": "HTMLAnchorElement"
                  }],
                  "required": false
                }
              }]
            }
          }, {
            "name": "signature",
            "type": "object",
            "raw": "{\n  Icon?: React.ComponentType<any>\n  subItems?: SidebarNavItem[]\n}",
            "signature": {
              "properties": [{
                "key": "Icon",
                "value": {
                  "name": "ReactComponentType",
                  "raw": "React.ComponentType<any>",
                  "elements": [{
                    "name": "any"
                  }],
                  "required": false
                }
              }, {
                "key": "subItems",
                "value": {
                  "name": "Array",
                  "elements": [{
                    "name": "signature",
                    "type": "object",
                    "raw": "{\n  label: React.ReactNode\n  to?: string\n  active?: boolean\n  onClick?: React.MouseEventHandler<HTMLAnchorElement>\n}",
                    "signature": {
                      "properties": [{
                        "key": "label",
                        "value": {
                          "name": "ReactReactNode",
                          "raw": "React.ReactNode",
                          "required": true
                        }
                      }, {
                        "key": "to",
                        "value": {
                          "name": "string",
                          "required": false
                        }
                      }, {
                        "key": "active",
                        "value": {
                          "name": "boolean",
                          "required": false
                        }
                      }, {
                        "key": "onClick",
                        "value": {
                          "name": "ReactMouseEventHandler",
                          "raw": "React.MouseEventHandler<HTMLAnchorElement>",
                          "elements": [{
                            "name": "HTMLAnchorElement"
                          }],
                          "required": false
                        }
                      }]
                    }
                  }],
                  "raw": "SidebarNavItem[]",
                  "required": false
                }
              }]
            }
          }]
        }],
        "raw": "SidebarNavOption[]"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/SidebarNav/SidebarNav.tsx"] = {
    name: "SidebarNav",
    docgenInfo: SidebarNav.__docgenInfo,
    path: "src/components/SidebarNav/SidebarNav.tsx"
  };
}

function _extends$6() {
  _extends$6 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$6.apply(this, arguments);
}

function _objectWithoutPropertiesLoose$8(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function createDescendantContext(name, initialValue) {
  if (initialValue === void 0) {
    initialValue = {};
  }

  var descendants = [];
  return createNamedContext(name, _extends$6({
    descendants: descendants,
    registerDescendant: noop,
    unregisterDescendant: noop
  }, initialValue));
}
/**
 * This hook registers our descendant by passing it into an array. We can then
 * search that array by to find its index when registering it in the component.
 * We use this for focus management, keyboard navigation, and typeahead
 * functionality for some components.
 *
 * The hook accepts the element node and (optionally) a key. The key is useful
 * if multiple descendants have identical text values and we need to
 * differentiate siblings for some reason.
 *
 * Our main goals with this are:
 *   1) maximum composability,
 *   2) minimal API friction
 *   3) SSR compatibility*
 *   4) concurrent safe
 *   5) index always up-to-date with the tree despite changes
 *   6) works with memoization of any component in the tree (hopefully)
 *
 * * As for SSR, the good news is that we don't actually need the index on the
 * server for most use-cases, as we are only using it to determine the order of
 * composed descendants for keyboard navigation. However, in the few cases where
 * this is not the case, we can require an explicit index from the app.
 */

function useDescendant(descendant, context, indexProp) {
  var _useState = React.useState(),
      forceUpdate = _useState[1];

  var _useContext = React.useContext(context),
      registerDescendant = _useContext.registerDescendant,
      unregisterDescendant = _useContext.unregisterDescendant,
      descendants = _useContext.descendants; // Prevent any flashing


  useIsomorphicLayoutEffect(function () {
    if (!descendant.element) forceUpdate({});
    registerDescendant(_extends$6(_extends$6({}, descendant), {}, {
      index: indexProp
    }));
    return function () {
      return unregisterDescendant(descendant.element);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [].concat(Object.values(descendant)));
  return indexProp !== null && indexProp !== void 0 ? indexProp : descendants.findIndex(function (item) {
    return item.element === descendant.element;
  });
}
function useDescendantsInit() {
  return React.useState([]);
}
function useDescendants(ctx) {
  return React.useContext(ctx).descendants;
}
function DescendantProvider(_ref) {
  var Ctx = _ref.context,
      children = _ref.children,
      items = _ref.items,
      set = _ref.set;
  var registerDescendant = React.useCallback(function (_ref2) {
    var element = _ref2.element,
        explicitIndex = _ref2.index,
        rest = _objectWithoutPropertiesLoose$8(_ref2, ["element", "index"]);

    if (!element) {
      return;
    }

    set(function (items) {
      var newItems;

      if (explicitIndex != null) {
        newItems = [].concat(items, [_extends$6(_extends$6({}, rest), {}, {
          element: element,
          index: explicitIndex
        })]);
      } else if (items.length === 0) {
        // If there are no items, register at index 0 and bail.
        newItems = [].concat(items, [_extends$6(_extends$6({}, rest), {}, {
          element: element,
          index: 0
        })]);
      } else if (items.find(function (item) {
        return item.element === element;
      })) {
        // If the element is already registered, just use the same array
        newItems = items;
      } else {
        // When registering a descendant, we need to make sure we insert in
        // into the array in the same order that it appears in the DOM. So as
        // new descendants are added or maybe some are removed, we always know
        // that the array is up-to-date and correct.
        //
        // So here we look at our registered descendants and see if the new
        // element we are adding appears earlier than an existing descendant's
        // DOM node via `node.compareDocumentPosition`. If it does, we insert
        // the new element at this index. Because `registerDescendant` will be
        // called in an effect every time the descendants state value changes,
        // we should be sure that this index is accurate when descendent
        // elements come or go from our component.
        var index = items.findIndex(function (item) {
          if (!item.element || !element) {
            return false;
          } // Does this element's DOM node appear before another item in the
          // array in our DOM tree? If so, return true to grab the index at
          // this point in the array so we know where to insert the new
          // element.


          return Boolean(item.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING);
        });

        var newItem = _extends$6(_extends$6({}, rest), {}, {
          element: element,
          index: index
        }); // If an index is not found we will push the element to the end.


        if (index === -1) {
          newItems = [].concat(items, [newItem]);
        } else {
          newItems = [].concat(items.slice(0, index), [newItem], items.slice(index));
        }
      }

      return newItems.map(function (item, index) {
        return _extends$6(_extends$6({}, item), {}, {
          index: index
        });
      });
    });
  }, // set is a state setter initialized by the useDescendants hook.
  // We can safely ignore the lint warning here because it will not change
  // between renders.
  // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  var unregisterDescendant = React.useCallback(function (element) {
    if (!element) {
      return;
    }

    set(function (items) {
      return items.filter(function (item) {
        return element !== item.element;
      });
    });
  }, // set is a state setter initialized by the useDescendants hook.
  // We can safely ignore the lint warning here because it will not change
  // between renders.
  // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  return React__default.createElement(Ctx.Provider, {
    value: React.useMemo(function () {
      return {
        descendants: items,
        registerDescendant: registerDescendant,
        unregisterDescendant: unregisterDescendant
      };
    }, [items, registerDescendant, unregisterDescendant])
  }, children);
}
/**
 * Testing this as an abstraction for compound components that use keyboard
 * navigation. Hoping this will help us prevent bugs and mismatched behavior
 * across various components, but it may also prove to be too messy of an
 * abstraction in the end.
 *
 * Currently used in:
 *   - Tabs
 *   - Accordion
 *
 * @param context
 * @param options
 */

function useDescendantKeyDown(context, options) {
  var _useContext2 = React.useContext(context),
      descendants = _useContext2.descendants;

  var callback = options.callback,
      currentIndex = options.currentIndex,
      filter = options.filter,
      _options$key = options.key,
      key = _options$key === void 0 ? "index" : _options$key,
      _options$orientation = options.orientation,
      orientation = _options$orientation === void 0 ? "vertical" : _options$orientation,
      _options$rotate = options.rotate,
      rotate = _options$rotate === void 0 ? true : _options$rotate,
      _options$rtl = options.rtl,
      rtl = _options$rtl === void 0 ? false : _options$rtl;
  var index = currentIndex !== null && currentIndex !== void 0 ? currentIndex : -1;
  return function handleKeyDown(event) {
    if (!["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight", "PageUp", "PageDown", "Home", "End"].includes(event.key)) {
      return;
    } // If we use a filter function, we need to re-index our descendants array
    // so that filtered descendent elements aren't selected.


    var selectableDescendants = filter ? descendants.filter(filter) : descendants; // Current index should map to the updated array vs. the original
    // descendants array.

    if (filter) {
      index = selectableDescendants.findIndex(function (descendant) {
        return descendant.index === currentIndex;
      });
    } // We need some options for any of this to work!


    if (!selectableDescendants.length) {
      return;
    }

    function getNextOption() {
      var atBottom = index === selectableDescendants.length - 1;
      return atBottom ? rotate ? getFirstOption() : selectableDescendants[index] : selectableDescendants[(index + 1) % selectableDescendants.length];
    }

    function getPreviousOption() {
      var atTop = index === 0;
      return atTop ? rotate ? getLastOption() : selectableDescendants[index] : selectableDescendants[(index - 1 + selectableDescendants.length) % selectableDescendants.length];
    }

    function getFirstOption() {
      return selectableDescendants[0];
    }

    function getLastOption() {
      return selectableDescendants[selectableDescendants.length - 1];
    }

    switch (event.key) {
      case "ArrowDown":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          var next = getNextOption();
          callback(key === "option" ? next : next[key]);
        }

        break;

      case "ArrowUp":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          var prev = getPreviousOption();
          callback(key === "option" ? prev : prev[key]);
        }

        break;

      case "ArrowLeft":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          var nextOrPrev = (rtl ? getNextOption : getPreviousOption)();
          callback(key === "option" ? nextOrPrev : nextOrPrev[key]);
        }

        break;

      case "ArrowRight":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          var prevOrNext = (rtl ? getPreviousOption : getNextOption)();
          callback(key === "option" ? prevOrNext : prevOrNext[key]);
        }

        break;

      case "PageUp":
        event.preventDefault();
        var prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();
        callback(key === "option" ? prevOrFirst : prevOrFirst[key]);
        break;

      case "Home":
        event.preventDefault();
        var first = getFirstOption();
        callback(key === "option" ? first : first[key]);
        break;

      case "PageDown":
        event.preventDefault();
        var nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();
        callback(key === "option" ? nextOrLast : nextOrLast[key]);
        break;

      case "End":
        event.preventDefault();
        var last = getLastOption();
        callback(key === "option" ? last : last[key]);
        break;
    }
  };
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var dist = createCommonjsModule(function (module) {
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _utils = __webpack_require__(2);
	
	Object.defineProperty(exports, 'combineChunks', {
	  enumerable: true,
	  get: function get() {
	    return _utils.combineChunks;
	  }
	});
	Object.defineProperty(exports, 'fillInChunks', {
	  enumerable: true,
	  get: function get() {
	    return _utils.fillInChunks;
	  }
	});
	Object.defineProperty(exports, 'findAll', {
	  enumerable: true,
	  get: function get() {
	    return _utils.findAll;
	  }
	});
	Object.defineProperty(exports, 'findChunks', {
	  enumerable: true,
	  get: function get() {
	    return _utils.findChunks;
	  }
	});

/***/ }),
/* 2 */
/***/ (function(module, exports) {
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	
	/**
	 * Creates an array of chunk objects representing both higlightable and non highlightable pieces of text that match each search word.
	 * @return Array of "chunks" (where a Chunk is { start:number, end:number, highlight:boolean })
	 */
	var findAll = exports.findAll = function findAll(_ref) {
	  var autoEscape = _ref.autoEscape,
	      _ref$caseSensitive = _ref.caseSensitive,
	      caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive,
	      _ref$findChunks = _ref.findChunks,
	      findChunks = _ref$findChunks === undefined ? defaultFindChunks : _ref$findChunks,
	      sanitize = _ref.sanitize,
	      searchWords = _ref.searchWords,
	      textToHighlight = _ref.textToHighlight;
	  return fillInChunks({
	    chunksToHighlight: combineChunks({
	      chunks: findChunks({
	        autoEscape: autoEscape,
	        caseSensitive: caseSensitive,
	        sanitize: sanitize,
	        searchWords: searchWords,
	        textToHighlight: textToHighlight
	      })
	    }),
	    totalLength: textToHighlight ? textToHighlight.length : 0
	  });
	};
	
	/**
	 * Takes an array of {start:number, end:number} objects and combines chunks that overlap into single chunks.
	 * @return {start:number, end:number}[]
	 */
	
	
	var combineChunks = exports.combineChunks = function combineChunks(_ref2) {
	  var chunks = _ref2.chunks;
	
	  chunks = chunks.sort(function (first, second) {
	    return first.start - second.start;
	  }).reduce(function (processedChunks, nextChunk) {
	    // First chunk just goes straight in the array...
	    if (processedChunks.length === 0) {
	      return [nextChunk];
	    } else {
	      // ... subsequent chunks get checked to see if they overlap...
	      var prevChunk = processedChunks.pop();
	      if (nextChunk.start <= prevChunk.end) {
	        // It may be the case that prevChunk completely surrounds nextChunk, so take the
	        // largest of the end indeces.
	        var endIndex = Math.max(prevChunk.end, nextChunk.end);
	        processedChunks.push({ highlight: false, start: prevChunk.start, end: endIndex });
	      } else {
	        processedChunks.push(prevChunk, nextChunk);
	      }
	      return processedChunks;
	    }
	  }, []);
	
	  return chunks;
	};
	
	/**
	 * Examine text for any matches.
	 * If we find matches, add them to the returned array as a "chunk" object ({start:number, end:number}).
	 * @return {start:number, end:number}[]
	 */
	var defaultFindChunks = function defaultFindChunks(_ref3) {
	  var autoEscape = _ref3.autoEscape,
	      caseSensitive = _ref3.caseSensitive,
	      _ref3$sanitize = _ref3.sanitize,
	      sanitize = _ref3$sanitize === undefined ? defaultSanitize : _ref3$sanitize,
	      searchWords = _ref3.searchWords,
	      textToHighlight = _ref3.textToHighlight;
	
	  textToHighlight = sanitize(textToHighlight);
	
	  return searchWords.filter(function (searchWord) {
	    return searchWord;
	  }) // Remove empty words
	  .reduce(function (chunks, searchWord) {
	    searchWord = sanitize(searchWord);
	
	    if (autoEscape) {
	      searchWord = escapeRegExpFn(searchWord);
	    }
	
	    var regex = new RegExp(searchWord, caseSensitive ? 'g' : 'gi');
	
	    var match = void 0;
	    while (match = regex.exec(textToHighlight)) {
	      var _start = match.index;
	      var _end = regex.lastIndex;
	      // We do not return zero-length matches
	      if (_end > _start) {
	        chunks.push({ highlight: false, start: _start, end: _end });
	      }
	
	      // Prevent browsers like Firefox from getting stuck in an infinite loop
	      // See http://www.regexguru.com/2008/04/watch-out-for-zero-length-matches/
	      if (match.index === regex.lastIndex) {
	        regex.lastIndex++;
	      }
	    }
	
	    return chunks;
	  }, []);
	};
	// Allow the findChunks to be overridden in findAll,
	// but for backwards compatibility we export as the old name
	exports.findChunks = defaultFindChunks;
	
	/**
	 * Given a set of chunks to highlight, create an additional set of chunks
	 * to represent the bits of text between the highlighted text.
	 * @param chunksToHighlight {start:number, end:number}[]
	 * @param totalLength number
	 * @return {start:number, end:number, highlight:boolean}[]
	 */
	
	var fillInChunks = exports.fillInChunks = function fillInChunks(_ref4) {
	  var chunksToHighlight = _ref4.chunksToHighlight,
	      totalLength = _ref4.totalLength;
	
	  var allChunks = [];
	  var append = function append(start, end, highlight) {
	    if (end - start > 0) {
	      allChunks.push({
	        start: start,
	        end: end,
	        highlight: highlight
	      });
	    }
	  };
	
	  if (chunksToHighlight.length === 0) {
	    append(0, totalLength, false);
	  } else {
	    var lastIndex = 0;
	    chunksToHighlight.forEach(function (chunk) {
	      append(lastIndex, chunk.start, false);
	      append(chunk.start, chunk.end, true);
	      lastIndex = chunk.end;
	    });
	    append(lastIndex, totalLength, false);
	  }
	  return allChunks;
	};
	
	function defaultSanitize(string) {
	  return string;
	}
	
	function escapeRegExpFn(string) {
	  return string.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
	}

/***/ })
/******/ ]);

});

unwrapExports(dist);
var dist_1 = dist.findAll;

var candidateSelectors = [
  'input',
  'select',
  'textarea',
  'a[href]',
  'button',
  '[tabindex]',
  'audio[controls]',
  'video[controls]',
  '[contenteditable]:not([contenteditable="false"])',
];
var candidateSelector = candidateSelectors.join(',');

var matches = typeof Element === 'undefined'
  ? function () {}
  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

function tabbable(el, options) {
  options = options || {};

  var regularTabbables = [];
  var orderedTabbables = [];

  var candidates = el.querySelectorAll(candidateSelector);

  if (options.includeContainer) {
    if (matches.call(el, candidateSelector)) {
      candidates = Array.prototype.slice.apply(candidates);
      candidates.unshift(el);
    }
  }

  var i, candidate, candidateTabindex;
  for (i = 0; i < candidates.length; i++) {
    candidate = candidates[i];

    if (!isNodeMatchingSelectorTabbable(candidate)) continue;

    candidateTabindex = getTabindex(candidate);
    if (candidateTabindex === 0) {
      regularTabbables.push(candidate);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        node: candidate,
      });
    }
  }

  var tabbableNodes = orderedTabbables
    .sort(sortOrderedTabbables)
    .map(function(a) { return a.node })
    .concat(regularTabbables);

  return tabbableNodes;
}

tabbable.isTabbable = isTabbable;
tabbable.isFocusable = isFocusable;

function isNodeMatchingSelectorTabbable(node) {
  if (
    !isNodeMatchingSelectorFocusable(node)
    || isNonTabbableRadio(node)
    || getTabindex(node) < 0
  ) {
    return false;
  }
  return true;
}

function isTabbable(node) {
  if (!node) throw new Error('No node provided');
  if (matches.call(node, candidateSelector) === false) return false;
  return isNodeMatchingSelectorTabbable(node);
}

function isNodeMatchingSelectorFocusable(node) {
  if (
    node.disabled
    || isHiddenInput(node)
    || isHidden(node)
  ) {
    return false;
  }
  return true;
}

var focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');
function isFocusable(node) {
  if (!node) throw new Error('No node provided');
  if (matches.call(node, focusableCandidateSelector) === false) return false;
  return isNodeMatchingSelectorFocusable(node);
}

function getTabindex(node) {
  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);
  if (!isNaN(tabindexAttr)) return tabindexAttr;
  // Browsers do not return `tabIndex` correctly for contentEditable nodes;
  // so if they don't have a tabindex attribute specifically set, assume it's 0.
  if (isContentEditable(node)) return 0;
  return node.tabIndex;
}

function sortOrderedTabbables(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
}

function isContentEditable(node) {
  return node.contentEditable === 'true';
}

function isInput(node) {
  return node.tagName === 'INPUT';
}

function isHiddenInput(node) {
  return isInput(node) && node.type === 'hidden';
}

function isRadio$1(node) {
  return isInput(node) && node.type === 'radio';
}

function isNonTabbableRadio(node) {
  return isRadio$1(node) && !isTabbableRadio(node);
}

function getCheckedRadio(nodes) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked) {
      return nodes[i];
    }
  }
}

function isTabbableRadio(node) {
  if (!node.name) return true;
  // This won't account for the edge case where you have radio groups with the same
  // in separate forms on the same page.
  var radioSet = node.ownerDocument.querySelectorAll('input[type="radio"][name="' + node.name + '"]');
  var checked = getCheckedRadio(radioSet);
  return !checked || checked === node;
}

function isHidden(node) {
  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,
  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.
  return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';
}

var tabbable_1 = tabbable;

function _extends$7() {
  _extends$7 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$7.apply(this, arguments);
}

function _objectWithoutPropertiesLoose$9(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/**
 * Popover
 */

var Popover = /*#__PURE__*/React.forwardRef(function Popover(props, ref) {
  return React__default.createElement(Portal, null, React__default.createElement(PopoverImpl, Object.assign({
    ref: ref
  }, props)));
});

if (process.env.NODE_ENV !== "production") {
  Popover.displayName = "Popover";
}

/**
 * PopoverImpl
 *
 * Popover is conditionally rendered so we can't start measuring until it shows
 * up, so useRect needs to live down here not up in Popover
 */

var PopoverImpl = /*#__PURE__*/React.forwardRef(function PopoverImpl(_ref, forwardedRef) {
  var targetRef = _ref.targetRef,
      _ref$position = _ref.position,
      position = _ref$position === void 0 ? positionDefault$1 : _ref$position,
      _ref$unstable_observa = _ref.unstable_observableRefs,
      unstable_observableRefs = _ref$unstable_observa === void 0 ? [] : _ref$unstable_observa,
      props = _objectWithoutPropertiesLoose$9(_ref, ["targetRef", "position", "unstable_observableRefs"]);

  var popoverRef = React.useRef(null);
  var popoverRect = useRect(popoverRef);
  var targetRect = useRect(targetRef);
  var ref = useForkedRef(popoverRef, forwardedRef);
  useSimulateTabNavigationForReactTree(targetRef, popoverRef);
  return React__default.createElement("div", Object.assign({
    "data-reach-popover": "",
    ref: ref
  }, props, {
    style: _extends$7(_extends$7({
      position: "absolute"
    }, getStyles$2.apply(void 0, [position, targetRect, popoverRect].concat(unstable_observableRefs))), props.style)
  }));
});

if (process.env.NODE_ENV !== "production") {
  PopoverImpl.displayName = "PopoverImpl";
} ////////////////////////////////////////////////////////////////////////////////


function getStyles$2(position, targetRect, popoverRect) {
  var needToMeasurePopup = !popoverRect;

  if (needToMeasurePopup) {
    return {
      visibility: "hidden"
    };
  }

  for (var _len = arguments.length, unstable_observableRefs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    unstable_observableRefs[_key - 3] = arguments[_key];
  }

  return position.apply(void 0, [targetRect, popoverRect].concat(unstable_observableRefs.map(function (ref) {
    return ref.current;
  })));
}

function getTopPosition(targetRect, popoverRect) {
  var _getCollisions = getCollisions(targetRect, popoverRect),
      directionUp = _getCollisions.directionUp;

  return {
    top: directionUp ? targetRect.top - popoverRect.height + window.pageYOffset + "px" : targetRect.top + targetRect.height + window.pageYOffset + "px"
  };
}

var positionDefault$1 = function positionDefault(targetRect, popoverRect) {
  if (!targetRect || !popoverRect) {
    return {};
  }

  var _getCollisions2 = getCollisions(targetRect, popoverRect),
      directionRight = _getCollisions2.directionRight;

  return _extends$7({
    left: directionRight ? targetRect.right - popoverRect.width + window.pageXOffset + "px" : targetRect.left + window.pageXOffset + "px"
  }, getTopPosition(targetRect, popoverRect));
};
var positionMatchWidth = function positionMatchWidth(targetRect, popoverRect) {
  if (!targetRect || !popoverRect) {
    return {};
  }

  return _extends$7({
    width: targetRect.width,
    left: targetRect.left
  }, getTopPosition(targetRect, popoverRect));
};
function getCollisions(targetRect, popoverRect, offsetLeft, offsetBottom) {
  if (offsetLeft === void 0) {
    offsetLeft = 0;
  }

  if (offsetBottom === void 0) {
    offsetBottom = 0;
  }

  var collisions = {
    top: targetRect.top - popoverRect.height < 0,
    right: window.innerWidth < targetRect.left + popoverRect.width - offsetLeft,
    bottom: window.innerHeight < targetRect.bottom + popoverRect.height - offsetBottom,
    left: targetRect.left + targetRect.width - popoverRect.width < 0
  };
  var directionRight = collisions.right && !collisions.left;
  var directionLeft = collisions.left && !collisions.right;
  var directionUp = collisions.bottom && !collisions.top;
  var directionDown = collisions.top && !collisions.bottom;
  return {
    directionRight: directionRight,
    directionLeft: directionLeft,
    directionUp: directionUp,
    directionDown: directionDown
  };
} // Heads up, my jQuery past haunts this function. This hook scopes the tab
// order to the React element tree, instead of the DOM tree. This way, when the
// user navigates with tab from the targetRef, the tab order moves into the
// popup, and then out of the popup back to the rest of the document.
// (We call targetRef, triggerRef inside this function to avoid confusion with
// event.target)

function useSimulateTabNavigationForReactTree(triggerRef, popoverRef) {
  var ownerDocument = getOwnerDocument(triggerRef.current);

  function handleKeyDown(event) {
    if (event.key === "Tab" && popoverRef.current && tabbable_1(popoverRef.current).length === 0) {
      return;
    }

    if (event.key === "Tab" && event.shiftKey) {
      if (shiftTabbedFromElementAfterTrigger(event)) {
        focusLastTabbableInPopover(event);
      } else if (shiftTabbedOutOfPopover(event)) {
        focusTriggerRef(event);
      } else if (shiftTabbedToBrowserChrome(event)) {
        disableTabbablesInPopover();
      }
    } else if (event.key === "Tab") {
      if (tabbedFromTriggerToPopover()) {
        focusFirstPopoverTabbable(event);
      } else if (tabbedOutOfPopover()) {
        focusTabbableAfterTrigger(event);
      } else if (tabbedToBrowserChrome(event)) {
        disableTabbablesInPopover();
      }
    }
  }

  React.useEffect(function () {
    if (ownerDocument) {
      ownerDocument.addEventListener("keydown", handleKeyDown);
      return function () {
        ownerDocument.removeEventListener("keydown", handleKeyDown);
      };
    }

    return; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  function getElementAfterTrigger() {
    var elements = ownerDocument && tabbable_1(ownerDocument);
    var targetIndex = elements && triggerRef.current ? elements.indexOf(triggerRef.current) : -1;
    return elements && elements[targetIndex + 1];
  }

  function tabbedFromTriggerToPopover() {
    return triggerRef.current && ownerDocument ? triggerRef.current === ownerDocument.activeElement : false;
  }

  function focusFirstPopoverTabbable(event) {
    var elements = popoverRef.current && tabbable_1(popoverRef.current);

    if (elements && elements[0]) {
      event.preventDefault();
      elements[0].focus();
    }
  }

  function tabbedOutOfPopover() {
    var inPopover = popoverRef.current && ownerDocument ? popoverRef.current.contains(ownerDocument.activeElement || null) : false;

    if (inPopover) {
      var elements = popoverRef.current && tabbable_1(popoverRef.current);
      return Boolean(elements && ownerDocument && elements[elements.length - 1] === ownerDocument.activeElement);
    }

    return false;
  }

  function focusTabbableAfterTrigger(event) {
    var elementAfterTrigger = getElementAfterTrigger();

    if (elementAfterTrigger) {
      event.preventDefault();
      elementAfterTrigger.focus();
    }
  }

  function shiftTabbedFromElementAfterTrigger(event) {
    if (!event.shiftKey) return;
    var elementAfterTrigger = getElementAfterTrigger();
    return event.target === elementAfterTrigger;
  }

  function focusLastTabbableInPopover(event) {
    var elements = popoverRef.current && tabbable_1(popoverRef.current);
    var last = elements && elements[elements.length - 1];

    if (last) {
      event.preventDefault();
      last.focus();
    }
  }

  function shiftTabbedOutOfPopover(event) {
    var elements = popoverRef.current && tabbable_1(popoverRef.current);

    if (elements) {
      return elements.length === 0 ? false : event.target === elements[0];
    }

    return false;
  }

  function focusTriggerRef(event) {
    var _triggerRef$current;

    event.preventDefault();
    (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.focus();
  }

  function tabbedToBrowserChrome(event) {
    var elements = ownerDocument && popoverRef.current ? tabbable_1(ownerDocument).filter(function (element) {
      return !popoverRef.current.contains(element);
    }) : null;
    return elements ? event.target === elements[elements.length - 1] : false;
  }

  function shiftTabbedToBrowserChrome(event) {
    // we're assuming the popover will never contain the first tabbable
    // element, and it better not, because the trigger needs to be tabbable!
    return ownerDocument ? event.target === tabbable_1(ownerDocument)[0] : false;
  }

  var restoreTabIndexTupls = [];

  function disableTabbablesInPopover() {
    var elements = popoverRef.current && tabbable_1(popoverRef.current);

    if (elements) {
      elements.forEach(function (element) {
        restoreTabIndexTupls.push([element, element.tabIndex]);
        element.tabIndex = -1;
      });
      ownerDocument && ownerDocument.addEventListener("focusin", enableTabbablesInPopover);
    }
  }

  function enableTabbablesInPopover() {
    ownerDocument && ownerDocument.removeEventListener("focusin", enableTabbablesInPopover);
    restoreTabIndexTupls.forEach(function (_ref2) {
      var element = _ref2[0],
          tabIndex = _ref2[1];
      element.tabIndex = tabIndex;
    });
  }
}

function _extends$8() {
  _extends$8 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$8.apply(this, arguments);
}

function _objectWithoutPropertiesLoose$a(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var _on$1, _on2$1, _on3$1, _on4$1, _states$1;
// States
// Nothing going on, waiting for the user to type or use the arrow keys

var IDLE$1 = "IDLE"; // The component is suggesting options as the user types

var SUGGESTING = "SUGGESTING"; // The user is using the keyboard to navigate the list, not typing

var NAVIGATING = "NAVIGATING"; // The user is interacting with arbitrary elements inside the popup that
// are not ComboboxInputs

var INTERACTING = "INTERACTING"; ////////////////////////////////////////////////////////////////////////////////
// Events
// User cleared the value w/ backspace, but input still has focus

var CLEAR = "CLEAR"; // User is typing

var CHANGE = "CHANGE"; // Initial input value change handler for syncing user state with state machine
// Prevents initial change from sending the user to the NAVIGATING state
// https://github.com/reach/reach-ui/issues/464

var INITIAL_CHANGE = "INITIAL_CHANGE"; // User is navigating w/ the keyboard

var NAVIGATE = "NAVIGATE"; // User can be navigating with keyboard and then click instead, we want the
// value from the click, not the current nav item

var SELECT_WITH_KEYBOARD$1 = "SELECT_WITH_KEYBOARD";
var SELECT_WITH_CLICK = "SELECT_WITH_CLICK"; // Pretty self-explanatory, user can hit escape or blur to close the popover

var ESCAPE = "ESCAPE";
var BLUR$1 = "BLUR"; // The user left the input to interact with arbitrary elements inside the popup

var INTERACT = "INTERACT";
var FOCUS$1 = "FOCUS";
var OPEN_WITH_BUTTON = "OPEN_WITH_BUTTON";
var CLOSE_WITH_BUTTON = "CLOSE_WITH_BUTTON"; ////////////////////////////////////////////////////////////////////////////////

var stateChart = {
  initial: IDLE$1,
  states: (_states$1 = {}, _states$1[IDLE$1] = {
    on: (_on$1 = {}, _on$1[BLUR$1] = IDLE$1, _on$1[CLEAR] = IDLE$1, _on$1[CHANGE] = SUGGESTING, _on$1[INITIAL_CHANGE] = IDLE$1, _on$1[FOCUS$1] = SUGGESTING, _on$1[NAVIGATE] = NAVIGATING, _on$1[OPEN_WITH_BUTTON] = SUGGESTING, _on$1)
  }, _states$1[SUGGESTING] = {
    on: (_on2$1 = {}, _on2$1[CHANGE] = SUGGESTING, _on2$1[FOCUS$1] = SUGGESTING, _on2$1[NAVIGATE] = NAVIGATING, _on2$1[CLEAR] = IDLE$1, _on2$1[ESCAPE] = IDLE$1, _on2$1[BLUR$1] = IDLE$1, _on2$1[SELECT_WITH_CLICK] = IDLE$1, _on2$1[INTERACT] = INTERACTING, _on2$1[CLOSE_WITH_BUTTON] = IDLE$1, _on2$1)
  }, _states$1[NAVIGATING] = {
    on: (_on3$1 = {}, _on3$1[CHANGE] = SUGGESTING, _on3$1[FOCUS$1] = SUGGESTING, _on3$1[CLEAR] = IDLE$1, _on3$1[BLUR$1] = IDLE$1, _on3$1[ESCAPE] = IDLE$1, _on3$1[NAVIGATE] = NAVIGATING, _on3$1[SELECT_WITH_CLICK] = IDLE$1, _on3$1[SELECT_WITH_KEYBOARD$1] = IDLE$1, _on3$1[CLOSE_WITH_BUTTON] = IDLE$1, _on3$1[INTERACT] = INTERACTING, _on3$1)
  }, _states$1[INTERACTING] = {
    on: (_on4$1 = {}, _on4$1[CLEAR] = IDLE$1, _on4$1[CHANGE] = SUGGESTING, _on4$1[FOCUS$1] = SUGGESTING, _on4$1[BLUR$1] = IDLE$1, _on4$1[ESCAPE] = IDLE$1, _on4$1[NAVIGATE] = NAVIGATING, _on4$1[CLOSE_WITH_BUTTON] = IDLE$1, _on4$1[SELECT_WITH_CLICK] = IDLE$1, _on4$1)
  }, _states$1)
};

var reducer = function reducer(data, event) {
  var nextState = _extends$8(_extends$8({}, data), {}, {
    lastEventType: event.type
  });

  switch (event.type) {
    case CHANGE:
    case INITIAL_CHANGE:
      return _extends$8(_extends$8({}, nextState), {}, {
        navigationValue: null,
        value: event.value
      });

    case NAVIGATE:
    case OPEN_WITH_BUTTON:
      return _extends$8(_extends$8({}, nextState), {}, {
        navigationValue: findNavigationValue(nextState, event)
      });

    case CLEAR:
      return _extends$8(_extends$8({}, nextState), {}, {
        value: "",
        navigationValue: null
      });

    case BLUR$1:
    case ESCAPE:
      return _extends$8(_extends$8({}, nextState), {}, {
        navigationValue: null
      });

    case SELECT_WITH_CLICK:
      return _extends$8(_extends$8({}, nextState), {}, {
        value: event.value,
        navigationValue: null
      });

    case SELECT_WITH_KEYBOARD$1:
      return _extends$8(_extends$8({}, nextState), {}, {
        value: data.navigationValue,
        navigationValue: null
      });

    case CLOSE_WITH_BUTTON:
      return _extends$8(_extends$8({}, nextState), {}, {
        navigationValue: null
      });

    case INTERACT:
      return nextState;

    case FOCUS$1:
      return _extends$8(_extends$8({}, nextState), {}, {
        navigationValue: findNavigationValue(nextState, event)
      });

    default:
      return nextState;
  }
};

function popoverIsExpanded(state) {
  return [SUGGESTING, NAVIGATING, INTERACTING].includes(state);
}
/**
 * When we open a list, set the navigation value to the value in the input, if
 * it's in the list, then it'll automatically be highlighted.
 *
 * @param stateData
 * @param event
 */


function findNavigationValue(stateData, event) {
  // @ts-ignore
  if (event.value) {
    // @ts-ignore
    return event.value; // @ts-ignore
  } else if (event.persistSelection) {
    return stateData.value;
  } else {
    return null;
  }
}

var ComboboxDescendantContext = /*#__PURE__*/createDescendantContext("ComboboxDescendantContext");
var ComboboxContext = /*#__PURE__*/createNamedContext("ComboboxContext", {}); // Allows us to put the option's value on context so that ComboboxOptionText
// can work it's highlight text magic no matter what else is rendered around
// it.

var OptionContext = /*#__PURE__*/createNamedContext("OptionContext", {}); ////////////////////////////////////////////////////////////////////////////////

/**
 * Combobox
 *
 * @see Docs https://reacttraining.com/reach-ui/combobox#combobox
 */

var Combobox = /*#__PURE__*/forwardRefWithAs(function Combobox(_ref, forwardedRef) {
  var onSelect = _ref.onSelect,
      _ref$openOnFocus = _ref.openOnFocus,
      openOnFocus = _ref$openOnFocus === void 0 ? false : _ref$openOnFocus,
      children = _ref.children,
      _ref$as = _ref.as,
      Comp = _ref$as === void 0 ? "div" : _ref$as,
      ariaLabel = _ref["aria-label"],
      ariaLabelledby = _ref["aria-labelledby"],
      props = _objectWithoutPropertiesLoose$a(_ref, ["onSelect", "openOnFocus", "children", "as", "aria-label", "aria-labelledby"]);

  var _useDescendantsInit = useDescendantsInit(),
      options = _useDescendantsInit[0],
      setOptions = _useDescendantsInit[1]; // Need this to focus it


  var inputRef = React.useRef();
  var popoverRef = React.useRef();
  var buttonRef = React.useRef(); // When <ComboboxInput autocomplete={false} /> we don't want cycle back to
  // the user's value while navigating (because it's always the user's value),
  // but we need to know this in useKeyDown which is far away from the prop
  // here, so we do something sneaky and write it to this ref on context so we
  // can use it anywhere else . Another new trick for me and I'm excited
  // about this one too!

  var autocompletePropRef = React.useRef();
  var persistSelectionRef = React.useRef();
  var defaultData = {
    // The value the user has typed. We derive this also when the developer is
    // controlling the value of ComboboxInput.
    value: "",
    // the value the user has navigated to with the keyboard
    navigationValue: null
  };

  var _useReducerMachine = useReducerMachine(stateChart, reducer, defaultData),
      state = _useReducerMachine[0],
      data = _useReducerMachine[1],
      transition = _useReducerMachine[2];

  useFocusManagement(data.lastEventType, inputRef);
  var id = useId(props.id);
  var listboxId = id ? makeId("listbox", id) : "listbox";
  var context = {
    ariaLabel: ariaLabel,
    ariaLabelledby: ariaLabelledby,
    autocompletePropRef: autocompletePropRef,
    buttonRef: buttonRef,
    comboboxId: id,
    data: data,
    inputRef: inputRef,
    isExpanded: popoverIsExpanded(state),
    listboxId: listboxId,
    onSelect: onSelect || noop,
    openOnFocus: openOnFocus,
    persistSelectionRef: persistSelectionRef,
    popoverRef: popoverRef,
    state: state,
    transition: transition
  };
  React.useEffect(function () {
    return checkStyles("combobox");
  }, []);
  return React__default.createElement(DescendantProvider, {
    context: ComboboxDescendantContext,
    items: options,
    set: setOptions
  }, React__default.createElement(ComboboxContext.Provider, {
    value: context
  }, React__default.createElement(Comp, Object.assign({}, props, {
    "data-reach-combobox": "",
    ref: forwardedRef
  }), isFunction$2(children) ? children({
    id: id,
    isExpanded: popoverIsExpanded(state)
  }) : children)));
});

if (process.env.NODE_ENV !== "production") {
  Combobox.displayName = "Combobox";
  Combobox.propTypes = {
    as: _pt__default.any,
    onSelect: _pt__default.func,
    openOnFocus: _pt__default.bool
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * ComboboxInput
 *
 * Wraps an `<input/>` with a couple extra props that work with the combobox.
 *
 * @see Docs https://reacttraining.com/reach-ui/combobox#comboboxinput
 */


var ComboboxInput = /*#__PURE__*/forwardRefWithAs(function ComboboxInput(_ref2, forwardedRef) {
  var _ref2$as = _ref2.as,
      Comp = _ref2$as === void 0 ? "input" : _ref2$as,
      _ref2$selectOnClick = _ref2.selectOnClick,
      selectOnClick = _ref2$selectOnClick === void 0 ? false : _ref2$selectOnClick,
      _ref2$autocomplete = _ref2.autocomplete,
      autocomplete = _ref2$autocomplete === void 0 ? true : _ref2$autocomplete,
      onClick = _ref2.onClick,
      onChange = _ref2.onChange,
      onKeyDown = _ref2.onKeyDown,
      onBlur = _ref2.onBlur,
      onFocus = _ref2.onFocus,
      controlledValue = _ref2.value,
      props = _objectWithoutPropertiesLoose$a(_ref2, ["as", "selectOnClick", "autocomplete", "onClick", "onChange", "onKeyDown", "onBlur", "onFocus", "value"]);

  // https://github.com/reach/reach-ui/issues/464
  var _useRef = React.useRef(controlledValue),
      initialControlledValue = _useRef.current;

  var controlledValueChangedRef = React.useRef(false);
  useUpdateEffect(function () {
    controlledValueChangedRef.current = true;
  }, [controlledValue]);

  var _useContext = React.useContext(ComboboxContext),
      _useContext$data = _useContext.data,
      navigationValue = _useContext$data.navigationValue,
      value = _useContext$data.value,
      lastEventType = _useContext$data.lastEventType,
      inputRef = _useContext.inputRef,
      state = _useContext.state,
      transition = _useContext.transition,
      listboxId = _useContext.listboxId,
      autocompletePropRef = _useContext.autocompletePropRef,
      openOnFocus = _useContext.openOnFocus,
      isExpanded = _useContext.isExpanded,
      ariaLabel = _useContext.ariaLabel,
      ariaLabelledby = _useContext.ariaLabelledby;

  var ref = useForkedRef(inputRef, forwardedRef); // Because we close the List on blur, we need to track if the blur is
  // caused by clicking inside the list, and if so, don't close the List.

  var selectOnClickRef = React.useRef(false);
  var handleKeyDown = useKeyDown();
  var handleBlur = useBlur();
  var isControlled = controlledValue != null; // Layout effect should be SSR-safe here because we don't actually do
  // anything with this ref that involves rendering until after we've
  // let the client hydrate in nested components.

  useIsomorphicLayoutEffect(function () {
    autocompletePropRef.current = autocomplete;
  }, [autocomplete, autocompletePropRef]);
  var handleValueChange = React.useCallback(function (value) {
    if (value.trim() === "") {
      transition(CLEAR);
    } else if (value === initialControlledValue && !controlledValueChangedRef.current) {
      transition(INITIAL_CHANGE, {
        value: value
      });
    } else {
      transition(CHANGE, {
        value: value
      });
    }
  }, [initialControlledValue, transition]);
  React.useEffect(function () {
    // If they are controlling the value we still need to do our transitions,
    // so  we have this derived state to emulate onChange of the input as we
    // receive new `value`s ...[*]
    if (isControlled && controlledValue !== value && ( // https://github.com/reach/reach-ui/issues/481
    controlledValue.trim() === "" ? (value || "").trim() !== "" : true)) {
      handleValueChange(controlledValue);
    }
  }, [controlledValue, handleValueChange, isControlled, value]); // [*]... and when controlled, we don't trigger handleValueChange as the
  // user types, instead the developer controls it with the normal input
  // onChange prop

  function handleChange(event) {
    var value = event.target.value;

    if (!isControlled) {
      handleValueChange(value);
    }
  }

  function handleFocus() {
    if (selectOnClick) {
      selectOnClickRef.current = true;
    } // If we select an option with click, useFocusManagement will focus the
    // input, in those cases we don't want to cause the menu to open back up,
    // so we guard behind these states.


    if (openOnFocus && lastEventType !== SELECT_WITH_CLICK) {
      transition(FOCUS$1);
    }
  }

  function handleClick() {
    if (selectOnClickRef.current) {
      selectOnClickRef.current = false;
      inputRef.current.select();
    }
  }

  var inputValue = autocomplete && (state === NAVIGATING || state === INTERACTING) ? // When idle, we don't have a navigationValue on ArrowUp/Down
  navigationValue || controlledValue || value : controlledValue || value;
  return React__default.createElement(Comp, Object.assign({
    "aria-activedescendant": navigationValue ? String(makeHash(navigationValue)) : undefined,
    "aria-autocomplete": "both",
    "aria-controls": listboxId,
    "aria-expanded": isExpanded,
    "aria-haspopup": "listbox",
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabel ? undefined : ariaLabelledby,
    role: "combobox"
  }, props, {
    "data-reach-combobox-input": "",
    ref: ref,
    onBlur: wrapEvent(onBlur, handleBlur),
    onChange: wrapEvent(onChange, handleChange),
    onClick: wrapEvent(onClick, handleClick),
    onFocus: wrapEvent(onFocus, handleFocus),
    onKeyDown: wrapEvent(onKeyDown, handleKeyDown),
    value: inputValue || ""
  }));
});

if (process.env.NODE_ENV !== "production") {
  ComboboxInput.displayName = "ComboboxInput";
} ////////////////////////////////////////////////////////////////////////////////

/**
 * ComboboxPopover
 *
 * Contains the popup that renders the list. Because some UI needs to render
 * more than the list in the popup, you need to render one of these around the
 * list. For example, maybe you want to render the number of results suggested.
 *
 * @see Docs https://reacttraining.com/reach-ui/combobox#comboboxpopover
 */


var ComboboxPopover = /*#__PURE__*/React.forwardRef(function ComboboxPopover(_ref3, forwardedRef) {
  var children = _ref3.children,
      _ref3$portal = _ref3.portal,
      portal = _ref3$portal === void 0 ? true : _ref3$portal,
      onKeyDown = _ref3.onKeyDown,
      onBlur = _ref3.onBlur,
      props = _objectWithoutPropertiesLoose$a(_ref3, ["children", "portal", "onKeyDown", "onBlur"]);

  var _useContext2 = React.useContext(ComboboxContext),
      popoverRef = _useContext2.popoverRef,
      inputRef = _useContext2.inputRef,
      isExpanded = _useContext2.isExpanded;

  var ref = useForkedRef(popoverRef, forwardedRef);
  var handleKeyDown = useKeyDown();
  var handleBlur = useBlur();
  var sharedProps = {
    "data-reach-combobox-popover": "",
    onKeyDown: wrapEvent(onKeyDown, handleKeyDown),
    onBlur: wrapEvent(onBlur, handleBlur),
    // Instead of conditionally rendering the popover we use the `hidden` prop
    // because we don't want to unmount on close (from escape or onSelect).
    // However, the developer can conditionally render the ComboboxPopover if
    // they do want to cause mount/unmount based on the app's own data (like
    // results.length or whatever).
    hidden: !isExpanded,
    tabIndex: -1,
    children: children
  };
  return portal ? React__default.createElement(Popover, Object.assign({}, props, {
    // @ts-ignore
    ref: ref,
    position: positionMatchWidth,
    targetRef: inputRef
  }, sharedProps)) : React__default.createElement("div", Object.assign({
    ref: ref
  }, props, sharedProps));
});

if (process.env.NODE_ENV !== "production") {
  ComboboxPopover.displayName = "ComboboxPopover";
} ////////////////////////////////////////////////////////////////////////////////

/**
 * ComboboxList
 *
 * Contains the `ComboboxOption` elements and sets up the proper aria attributes
 * for the list.
 *
 * @see Docs https://reacttraining.com/reach-ui/combobox#comboboxlist
 */


var ComboboxList = /*#__PURE__*/forwardRefWithAs(function ComboboxList(_ref4, forwardedRef) {
  var _ref4$persistSelectio = _ref4.persistSelection,
      persistSelection = _ref4$persistSelectio === void 0 ? false : _ref4$persistSelectio,
      _ref4$as = _ref4.as,
      Comp = _ref4$as === void 0 ? "ul" : _ref4$as,
      props = _objectWithoutPropertiesLoose$a(_ref4, ["persistSelection", "as"]);

  var _useContext3 = React.useContext(ComboboxContext),
      persistSelectionRef = _useContext3.persistSelectionRef,
      listboxId = _useContext3.listboxId;

  if (persistSelection) {
    persistSelectionRef.current = true;
  }

  return React__default.createElement(Comp, Object.assign({
    role: "listbox"
  }, props, {
    ref: forwardedRef,
    "data-reach-combobox-list": "",
    id: listboxId
  }));
});

if (process.env.NODE_ENV !== "production") {
  ComboboxList.displayName = "ComboboxList";
} ////////////////////////////////////////////////////////////////////////////////

/**
 * ComboboxOption
 *
 * An option that is suggested to the user as they interact with the combobox.
 *
 * @see Docs https://reacttraining.com/reach-ui/combobox#comboboxoption
 */


var ComboboxOption = /*#__PURE__*/forwardRefWithAs(function ComboboxOption(_ref5, forwardedRef) {
  var _ref5$as = _ref5.as,
      Comp = _ref5$as === void 0 ? "li" : _ref5$as,
      children = _ref5.children,
      value = _ref5.value,
      onClick = _ref5.onClick,
      props = _objectWithoutPropertiesLoose$a(_ref5, ["as", "children", "value", "onClick"]);

  var _useContext4 = React.useContext(ComboboxContext),
      onSelect = _useContext4.onSelect,
      navigationValue = _useContext4.data.navigationValue,
      transition = _useContext4.transition;

  var ownRef = React.useRef(null);
  var ref = useForkedRef(forwardedRef, ownRef);
  var index = useDescendant({
    element: ownRef.current,
    value: value
  }, ComboboxDescendantContext);
  var isActive = navigationValue === value;

  var handleClick = function handleClick() {
    onSelect && onSelect(value);
    transition(SELECT_WITH_CLICK, {
      value: value
    });
  };

  return React__default.createElement(OptionContext.Provider, {
    value: {
      value: value,
      index: index
    }
  }, React__default.createElement(Comp, Object.assign({
    "aria-selected": isActive,
    role: "option"
  }, props, {
    "data-reach-combobox-option": "",
    ref: ref,
    id: String(makeHash(value)),
    "data-highlighted": isActive ? "" : undefined,
    // Without this the menu will close from `onBlur`, but with it the
    // element can be `document.activeElement` and then our focus checks in
    // onBlur will work as intended
    tabIndex: -1,
    onClick: wrapEvent(onClick, handleClick),
    children: children || React__default.createElement(ComboboxOptionText, null)
  })));
});

if (process.env.NODE_ENV !== "production") {
  ComboboxOption.displayName = "ComboboxOption";
} ////////////////////////////////////////////////////////////////////////////////

/**
 * ComboboxOptionText
 *
 * Renders the value of a `ComboboxOption` as text but with spans wrapping the
 * matching and non-matching segments of text.
 *
 * We don't forwardRef or spread props because we render multiple spans or null,
 * should be fine 
 *
 * @example
 *   <ComboboxOption value="Seattle">
 *      <ComboboxOptionText />
 *   </ComboboxOption>
 *
 * @see Docs https://reacttraining.com/reach-ui/combobox#comboboxoptiontext
 */


function ComboboxOptionText() {
  var _useContext5 = React.useContext(OptionContext),
      value = _useContext5.value;

  var _useContext6 = React.useContext(ComboboxContext),
      contextValue = _useContext6.data.value;

  var results = React.useMemo(function () {
    return dist_1({
      searchWords: escapeRegexp(contextValue || "").split(/\s+/),
      textToHighlight: value
    });
  }, [contextValue, value]);
  return React__default.createElement(React__default.Fragment, null, results.length ? results.map(function (result, index) {
    var str = value.slice(result.start, result.end);
    return React__default.createElement("span", {
      key: index,
      "data-user-value": result.highlight ? true : undefined,
      "data-suggested-value": result.highlight ? undefined : true
    }, str);
  }) : value);
}

if (process.env.NODE_ENV !== "production") {
  ComboboxOptionText.displayName = "ComboboxOptionText";
} ////////////////////////////////////////////////////////////////////////////////

/**
 * ComboboxButton
 */


var ComboboxButton = /*#__PURE__*/forwardRefWithAs(function ComboboxButton(_ref6, forwardedRef) {
  var _ref6$as = _ref6.as,
      Comp = _ref6$as === void 0 ? "button" : _ref6$as,
      onClick = _ref6.onClick,
      onKeyDown = _ref6.onKeyDown,
      props = _objectWithoutPropertiesLoose$a(_ref6, ["as", "onClick", "onKeyDown"]);

  var _useContext7 = React.useContext(ComboboxContext),
      transition = _useContext7.transition,
      state = _useContext7.state,
      buttonRef = _useContext7.buttonRef,
      listboxId = _useContext7.listboxId,
      isExpanded = _useContext7.isExpanded;

  var ref = useForkedRef(buttonRef, forwardedRef);
  var handleKeyDown = useKeyDown();

  var handleClick = function handleClick() {
    if (state === IDLE$1) {
      transition(OPEN_WITH_BUTTON);
    } else {
      transition(CLOSE_WITH_BUTTON);
    }
  };

  return React__default.createElement(Comp, Object.assign({
    "aria-controls": listboxId,
    "aria-haspopup": "listbox",
    "aria-expanded": isExpanded
  }, props, {
    "data-reach-combobox-button": "",
    ref: ref,
    onClick: wrapEvent(onClick, handleClick),
    onKeyDown: wrapEvent(onKeyDown, handleKeyDown)
  }));
});

if (process.env.NODE_ENV !== "production") {
  ComboboxButton.displayName = "ComboboxButton";
} ////////////////////////////////////////////////////////////////////////////////

/**
 * Move focus back to the input if we start navigating w/ the
 * keyboard after focus has moved to any focusable content in
 * the popup.
 *
 * @param lastEventType
 * @param inputRef
 */


function useFocusManagement(lastEventType, inputRef) {
  // useLayoutEffect so that the cursor goes to the end of the input instead
  // of awkwardly at the beginning, unclear to me why 
  //
  // Should be safe to use here since we're just focusing an input.
  useIsomorphicLayoutEffect(function () {
    if (lastEventType === NAVIGATE || lastEventType === ESCAPE || lastEventType === SELECT_WITH_CLICK || lastEventType === OPEN_WITH_BUTTON) {
      inputRef.current.focus();
    }
  }, [inputRef, lastEventType]);
}
/**
 * We want the same events when the input or the popup have focus (HOW COOL ARE
 * HOOKS BTW?) This is probably the hairiest piece but it's not bad.
 */


function useKeyDown() {
  var _useContext8 = React.useContext(ComboboxContext),
      navigationValue = _useContext8.data.navigationValue,
      onSelect = _useContext8.onSelect,
      state = _useContext8.state,
      transition = _useContext8.transition,
      autocompletePropRef = _useContext8.autocompletePropRef,
      persistSelectionRef = _useContext8.persistSelectionRef;

  var options = useDescendants(ComboboxDescendantContext);
  return function handleKeyDown(event) {
    var index = options.findIndex(function (_ref7) {
      var value = _ref7.value;
      return value === navigationValue;
    });

    function getNextOption() {
      var atBottom = index === options.length - 1;

      if (atBottom) {
        if (autocompletePropRef.current) {
          // Go back to the value the user has typed because we are
          // autocompleting and they need to be able to get back to what
          // they had typed w/o having to backspace out.
          return null;
        } else {
          // cycle through
          return getFirstOption();
        }
      } else {
        // Go to the next item in the list
        return options[(index + 1) % options.length];
      }
    }

    function getPreviousOption() {
      var atTop = index === 0;

      if (atTop) {
        if (autocompletePropRef.current) {
          // Go back to the value the user has typed because we are
          // autocompleting and they need to be able to get back to what
          // they had typed w/o having to backspace out.
          return null;
        } else {
          // cycle through
          return getLastOption();
        }
      } else if (index === -1) {
        // displaying the user's value, so go select the last one
        return getLastOption();
      } else {
        // normal case, select previous
        return options[(index - 1 + options.length) % options.length];
      }
    }

    function getFirstOption() {
      return options[0];
    }

    function getLastOption() {
      return options[options.length - 1];
    }

    switch (event.key) {
      case "ArrowDown":
        // Don't scroll the page
        event.preventDefault();

        if (!options || !options.length) {
          return;
        }

        if (state === IDLE$1) {
          // Opening a closed list
          transition(NAVIGATE, {
            persistSelection: persistSelectionRef.current
          });
        } else {
          var next = getNextOption();
          transition(NAVIGATE, {
            value: next ? next.value : null
          });
        }

        break;
      // A lot of duplicate code with ArrowDown up next, I'm already over it.

      case "ArrowUp":
        // Don't scroll the page
        event.preventDefault();

        if (!options || options.length === 0) {
          return;
        }

        if (state === IDLE$1) {
          transition(NAVIGATE);
        } else {
          var prev = getPreviousOption();
          transition(NAVIGATE, {
            value: prev ? prev.value : null
          });
        }

        break;

      case "Home":
      case "PageUp":
        // Don't scroll the page
        event.preventDefault();

        if (!options || options.length === 0) {
          return;
        }

        if (state === IDLE$1) {
          transition(NAVIGATE);
        } else {
          transition(NAVIGATE, {
            value: getFirstOption().value
          });
        }

        break;

      case "End":
      case "PageDown":
        // Don't scroll the page
        event.preventDefault();

        if (!options || options.length === 0) {
          return;
        }

        if (state === IDLE$1) {
          transition(NAVIGATE);
        } else {
          transition(NAVIGATE, {
            value: getLastOption().value
          });
        }

        break;

      case "Escape":
        if (state !== IDLE$1) {
          transition(ESCAPE);
        }

        break;

      case "Enter":
        if (state === NAVIGATING && navigationValue !== null) {
          // don't want to submit forms
          event.preventDefault();
          onSelect && onSelect(navigationValue);
          transition(SELECT_WITH_KEYBOARD$1);
        }

        break;
    }
  };
}

function useBlur() {
  var _useContext9 = React.useContext(ComboboxContext),
      state = _useContext9.state,
      transition = _useContext9.transition,
      popoverRef = _useContext9.popoverRef,
      inputRef = _useContext9.inputRef,
      buttonRef = _useContext9.buttonRef;

  return function handleBlur() {
    var ownerDocument = getOwnerDocument(inputRef.current) || document;
    requestAnimationFrame(function () {
      // we on want to close only if focus propss outside the combobox
      if (ownerDocument.activeElement !== inputRef.current && ownerDocument.activeElement !== buttonRef.current && popoverRef.current) {
        if (popoverRef.current.contains(ownerDocument.activeElement)) {
          // focus landed inside the combobox, keep it open
          if (state !== INTERACTING) {
            transition(INTERACT);
          }
        } else {
          // focus landed outside the combobox, close it.
          transition(BLUR$1);
        }
      }
    });
  };
}
/**
 * This manages transitions between states with a built in reducer to manage
 * the data that goes with those transitions.
 *
 * @param chart
 * @param reducer
 * @param initialData
 */


function useReducerMachine(chart, reducer, initialData) {
  var _useState = React.useState(chart.initial),
      state = _useState[0],
      setState = _useState[1];

  var _useReducer = React.useReducer(reducer, initialData),
      data = _useReducer[0],
      dispatch = _useReducer[1];

  var transition = function transition(event, payload) {
    if (payload === void 0) {
      payload = {};
    }

    var currentState = chart.states[state];
    var nextState = currentState && currentState.on[event];

    if (nextState) {
      dispatch(_extends$8({
        type: event,
        state: state,
        nextState: state
      }, payload));
      setState(nextState);
      return;
    }
  };

  return [state, data, transition];
}
/**
 * We don't want to track the active descendant with indexes because nothing is
 * more annoying in a combobox than having it change values RIGHT AS YOU HIT
 * ENTER. That only happens if you use the index as your data, rather than
 * *your data as your data*. We use this to generate a unique ID based on the
 * value of each item.  This function is short, sweet, and good enough (I also
 * don't know how it works, tbqh)
 *
 * @see https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript
 * @param str
 */


var makeHash = function makeHash(str) {
  var hash = 0;

  if (str.length === 0) {
    return hash;
  }

  for (var i = 0; i < str.length; i++) {
    var _char = str.charCodeAt(i);

    hash = (hash << 5) - hash + _char;
    hash = hash & hash;
  }

  return hash;
};
/**
 * Escape regexp special characters in `str`
 *
 * @see https://github.com/component/escape-regexp/blob/5ce923c1510c9802b3da972c90b6861dd2829b6b/index.js
 * @param str
 */


function escapeRegexp(str) {
  return String(str).replace(/([.*+?=^!:${}()|[\]/\\])/g, "\\$1");
} ////////////////////////////////////////////////////////////////////////////////

/**
 * A hook that exposes data for a given `Combobox` component to its descendants.
 *
 * @see Docs https://reacttraining.com/reach-ui/combobox#usecomboboxcontext
 */

function useComboboxContext() {
  var _useContext10 = React.useContext(ComboboxContext),
      isExpanded = _useContext10.isExpanded,
      comboboxId = _useContext10.comboboxId;

  return React.useMemo(function () {
    return {
      id: comboboxId,
      isExpanded: isExpanded
    };
  }, [comboboxId, isExpanded]);
}

function getFormFieldLabelSizes(theme) {
  return {
    L: theme.fontSizes[2],
    M: theme.fontSizes[1],
    S: theme.fontSizes[0]
  };
}

var getLabelFontSize = function getLabelFontSize(size, t) {
  return {
    fontSize: getFormFieldLabelSizes(t)[size]
  };
};
var getLabelStyles = function getLabelStyles(theme) {
  return {
    color: theme.colors.grey[90],
    lineHeight: theme.lineHeights.dense,
    alignSelf: "center"
  };
};
var RequiredFlag = function RequiredFlag() {
  return core.jsx("span", {
    css: function css(theme) {
      return {
        color: theme.colors.grey[50],
        fontSize: theme.fontSizes[0],
        marginLeft: theme.space[1]
      };
    }
  }, "(required)");
};
var getFocusStyles = function getFocusStyles(theme, hasError) {
  return {
    boxShadow: "0 0 0 3px ".concat(hasError ? theme.colors.red[10] : theme.colors.purple[20]),
    borderColor: hasError ? theme.colors.red[30] : theme.colors.purple[60]
  };
};
var getInputStyles = function getInputStyles(theme, hasError) {
  return {
    border: hasError ? "1px solid ".concat(theme.colors.red[60]) : "1px solid ".concat(theme.colors.grey[30]),
    background: theme.colors.white,
    borderRadius: theme.radii[2],
    color: theme.colors.grey[90],
    fontFamily: theme.fonts.system,
    fontSize: theme.fontSizes[2],
    height: "2.25rem",
    padding: "0 ".concat(theme.space[3]),
    position: "relative",
    width: "100%",
    zIndex: 1,
    WebkitAppearance: "none",
    ":focus": _objectSpread2({
      outline: "0",
      transition: "box-shadow 0.15s ease-in-out"
    }, getFocusStyles(theme, hasError)),
    ":disabled": {
      background: theme.colors.grey[10],
      cursor: "not-allowed"
    },
    "&:disabled::placeholder": {
      color: theme.colors.grey[40]
    },
    "&::placeholder": {
      color: theme.colors.grey[50]
    }
  };
};
var getDescriptionStyles = function getDescriptionStyles(theme) {
  return {
    color: theme.colors.grey[50],
    fontSize: theme.fontSizes[0],
    lineHeight: theme.lineHeights.dense,
    position: "relative",
    zIndex: 0
  };
};
var getFieldLayoutStyles = function getFieldLayoutStyles(theme) {
  var layout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "vertical";
  return [{
    display: "grid",
    gridRowGap: theme.space[2],
    gridColumnGap: theme.space[4]
  }, layout === "horizontal" ? {
    gridTemplateAreas: "\n      \"label control\"\n      \"..... hint\"\n      \"..... error\"\n    ",
    gridTemplateColumns: "30% 70%"
  } : {
    gridTemplateAreas: "\n      \"label\"\n      \"control\"\n      \"hint\"\n      \"error\"\n    "
  }];
};
RequiredFlag.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RequiredFlag"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/FormField.helpers.tsx"] = {
    name: "RequiredFlag",
    docgenInfo: RequiredFlag.__docgenInfo,
    path: "src/components/form/components/FormField.helpers.tsx"
  };
}

var comboboxCss = function comboboxCss() {
  return {
    position: "relative"
  };
};
var popoverCss = function popoverCss(theme) {
  return {
    position: "absolute",
    zIndex: 1000,
    width: "100%",
    background: theme.colors.primaryBackground,
    border: "1px solid ".concat(theme.colors.grey[10]),
    borderBottomLeftRadius: theme.radii[3],
    borderBottomRightRadius: theme.radii[3],
    boxShadow: "0 5px 10px 3px rgba(0, 0, 0, 0.1)",
    color: theme.colors.grey[90],
    fontSize: theme.fontSizes[1]
  };
};
var inputCss = function inputCss() {
  var hasError = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return function (theme) {
    return [getInputStyles(theme, hasError), {
      paddingLeft: theme.space[8],
      backgroundImage: "url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCI+CiAgPHBhdGggZmlsbD0iI0I3QjVCRCIgZD0iTTE1LjUgMTRoLS44bC0uMy0uM2MxLTEuMSAxLjYtMi42IDEuNi00LjJhNi41IDYuNSAwIDEgMC0yLjMgNWwuMy4ydi44bDUgNSAxLjUtMS41LTUtNXptLTYgMGE0LjUgNC41IDAgMSAxIDAtOSA0LjUgNC41IDAgMCAxIDAgOXoiLz4KICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+Cjwvc3ZnPg==)",
      backgroundPosition: "left 0.4rem center",
      backgroundRepeat: "no-repeat",
      backgroundSize: "".concat(theme.space[6], " ").concat(theme.space[6])
    }];
  };
};
var inputWithSelectedValueCss = function inputWithSelectedValueCss(theme) {
  return {
    "&:focus + span": {
      fontSize: theme.fontSizes[0],
      transform: "translate3d(0, 0, 0)",
      backgroundColor: theme.colors.white,
      color: theme.colors.purple[70],
      opacity: 1
    }
  };
};
var selectedValueCss = function selectedValueCss(theme) {
  return {
    fontSize: theme.fontSizes[2],
    lineHeight: theme.lineHeights.solid,
    position: "absolute",
    zIndex: 2,
    color: theme.colors.grey[90],
    top: "calc(-".concat(theme.fontSizes[0], " / 2)"),
    left: theme.space[5],
    maxWidth: "calc(100% - ".concat(theme.space[5], " - ").concat(theme.space[8], ")"),
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    padding: "0 ".concat(theme.space[2]),
    opacity: 0,
    transform: "translate3d(0.8rem, 1.1rem, 0)",
    transition: "all ".concat(theme.transitions.curve["default"], " ").concat(theme.transitions.speed["default"]),
    pointerEvents: "none"
  };
};
var listCss$1 = function listCss() {
  return {
    listStyle: "none",
    margin: 0,
    padding: 0,
    userSelect: "none",
    maxHeight: "18rem",
    height: "auto",
    overflowY: "scroll"
  };
};
var optionCss = function optionCss(highlightMatches) {
  return function (theme) {
    return [{
      cursor: "pointer",
      padding: "".concat(theme.space[4], " ").concat(theme.space[5]),
      margin: 0,
      overflow: "hidden",
      position: "relative",
      textDecoration: "none",
      "&:hover": {
        background: theme.colors.purple[10]
      },
      "&[data-highlighted]": {
        background: theme.colors.purple[10],
        color: theme.colors.purple[50],
        outline: "none"
      }
    }, highlightMatches && {
      "[data-suggested-value]": {
        fontWeight: theme.fontWeights.body
      },
      "[data-user-value]": {
        color: theme.colors.purple[60],
        fontWeight: theme.fontWeights.bold,
        textDecoration: "underline"
      }
    }];
  };
};
var selectedOptionIconCss = function selectedOptionIconCss(theme) {
  return {
    transition: "0.5s",
    marginRight: theme.space[3],
    "[data-reach-combobox-option][data-highlighted] > &": {
      transform: "scale(1.2)"
    }
  };
};

var ComboboxCustomContext = React__default.createContext({
  listRef: {
    current: null
  }
});

function useComboboxCustomContext() {
  return React__default.useContext(ComboboxCustomContext);
}

function Combobox$1(props) {
  var listRef = React__default.useRef(null);
  return core.jsx(ComboboxCustomContext.Provider, {
    value: {
      listRef: listRef
    }
  }, core.jsx(DisableReachStyleCheck, {
    reachComponent: "combobox"
  }), core.jsx(Combobox, _extends({
    openOnFocus: true,
    css: comboboxCss
  }, props)));
}
var ComboboxInput$1 = React__default.forwardRef(function ComboboxInput$1(_ref, ref) {
  var selectedOptionLabel = _ref.selectedOptionLabel,
      hasError = _ref.hasError,
      delegated = _objectWithoutProperties(_ref, ["selectedOptionLabel", "hasError"]);

  var _useComboboxCustomCon = useComboboxCustomContext(),
      listRef = _useComboboxCustomCon.listRef;
  /**
   * This handler allows to scroll list of options along with keyboard navigation
   *
   * This solution has been suggested in one of the replies:
   * https://github.com/reach/reach-ui/issues/357#issuecomment-575849548
   */


  var onKeyDown = function onKeyDown(event) {
    if (event.isDefaultPrevented()) {
      return;
    }

    var container = listRef.current;

    if (!container) {
      return;
    } // According to the original Github comment, using "requestAnimationFrame" makes
    // scrolling work when navigating from last item to first item and vice versa


    window.requestAnimationFrame(function () {
      var element = container.querySelector("[aria-selected=true]");

      if (!element) {
        return;
      }

      var top = element.offsetTop - container.scrollTop;
      var bottom = container.scrollTop + container.clientHeight - (element.offsetTop + element.clientHeight);
      if (bottom < 0) container.scrollTop -= bottom;
      if (top < 0) container.scrollTop += top;
    });
  };

  var showSelectedOptionLabel = !!selectedOptionLabel;

  if (delegated.value === selectedOptionLabel) {
    showSelectedOptionLabel = false;
  }

  return core.jsx("div", {
    css: {
      position: "relative"
    }
  }, core.jsx(ComboboxInput, _extends({
    ref: ref,
    selectOnClick: true,
    onKeyDown: onKeyDown,
    css: function css(theme) {
      return [inputCss(hasError)(theme), showSelectedOptionLabel && inputWithSelectedValueCss(theme)];
    }
  }, delegated)), !!selectedOptionLabel && core.jsx("span", {
    "aria-hidden": true,
    css: selectedValueCss
  }, selectedOptionLabel));
});
var ComboboxPopover$1 = React__default.forwardRef(function ComboboxPopover$1(props, ref) {
  return core.jsx(ComboboxPopover, _extends({
    ref: ref,
    portal: true,
    css: popoverCss
  }, props));
});
function ComboboxList$1(props) {
  var _useComboboxCustomCon2 = useComboboxCustomContext(),
      listRef = _useComboboxCustomCon2.listRef;

  if (process.env.NODE_ENV === "development") {
    var hasAccessibleName = Boolean(props["aria-label"] || props["aria-labelledby"]);

    if (!hasAccessibleName) {
      warn("<ComboboxList /> is missing one of the required props: \"aria-label\", \"aria-labelledby\"");
    }
  }

  return core.jsx(ComboboxList, _extends({
    ref: listRef,
    persistSelection: true,
    css: listCss$1
  }, props));
}
var ComboboxOption$1 = React__default.forwardRef(function ComboboxOption$1(_ref2, ref) {
  var selected = _ref2.selected,
      _ref2$selectedAriaLab = _ref2.selectedAriaLabel,
      selectedAriaLabel = _ref2$selectedAriaLab === void 0 ? "currently selected:" : _ref2$selectedAriaLab,
      _ref2$highlightMatche = _ref2.highlightMatches,
      highlightMatches = _ref2$highlightMatche === void 0 ? true : _ref2$highlightMatche,
      value = _ref2.value,
      children = _ref2.children,
      delegated = _objectWithoutProperties(_ref2, ["selected", "selectedAriaLabel", "highlightMatches", "value", "children"]);

  return core.jsx(ComboboxOption, _extends({
    ref: ref,
    value: value,
    css: optionCss(highlightMatches)
  }, delegated), selected && core.jsx(md.MdDone, {
    css: selectedOptionIconCss,
    "aria-label": selectedAriaLabel
  }), children || (highlightMatches ? core.jsx(ComboboxOptionText$1, null) : value));
});
function ComboboxOptionText$1(props) {
  return core.jsx(ComboboxOptionText, props);
}
function useComboboxContext$1() {
  return useComboboxContext();
}
Combobox$1.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "Combobox"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Combobox/Combobox.tsx"] = {
    name: "Combobox",
    docgenInfo: Combobox$1.__docgenInfo,
    path: "src/components/Combobox/Combobox.tsx"
  };
}

ComboboxInput$1.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "ComboboxInput"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Combobox/Combobox.tsx"] = {
    name: "ComboboxInput",
    docgenInfo: ComboboxInput$1.__docgenInfo,
    path: "src/components/Combobox/Combobox.tsx"
  };
}

ComboboxPopover$1.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "ComboboxPopover"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Combobox/Combobox.tsx"] = {
    name: "ComboboxPopover",
    docgenInfo: ComboboxPopover$1.__docgenInfo,
    path: "src/components/Combobox/Combobox.tsx"
  };
}

ComboboxList$1.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "ComboboxList"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Combobox/Combobox.tsx"] = {
    name: "ComboboxList",
    docgenInfo: ComboboxList$1.__docgenInfo,
    path: "src/components/Combobox/Combobox.tsx"
  };
}

ComboboxOption$1.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "ComboboxOption",
  "props": {
    "selectedAriaLabel": {
      "defaultValue": {
        "value": "\"currently selected:\"",
        "computed": false
      },
      "required": false
    },
    "highlightMatches": {
      "defaultValue": {
        "value": "true",
        "computed": false
      },
      "required": false
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Combobox/Combobox.tsx"] = {
    name: "ComboboxOption",
    docgenInfo: ComboboxOption$1.__docgenInfo,
    path: "src/components/Combobox/Combobox.tsx"
  };
}

ComboboxOptionText$1.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "ComboboxOptionText"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Combobox/Combobox.tsx"] = {
    name: "ComboboxOptionText",
    docgenInfo: ComboboxOptionText$1.__docgenInfo,
    path: "src/components/Combobox/Combobox.tsx"
  };
}

function _templateObject2$2() {
  var data = _taggedTemplateLiteral(["\n  to {\n    transform: translateY(-0.1em) scale(1) \n  }\n"]);

  _templateObject2$2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject$a() {
  var data = _taggedTemplateLiteral(["\n  50% {\n    opacity: .5;\n  }\n  to {\n    opacity: 1;\n  }\n"]);

  _templateObject$a = function _templateObject() {
    return data;
  };

  return data;
}
function useStyledFieldLabel(label) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? "M" : _ref$size,
      _ref$isRequired = _ref.isRequired,
      isRequired = _ref$isRequired === void 0 ? false : _ref$isRequired;

  return {
    css: function css(theme) {
      return [getLabelFontSize(size, theme), getLabelStyles(theme)];
    },
    children: core.jsx(React__default.Fragment, null, label, " ", isRequired && core.jsx(RequiredFlag, null))
  };
}
function useStyledFieldHint() {
  return {
    css: function css(theme) {
      return [getDescriptionStyles(theme), {
        gridArea: "hint"
      }];
    }
  };
}
var errorEntry = core.keyframes(_templateObject$a());
var errorIconEntry = core.keyframes(_templateObject2$2());
function useStyledFieldError(error) {
  return {
    css: function css(theme) {
      return [getDescriptionStyles(theme), {
        gridArea: "error",
        animation: "".concat(errorEntry, " .25s ease forwards"),
        color: theme.colors.red[70],
        opacity: 0
      }];
    },
    children: core.jsx(React__default.Fragment, null, core.jsx(md.MdError, {
      css: function css(theme) {
        return {
          animation: "".concat(errorIconEntry, " .25s ease-out forwards"),
          height: "1em",
          marginRight: theme.space[1],
          transform: "translateY(-0.1em) scale(0)",
          verticalAlign: "middle",
          width: "1em"
        };
      }
    }), error)
  };
}
function FormFieldContainer(_ref2) {
  var layout = _ref2.layout,
      rest = _objectWithoutProperties(_ref2, ["layout"]);

  var layoutProps = useFormFieldContainerProps(layout);
  return core.jsx("div", _extends({}, layoutProps, rest));
}
FormFieldContainer.propTypes = {
  layout: _pt__default.oneOf(["horizontal", "vertical"])
};
function useFormFieldContainerProps() {
  var layout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "vertical";
  return {
    css: function css(theme) {
      return getFieldLayoutStyles(theme, layout);
    }
  };
}
FormFieldContainer.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "FormFieldContainer",
  "props": {
    "layout": {
      "required": false,
      "tsType": {
        "name": "union",
        "raw": "`horizontal` | `vertical`",
        "elements": [{
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }]
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/FormField.tsx"] = {
    name: "FormFieldContainer",
    docgenInfo: FormFieldContainer.__docgenInfo,
    path: "src/components/form/components/FormField.tsx"
  };
}

function getFinalAriaDescribedBy(controlDescribedBy, ariaDescribedBy) {
  return [controlDescribedBy, ariaDescribedBy].filter(function (describedBy) {
    return describedBy;
  }).join(" ") || undefined;
}
function getHintId(fieldId) {
  return "".concat(fieldId, "__hint");
}
function getErrorId(fieldId) {
  return "".concat(fieldId, "__error");
}

var FormFieldSkeletonContext = React__default.createContext({
  id: "",
  hasHint: undefined,
  hasError: undefined,
  meta: {
    hintId: undefined,
    errorId: undefined,
    controlDescribedBy: undefined
  }
});

function FormFieldSkeletonProvider(_ref) {
  var id = _ref.id,
      hasError = _ref.hasError,
      hasHint = _ref.hasHint,
      children = _ref.children;
  var fieldContext = React__default.useMemo(function () {
    var hintId = getHintId(id);
    var errorId = getErrorId(id);
    var controlDescribedBy = [hasError && errorId, hasHint && hintId].filter(function (describedBy) {
      return describedBy;
    }).join(" ") || undefined;
    return {
      id: id,
      hasError: hasError,
      hasHint: hasHint,
      meta: {
        hintId: hintId,
        errorId: errorId,
        controlDescribedBy: controlDescribedBy
      }
    };
  }, [id, hasError, hasHint]);
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonContext.Provider, {
    value: fieldContext
  }, children);
}

FormFieldSkeletonProvider.propTypes = {
  id: _pt__default.string.isRequired,
  hasHint: _pt__default.bool,
  hasError: _pt__default.bool,
  children: _pt__default.node
};
var FormFieldSkeletonLabel = function FormFieldSkeletonLabel(props) {
  var _useFormFieldSkeleton = useFormFieldSkeleton(),
      id = _useFormFieldSkeleton.id;

  return /*#__PURE__*/React__default.createElement("label", _extends({
    htmlFor: id
  }, props));
};
var FormFieldSkeletonHint = function FormFieldSkeletonHint(_ref2) {
  var children = _ref2.children,
      rest = _objectWithoutProperties(_ref2, ["children"]);

  var _useFormFieldSkeleton2 = useFormFieldSkeleton(),
      hasHint = _useFormFieldSkeleton2.hasHint,
      meta = _useFormFieldSkeleton2.meta;

  return /*#__PURE__*/React__default.createElement("div", _extends({
    id: meta.hintId
  }, rest), hasHint ? children : null);
};
var FormFieldSkeletonError = function FormFieldSkeletonError(_ref3) {
  var children = _ref3.children,
      validationMode = _ref3.validationMode,
      rest = _objectWithoutProperties(_ref3, ["children", "validationMode"]);

  var _useFormFieldSkeleton3 = useFormFieldSkeleton(),
      hasError = _useFormFieldSkeleton3.hasError,
      meta = _useFormFieldSkeleton3.meta;

  return /*#__PURE__*/React__default.createElement("div", _extends({
    id: meta.errorId,
    "aria-live": getErrorAriaLiveAttribute(validationMode)
  }, rest), hasError ? children : null);
};
FormFieldSkeletonError.propTypes = {
  validationMode: _pt__default.oneOf(["focus", "change", "submit"])
};
function FormFieldSkeleton(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonProvider, props);
}
FormFieldSkeleton.propTypes = {
  id: _pt__default.string.isRequired,
  hasHint: _pt__default.bool,
  hasError: _pt__default.bool,
  children: _pt__default.node
};
function useFormFieldSkeleton() {
  return React__default.useContext(FormFieldSkeletonContext);
}

function getErrorAriaLiveAttribute(validationMode) {
  if (validationMode === "focus") {
    return "assertive";
  }

  if (validationMode === "change") {
    return "polite";
  }

  return undefined;
}

FormFieldSkeletonLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "FormFieldSkeletonLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/FormFieldSkeleton.tsx"] = {
    name: "FormFieldSkeletonLabel",
    docgenInfo: FormFieldSkeletonLabel.__docgenInfo,
    path: "src/components/form-skeletons/components/FormFieldSkeleton.tsx"
  };
}

FormFieldSkeletonHint.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "FormFieldSkeletonHint"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/FormFieldSkeleton.tsx"] = {
    name: "FormFieldSkeletonHint",
    docgenInfo: FormFieldSkeletonHint.__docgenInfo,
    path: "src/components/form-skeletons/components/FormFieldSkeleton.tsx"
  };
}

FormFieldSkeletonError.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "FormFieldSkeletonError"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/FormFieldSkeleton.tsx"] = {
    name: "FormFieldSkeletonError",
    docgenInfo: FormFieldSkeletonError.__docgenInfo,
    path: "src/components/form-skeletons/components/FormFieldSkeleton.tsx"
  };
}

FormFieldSkeleton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "FormFieldSkeleton",
  "props": {
    "id": {
      "required": true,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "hasHint": {
      "required": false,
      "tsType": {
        "name": "boolean"
      },
      "description": ""
    },
    "hasError": {
      "required": false,
      "tsType": {
        "name": "boolean"
      },
      "description": ""
    },
    "children": {
      "required": false,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/FormFieldSkeleton.tsx"] = {
    name: "FormFieldSkeleton",
    docgenInfo: FormFieldSkeleton.__docgenInfo,
    path: "src/components/form-skeletons/components/FormFieldSkeleton.tsx"
  };
}

function InputFieldSkeleton(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeleton, props);
}
var InputFieldSkeletonControl = React__default.forwardRef(function InputFieldSkeletonControl(props, ref) {
  var _useFormFieldSkeleton = useFormFieldSkeleton(),
      id = _useFormFieldSkeleton.id,
      hasError = _useFormFieldSkeleton.hasError,
      meta = _useFormFieldSkeleton.meta;

  return /*#__PURE__*/React__default.createElement("input", _extends({
    id: id
  }, props, {
    "aria-describedby": getFinalAriaDescribedBy(meta.controlDescribedBy, props["aria-describedby"]),
    "aria-invalid": hasError,
    ref: ref
  }));
});
function InputFieldSkeletonLabel(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonLabel, props);
}
function InputFieldSkeletonHint(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonHint, props);
}
function InputFieldSkeletonError(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonError, props);
}
InputFieldSkeleton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "InputFieldSkeleton"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/InputFieldSkeleton.tsx"] = {
    name: "InputFieldSkeleton",
    docgenInfo: InputFieldSkeleton.__docgenInfo,
    path: "src/components/form-skeletons/components/InputFieldSkeleton.tsx"
  };
}

InputFieldSkeletonControl.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "InputFieldSkeletonControl"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/InputFieldSkeleton.tsx"] = {
    name: "InputFieldSkeletonControl",
    docgenInfo: InputFieldSkeletonControl.__docgenInfo,
    path: "src/components/form-skeletons/components/InputFieldSkeleton.tsx"
  };
}

InputFieldSkeletonLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "InputFieldSkeletonLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/InputFieldSkeleton.tsx"] = {
    name: "InputFieldSkeletonLabel",
    docgenInfo: InputFieldSkeletonLabel.__docgenInfo,
    path: "src/components/form-skeletons/components/InputFieldSkeleton.tsx"
  };
}

InputFieldSkeletonHint.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "InputFieldSkeletonHint"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/InputFieldSkeleton.tsx"] = {
    name: "InputFieldSkeletonHint",
    docgenInfo: InputFieldSkeletonHint.__docgenInfo,
    path: "src/components/form-skeletons/components/InputFieldSkeleton.tsx"
  };
}

InputFieldSkeletonError.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "InputFieldSkeletonError"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/InputFieldSkeleton.tsx"] = {
    name: "InputFieldSkeletonError",
    docgenInfo: InputFieldSkeletonError.__docgenInfo,
    path: "src/components/form-skeletons/components/InputFieldSkeleton.tsx"
  };
}

function InputField(props) {
  return core.jsx(InputFieldSkeleton, props);
}
var InputFieldControl = React__default.forwardRef(function InputFieldControl(props, ref) {
  var _useFormFieldSkeleton = useFormFieldSkeleton(),
      hasError = _useFormFieldSkeleton.hasError;

  var placeholder = props.placeholder && props.disabled ? "The field is disabled" : props.placeholder;
  return core.jsx(InputFieldSkeletonControl, _extends({
    ref: ref,
    css: function css(theme) {
      return [getInputStyles(theme, hasError)];
    }
  }, props, {
    placeholder: placeholder
  }));
});
function InputFieldLabel(_ref) {
  var children = _ref.children,
      size = _ref.size,
      isRequired = _ref.isRequired,
      props = _objectWithoutProperties(_ref, ["children", "size", "isRequired"]);

  var styledProps = useStyledFieldLabel(children, {
    size: size,
    isRequired: isRequired
  });
  return core.jsx(InputFieldSkeletonLabel, _extends({}, props, styledProps));
}
function InputFieldError(_ref2) {
  var children = _ref2.children,
      props = _objectWithoutProperties(_ref2, ["children"]);

  var styledProps = useStyledFieldError(children);
  return core.jsx(InputFieldSkeletonError, _extends({}, props, styledProps));
}
function InputFieldHint(props) {
  var styledProps = useStyledFieldHint();
  return core.jsx(InputFieldSkeletonHint, _extends({}, props, styledProps));
}
InputField.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "InputField"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/InputField.tsx"] = {
    name: "InputField",
    docgenInfo: InputField.__docgenInfo,
    path: "src/components/form/components/InputField.tsx"
  };
}

InputFieldControl.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "InputFieldControl"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/InputField.tsx"] = {
    name: "InputFieldControl",
    docgenInfo: InputFieldControl.__docgenInfo,
    path: "src/components/form/components/InputField.tsx"
  };
}

InputFieldLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "InputFieldLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/InputField.tsx"] = {
    name: "InputFieldLabel",
    docgenInfo: InputFieldLabel.__docgenInfo,
    path: "src/components/form/components/InputField.tsx"
  };
}

InputFieldError.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "InputFieldError"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/InputField.tsx"] = {
    name: "InputFieldError",
    docgenInfo: InputFieldError.__docgenInfo,
    path: "src/components/form/components/InputField.tsx"
  };
}

InputFieldHint.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "InputFieldHint"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/InputField.tsx"] = {
    name: "InputFieldHint",
    docgenInfo: InputFieldHint.__docgenInfo,
    path: "src/components/form/components/InputField.tsx"
  };
}

var InputFieldBlock = React__default.forwardRef(function InputFieldBlock(props, ref) {
  var id = props.id,
      label = props.label,
      labelSize = props.labelSize,
      error = props.error,
      hint = props.hint,
      className = props.className,
      validationMode = props.validationMode,
      layout = props.layout,
      rest = _objectWithoutProperties(props, ["id", "label", "labelSize", "error", "hint", "className", "validationMode", "layout"]);

  return core.jsx(FormFieldContainer, {
    layout: layout,
    className: className
  }, core.jsx(InputField, {
    id: id,
    hasError: !!error,
    hasHint: !!hint
  }, core.jsx(InputFieldLabel, {
    size: labelSize,
    isRequired: !!rest.required
  }, label), core.jsx(InputFieldControl, _extends({
    ref: ref
  }, rest)), core.jsx(InputFieldHint, null, hint), core.jsx(InputFieldError, {
    validationMode: validationMode
  }, error)));
});
InputFieldBlock.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "InputFieldBlock"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/InputFieldBlock.tsx"] = {
    name: "InputFieldBlock",
    docgenInfo: InputFieldBlock.__docgenInfo,
    path: "src/components/form/components/InputFieldBlock.tsx"
  };
}

var Case = createCommonjsModule(function (module) {
/*! Case - v1.6.2 - 2020-03-24
* Copyright (c) 2020 Nathan Bubna; Licensed MIT, GPL */
(function() {
    var unicodes = function(s, prefix) {
        prefix = prefix || '';
        return s.replace(/(^|-)/g, '$1\\u'+prefix).replace(/,/g, '\\u'+prefix);
    },
    basicSymbols = unicodes('20-26,28-2F,3A-40,5B-60,7B-7E,A0-BF,D7,F7', '00'),
    baseLowerCase = 'a-z'+unicodes('DF-F6,F8-FF', '00'),
    baseUpperCase = 'A-Z'+unicodes('C0-D6,D8-DE', '00'),
    improperInTitle = 'A|An|And|As|At|But|By|En|For|If|In|Of|On|Or|The|To|Vs?\\.?|Via',
    regexps = function(symbols, lowers, uppers, impropers) {
        symbols = symbols || basicSymbols;
        lowers = lowers || baseLowerCase;
        uppers = uppers || baseUpperCase;
        impropers = impropers || improperInTitle;
        return {
            capitalize: new RegExp('(^|['+symbols+'])(['+lowers+'])', 'g'),
            pascal: new RegExp('(^|['+symbols+'])+(['+lowers+uppers+'])', 'g'),
            fill: new RegExp('['+symbols+']+(.|$)','g'),
            sentence: new RegExp('(^\\s*|[\\?\\!\\.]+"?\\s+"?|,\\s+")(['+lowers+'])', 'g'),
            improper: new RegExp('\\b('+impropers+')\\b', 'g'),
            relax: new RegExp('([^'+uppers+'])(['+uppers+']*)(['+uppers+'])(?=[^'+uppers+']|$)', 'g'),
            upper: new RegExp('^[^'+lowers+']+$'),
            hole: /[^\s]\s[^\s]/,
            apostrophe: /'/g,
            room: new RegExp('['+symbols+']')
        };
    },
    re = regexps(),
    _ = {
        re: re,
        unicodes: unicodes,
        regexps: regexps,
        types: [],
        up: String.prototype.toUpperCase,
        low: String.prototype.toLowerCase,
        cap: function(s) {
            return _.up.call(s.charAt(0))+s.slice(1);
        },
        decap: function(s) {
            return _.low.call(s.charAt(0))+s.slice(1);
        },
        deapostrophe: function(s) {
            return s.replace(re.apostrophe, '');
        },
        fill: function(s, fill, deapostrophe) {
            if (fill != null) {
                s = s.replace(re.fill, function(m, next) {
                    return next ? fill + next : '';
                });
            }
            if (deapostrophe) {
                s = _.deapostrophe(s);
            }
            return s;
        },
        prep: function(s, fill, pascal, upper) {
            s = s == null ? '' : s + '';// force to string
            if (!upper && re.upper.test(s)) {
                s = _.low.call(s);
            }
            if (!fill && !re.hole.test(s)) {
                var holey = _.fill(s, ' ');
                if (re.hole.test(holey)) {
                    s = holey;
                }
            }
            if (!pascal && !re.room.test(s)) {
                s = s.replace(re.relax, _.relax);
            }
            return s;
        },
        relax: function(m, before, acronym, caps) {
            return before + ' ' + (acronym ? acronym+' ' : '') + caps;
        }
    },
    Case = {
        _: _,
        of: function(s) {
            for (var i=0,m=_.types.length; i<m; i++) {
                if (Case[_.types[i]].apply(Case, arguments) === s){ return _.types[i]; }
            }
        },
        flip: function(s) {
            return s.replace(/\w/g, function(l) {
                return (l == _.up.call(l) ? _.low : _.up).call(l);
            });
        },
        random: function(s) {
            return s.replace(/\w/g, function(l) {
                return (Math.round(Math.random()) ? _.up : _.low).call(l);
            });
        },
        type: function(type, fn) {
            Case[type] = fn;
            _.types.push(type);
        }
    },
    types = {
        lower: function(s, fill, deapostrophe) {
            return _.fill(_.low.call(_.prep(s, fill)), fill, deapostrophe);
        },
        snake: function(s) {
            return Case.lower(s, '_', true);
        },
        constant: function(s) {
            return Case.upper(s, '_', true);
        },
        camel: function(s) {
            return _.decap(Case.pascal(s));
        },
        kebab: function(s) {
            return Case.lower(s, '-', true);
        },
        upper: function(s, fill, deapostrophe) {
            return _.fill(_.up.call(_.prep(s, fill, false, true)), fill, deapostrophe);
        },
        capital: function(s, fill, deapostrophe) {
            return _.fill(_.prep(s).replace(re.capitalize, function(m, border, letter) {
                return border+_.up.call(letter);
            }), fill, deapostrophe);
        },
        header: function(s) {
            return Case.capital(s, '-', true);
        },
        pascal: function(s) {
            return _.fill(_.prep(s, false, true).replace(re.pascal, function(m, border, letter) {
                return _.up.call(letter);
            }), '', true);
        },
        title: function(s) {
            return Case.capital(s).replace(re.improper, function(small, p, i, s) {
                return i > 0 && i < s.lastIndexOf(' ') ? _.low.call(small) : small;
            });
        },
        sentence: function(s, names, abbreviations) {
            s = Case.lower(s).replace(re.sentence, function(m, prelude, letter) {
                return prelude + _.up.call(letter);
            });
            if (names) {
                names.forEach(function(name) {
                    s = s.replace(new RegExp('\\b'+Case.lower(name)+'\\b', "g"), _.cap);
                });
            }
            if (abbreviations) {
                abbreviations.forEach(function(abbr) {
                    s = s.replace(new RegExp('(\\b'+Case.lower(abbr)+'\\. +)(\\w)'), function(m, abbrAndSpace, letter) {
                        return abbrAndSpace + _.low.call(letter);
                    });
                });
            }
            return s;
        }
    };

    // TODO: Remove "squish" in a future breaking release.
    types.squish = types.pascal;
    
    // Allow import default
    Case.default = Case;

    for (var type in types) {
        Case.type(type, types[type]);
    }
    // export Case (AMD, commonjs, or global)
    var define = typeof define === "function" ? define : function(){};
    define( module.exports ? module.exports = Case : this.Case = Case);

}).call(commonjsGlobal);
});

function useConnectedField(fieldName) {
  var id = "".concat(fieldName, "Field");
  var label = Case.sentence(fieldName);

  var _useField = formik.useField(fieldName),
      _useField2 = _slicedToArray(_useField, 3),
      field = _useField2[0],
      meta = _useField2[1],
      helpers = _useField2[2];

  var connectedProps = {
    id: id,
    label: label,
    value: field.value,
    error: meta.touched ? meta.error : "",
    onBlur: field.onBlur,
    onChange: field.onChange
  };
  return [connectedProps, field, meta, helpers];
}

var InputConnectedField = React__default.forwardRef(function InputConnectedField(props, ref) {
  var _useConnectedField = useConnectedField(props.name),
      _useConnectedField2 = _slicedToArray(_useConnectedField, 1),
      connectedProps = _useConnectedField2[0];

  return core.jsx(InputFieldBlock, _extends({
    ref: ref
  }, connectedProps, props));
});
InputConnectedField.propTypes = {
  name: _pt__default.string.isRequired,
  id: _pt__default.string,
  label: _pt__default.node
};
InputConnectedField.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "InputConnectedField"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/InputConnectedField.tsx"] = {
    name: "InputConnectedField",
    docgenInfo: InputConnectedField.__docgenInfo,
    path: "src/components/form/components/InputConnectedField.tsx"
  };
}

function TextAreaFieldSkeleton(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeleton, props);
}
var TextAreaFieldSkeletonControl = React__default.forwardRef(function TextAreaFieldSkeletonControl(props, ref) {
  var _useFormFieldSkeleton = useFormFieldSkeleton(),
      id = _useFormFieldSkeleton.id,
      hasError = _useFormFieldSkeleton.hasError,
      meta = _useFormFieldSkeleton.meta;

  return /*#__PURE__*/React__default.createElement("textarea", _extends({
    id: id
  }, props, {
    "aria-describedby": getFinalAriaDescribedBy(meta.controlDescribedBy, props["aria-describedby"]),
    "aria-invalid": hasError,
    ref: ref
  }));
});
function TextAreaFieldSkeletonLabel(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonLabel, props);
}
function TextAreaFieldSkeletonHint(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonHint, props);
}
function TextAreaFieldSkeletonError(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonError, props);
}
TextAreaFieldSkeleton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "TextAreaFieldSkeleton"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/TextAreaFieldSkeleton.tsx"] = {
    name: "TextAreaFieldSkeleton",
    docgenInfo: TextAreaFieldSkeleton.__docgenInfo,
    path: "src/components/form-skeletons/components/TextAreaFieldSkeleton.tsx"
  };
}

TextAreaFieldSkeletonControl.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "TextAreaFieldSkeletonControl"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/TextAreaFieldSkeleton.tsx"] = {
    name: "TextAreaFieldSkeletonControl",
    docgenInfo: TextAreaFieldSkeletonControl.__docgenInfo,
    path: "src/components/form-skeletons/components/TextAreaFieldSkeleton.tsx"
  };
}

TextAreaFieldSkeletonLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "TextAreaFieldSkeletonLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/TextAreaFieldSkeleton.tsx"] = {
    name: "TextAreaFieldSkeletonLabel",
    docgenInfo: TextAreaFieldSkeletonLabel.__docgenInfo,
    path: "src/components/form-skeletons/components/TextAreaFieldSkeleton.tsx"
  };
}

TextAreaFieldSkeletonHint.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "TextAreaFieldSkeletonHint"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/TextAreaFieldSkeleton.tsx"] = {
    name: "TextAreaFieldSkeletonHint",
    docgenInfo: TextAreaFieldSkeletonHint.__docgenInfo,
    path: "src/components/form-skeletons/components/TextAreaFieldSkeleton.tsx"
  };
}

TextAreaFieldSkeletonError.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "TextAreaFieldSkeletonError"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/TextAreaFieldSkeleton.tsx"] = {
    name: "TextAreaFieldSkeletonError",
    docgenInfo: TextAreaFieldSkeletonError.__docgenInfo,
    path: "src/components/form-skeletons/components/TextAreaFieldSkeleton.tsx"
  };
}

function TextAreaField(props) {
  return core.jsx(TextAreaFieldSkeleton, props);
}
var TextAreaFieldControl = React__default.forwardRef(function TextAreaFieldControl(props, ref) {
  var _useFormFieldSkeleton = useFormFieldSkeleton(),
      hasError = _useFormFieldSkeleton.hasError;

  var placeholder = props.placeholder && props.disabled ? "The field is disabled" : props.placeholder;
  return core.jsx(TextAreaFieldSkeletonControl, _extends({
    ref: ref,
    css: function css(theme) {
      return [getInputStyles(theme, hasError), {
        display: "block",
        minHeight: "4.85em",
        resize: "vertical",
        padding: "".concat(theme.space[2], " ").concat(theme.space[3])
      }];
    }
  }, props, {
    placeholder: placeholder
  }));
});
function TextAreaFieldLabel(_ref) {
  var children = _ref.children,
      size = _ref.size,
      isRequired = _ref.isRequired,
      props = _objectWithoutProperties(_ref, ["children", "size", "isRequired"]);

  var styledProps = useStyledFieldLabel(children, {
    size: size,
    isRequired: isRequired
  });
  return core.jsx(TextAreaFieldSkeletonLabel, _extends({}, props, styledProps));
}
function TextAreaFieldError(_ref2) {
  var children = _ref2.children,
      props = _objectWithoutProperties(_ref2, ["children"]);

  var styledProps = useStyledFieldError(children);
  return core.jsx(TextAreaFieldSkeletonError, _extends({}, props, styledProps));
}
function TextAreaFieldHint(props) {
  var styledProps = useStyledFieldHint();
  return core.jsx(TextAreaFieldSkeletonHint, _extends({}, props, styledProps));
}
TextAreaField.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "TextAreaField"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/TextAreaField.tsx"] = {
    name: "TextAreaField",
    docgenInfo: TextAreaField.__docgenInfo,
    path: "src/components/form/components/TextAreaField.tsx"
  };
}

TextAreaFieldControl.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "TextAreaFieldControl"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/TextAreaField.tsx"] = {
    name: "TextAreaFieldControl",
    docgenInfo: TextAreaFieldControl.__docgenInfo,
    path: "src/components/form/components/TextAreaField.tsx"
  };
}

TextAreaFieldLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "TextAreaFieldLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/TextAreaField.tsx"] = {
    name: "TextAreaFieldLabel",
    docgenInfo: TextAreaFieldLabel.__docgenInfo,
    path: "src/components/form/components/TextAreaField.tsx"
  };
}

TextAreaFieldError.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "TextAreaFieldError"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/TextAreaField.tsx"] = {
    name: "TextAreaFieldError",
    docgenInfo: TextAreaFieldError.__docgenInfo,
    path: "src/components/form/components/TextAreaField.tsx"
  };
}

TextAreaFieldHint.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "TextAreaFieldHint"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/TextAreaField.tsx"] = {
    name: "TextAreaFieldHint",
    docgenInfo: TextAreaFieldHint.__docgenInfo,
    path: "src/components/form/components/TextAreaField.tsx"
  };
}

var TextAreaFieldBlock = React__default.forwardRef(function TextAreaFieldBlock(props, ref) {
  var id = props.id,
      label = props.label,
      labelSize = props.labelSize,
      error = props.error,
      hint = props.hint,
      className = props.className,
      validationMode = props.validationMode,
      layout = props.layout,
      rest = _objectWithoutProperties(props, ["id", "label", "labelSize", "error", "hint", "className", "validationMode", "layout"]);

  return core.jsx(FormFieldContainer, {
    layout: layout,
    className: className
  }, core.jsx(TextAreaField, {
    id: id,
    hasError: !!error,
    hasHint: !!hint
  }, core.jsx(TextAreaFieldLabel, {
    size: labelSize,
    isRequired: !!rest.required,
    css: function css(theme) {
      return [layout === "horizontal" && {
        alignSelf: "baseline",
        paddingTop: theme.space[2]
      }];
    }
  }, label), core.jsx(TextAreaFieldControl, _extends({
    ref: ref
  }, rest)), core.jsx(TextAreaFieldHint, null, hint), core.jsx(TextAreaFieldError, {
    validationMode: validationMode
  }, error)));
});
TextAreaFieldBlock.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "TextAreaFieldBlock"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/TextAreaFieldBlock.tsx"] = {
    name: "TextAreaFieldBlock",
    docgenInfo: TextAreaFieldBlock.__docgenInfo,
    path: "src/components/form/components/TextAreaFieldBlock.tsx"
  };
}

var TextAreaConnectedField = React__default.forwardRef(function TextAreaConnectedField(props, ref) {
  var _useConnectedField = useConnectedField(props.name),
      _useConnectedField2 = _slicedToArray(_useConnectedField, 1),
      connectedProps = _useConnectedField2[0];

  return core.jsx(TextAreaFieldBlock, _extends({
    ref: ref
  }, connectedProps, props));
});
TextAreaConnectedField.propTypes = {
  name: _pt__default.string.isRequired,
  id: _pt__default.string,
  label: _pt__default.node
};
TextAreaConnectedField.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "TextAreaConnectedField"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/TextAreaConnectedField.tsx"] = {
    name: "TextAreaConnectedField",
    docgenInfo: TextAreaConnectedField.__docgenInfo,
    path: "src/components/form/components/TextAreaConnectedField.tsx"
  };
}

function SelectFieldSkeleton(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeleton, props);
}
var SelectFieldSkeletonControl = React__default.forwardRef(function SelectFieldSkeletonControl(_ref, ref) {
  var options = _ref.options,
      rest = _objectWithoutProperties(_ref, ["options"]);

  var _useFormFieldSkeleton = useFormFieldSkeleton(),
      id = _useFormFieldSkeleton.id,
      hasError = _useFormFieldSkeleton.hasError,
      meta = _useFormFieldSkeleton.meta;

  return /*#__PURE__*/React__default.createElement("select", _extends({
    id: id
  }, rest, {
    "aria-describedby": getFinalAriaDescribedBy(meta.controlDescribedBy, rest["aria-describedby"]),
    "aria-invalid": hasError,
    ref: ref
  }), options.map(renderOption));
});
SelectFieldSkeletonControl.propTypes = {
  options: _pt__default.arrayOf(_pt__default.shape({
    value: _pt__default.string.isRequired,
    label: _pt__default.string.isRequired
  })).isRequired
};

function renderOption(_ref2) {
  var label = _ref2.label,
      value = _ref2.value;
  return /*#__PURE__*/React__default.createElement("option", {
    key: value,
    value: value
  }, label);
}

function SelectFieldSkeletonLabel(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonLabel, props);
}
function SelectFieldSkeletonHint(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonHint, props);
}
function SelectFieldSkeletonError(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonError, props);
}
SelectFieldSkeleton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "SelectFieldSkeleton"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/SelectFieldSkeleton.tsx"] = {
    name: "SelectFieldSkeleton",
    docgenInfo: SelectFieldSkeleton.__docgenInfo,
    path: "src/components/form-skeletons/components/SelectFieldSkeleton.tsx"
  };
}

SelectFieldSkeletonControl.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "SelectFieldSkeletonControl"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/SelectFieldSkeleton.tsx"] = {
    name: "SelectFieldSkeletonControl",
    docgenInfo: SelectFieldSkeletonControl.__docgenInfo,
    path: "src/components/form-skeletons/components/SelectFieldSkeleton.tsx"
  };
}

SelectFieldSkeletonLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "SelectFieldSkeletonLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/SelectFieldSkeleton.tsx"] = {
    name: "SelectFieldSkeletonLabel",
    docgenInfo: SelectFieldSkeletonLabel.__docgenInfo,
    path: "src/components/form-skeletons/components/SelectFieldSkeleton.tsx"
  };
}

SelectFieldSkeletonHint.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "SelectFieldSkeletonHint"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/SelectFieldSkeleton.tsx"] = {
    name: "SelectFieldSkeletonHint",
    docgenInfo: SelectFieldSkeletonHint.__docgenInfo,
    path: "src/components/form-skeletons/components/SelectFieldSkeleton.tsx"
  };
}

SelectFieldSkeletonError.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "SelectFieldSkeletonError"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/SelectFieldSkeleton.tsx"] = {
    name: "SelectFieldSkeletonError",
    docgenInfo: SelectFieldSkeletonError.__docgenInfo,
    path: "src/components/form-skeletons/components/SelectFieldSkeleton.tsx"
  };
}

function SelectField(props) {
  return core.jsx(SelectFieldSkeleton, props);
}
var SelectFieldControl = React__default.forwardRef(function SelectFieldControl(props, ref) {
  var _useFormFieldSkeleton = useFormFieldSkeleton(),
      hasError = _useFormFieldSkeleton.hasError;

  return core.jsx(SelectFieldSkeletonControl, _extends({
    ref: ref,
    css: function css(theme) {
      return [getInputStyles(theme, hasError), {
        padding: "0 ".concat(theme.space[3]),
        backgroundImage: "url(\"data:image/svg+xml,%3Csvg stroke='currentColor' fill='currentColor' stroke-width='0' viewBox='0 0 24 24' height='1em' width='1em' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z'%3E%3C/path%3E%3C/svg%3E\")",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "right ".concat(theme.space[3], " top 50%, 0 0")
      }];
    }
  }, props));
});
function SelectFieldLabel(_ref) {
  var children = _ref.children,
      size = _ref.size,
      isRequired = _ref.isRequired,
      props = _objectWithoutProperties(_ref, ["children", "size", "isRequired"]);

  var styledProps = useStyledFieldLabel(children, {
    size: size,
    isRequired: isRequired
  });
  return core.jsx(SelectFieldSkeletonLabel, _extends({}, props, styledProps));
}
function SelectFieldError(_ref2) {
  var children = _ref2.children,
      props = _objectWithoutProperties(_ref2, ["children"]);

  var styledProps = useStyledFieldError(children);
  return core.jsx(SelectFieldSkeletonError, _extends({}, props, styledProps));
}
function SelectFieldHint(props) {
  var styledProps = useStyledFieldHint();
  return core.jsx(SelectFieldSkeletonHint, _extends({}, props, styledProps));
}
SelectField.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "SelectField"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/SelectField.tsx"] = {
    name: "SelectField",
    docgenInfo: SelectField.__docgenInfo,
    path: "src/components/form/components/SelectField.tsx"
  };
}

SelectFieldControl.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "SelectFieldControl"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/SelectField.tsx"] = {
    name: "SelectFieldControl",
    docgenInfo: SelectFieldControl.__docgenInfo,
    path: "src/components/form/components/SelectField.tsx"
  };
}

SelectFieldLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "SelectFieldLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/SelectField.tsx"] = {
    name: "SelectFieldLabel",
    docgenInfo: SelectFieldLabel.__docgenInfo,
    path: "src/components/form/components/SelectField.tsx"
  };
}

SelectFieldError.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "SelectFieldError"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/SelectField.tsx"] = {
    name: "SelectFieldError",
    docgenInfo: SelectFieldError.__docgenInfo,
    path: "src/components/form/components/SelectField.tsx"
  };
}

SelectFieldHint.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "SelectFieldHint"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/SelectField.tsx"] = {
    name: "SelectFieldHint",
    docgenInfo: SelectFieldHint.__docgenInfo,
    path: "src/components/form/components/SelectField.tsx"
  };
}

var SelectFieldBlock = React__default.forwardRef(function SelectFieldBlock(props, ref) {
  var id = props.id,
      label = props.label,
      labelSize = props.labelSize,
      error = props.error,
      hint = props.hint,
      className = props.className,
      validationMode = props.validationMode,
      layout = props.layout,
      rest = _objectWithoutProperties(props, ["id", "label", "labelSize", "error", "hint", "className", "validationMode", "layout"]);

  return core.jsx(FormFieldContainer, {
    layout: layout,
    className: className
  }, core.jsx(SelectField, {
    id: id,
    hasError: !!error,
    hasHint: !!hint
  }, core.jsx(SelectFieldLabel, {
    size: labelSize,
    isRequired: !!rest.required
  }, label), core.jsx(SelectFieldControl, _extends({
    ref: ref
  }, rest)), core.jsx(SelectFieldHint, null, hint), core.jsx(SelectFieldError, {
    validationMode: validationMode
  }, error)));
});
SelectFieldBlock.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "SelectFieldBlock"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/SelectFieldBlock.tsx"] = {
    name: "SelectFieldBlock",
    docgenInfo: SelectFieldBlock.__docgenInfo,
    path: "src/components/form/components/SelectFieldBlock.tsx"
  };
}

var SelectConnectedField = React__default.forwardRef(function SelectConnectedField(props, ref) {
  var _useConnectedField = useConnectedField(props.name),
      _useConnectedField2 = _slicedToArray(_useConnectedField, 1),
      connectedProps = _useConnectedField2[0];

  return core.jsx(SelectFieldBlock, _extends({
    ref: ref
  }, connectedProps, props));
});
SelectConnectedField.propTypes = {
  name: _pt__default.string.isRequired,
  id: _pt__default.string,
  label: _pt__default.node
};
SelectConnectedField.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "SelectConnectedField"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/SelectConnectedField.tsx"] = {
    name: "SelectConnectedField",
    docgenInfo: SelectConnectedField.__docgenInfo,
    path: "src/components/form/components/SelectConnectedField.tsx"
  };
}

function CheckboxFieldSkeleton(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeleton, props);
}
var CheckboxFieldSkeletonControl = React__default.forwardRef(function CheckboxFieldSkeletonControl(props, ref) {
  var _useFormFieldSkeleton = useFormFieldSkeleton(),
      id = _useFormFieldSkeleton.id,
      hasError = _useFormFieldSkeleton.hasError,
      meta = _useFormFieldSkeleton.meta;

  return /*#__PURE__*/React__default.createElement("input", _extends({
    id: id
  }, props, {
    type: "checkbox",
    "aria-describedby": getFinalAriaDescribedBy(meta.controlDescribedBy, props["aria-describedby"]),
    "aria-invalid": hasError,
    ref: ref
  }));
});
function CheckboxFieldSkeletonLabel(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonLabel, props);
}
function CheckboxFieldSkeletonHint(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonHint, props);
}
function CheckboxFieldSkeletonError(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonError, props);
}
CheckboxFieldSkeleton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxFieldSkeleton"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/CheckboxFieldSkeleton.tsx"] = {
    name: "CheckboxFieldSkeleton",
    docgenInfo: CheckboxFieldSkeleton.__docgenInfo,
    path: "src/components/form-skeletons/components/CheckboxFieldSkeleton.tsx"
  };
}

CheckboxFieldSkeletonControl.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxFieldSkeletonControl"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/CheckboxFieldSkeleton.tsx"] = {
    name: "CheckboxFieldSkeletonControl",
    docgenInfo: CheckboxFieldSkeletonControl.__docgenInfo,
    path: "src/components/form-skeletons/components/CheckboxFieldSkeleton.tsx"
  };
}

CheckboxFieldSkeletonLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxFieldSkeletonLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/CheckboxFieldSkeleton.tsx"] = {
    name: "CheckboxFieldSkeletonLabel",
    docgenInfo: CheckboxFieldSkeletonLabel.__docgenInfo,
    path: "src/components/form-skeletons/components/CheckboxFieldSkeleton.tsx"
  };
}

CheckboxFieldSkeletonHint.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxFieldSkeletonHint"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/CheckboxFieldSkeleton.tsx"] = {
    name: "CheckboxFieldSkeletonHint",
    docgenInfo: CheckboxFieldSkeletonHint.__docgenInfo,
    path: "src/components/form-skeletons/components/CheckboxFieldSkeleton.tsx"
  };
}

CheckboxFieldSkeletonError.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxFieldSkeletonError"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/CheckboxFieldSkeleton.tsx"] = {
    name: "CheckboxFieldSkeletonError",
    docgenInfo: CheckboxFieldSkeletonError.__docgenInfo,
    path: "src/components/form-skeletons/components/CheckboxFieldSkeleton.tsx"
  };
}

function CheckboxField(props) {
  return core.jsx(CheckboxFieldSkeleton, props);
}
var CheckboxFieldControl = React__default.forwardRef(function CheckboxFieldControl(props, ref) {
  var _useFormFieldSkeleton = useFormFieldSkeleton(),
      hasError = _useFormFieldSkeleton.hasError;

  return core.jsx(CheckboxFieldSkeletonControl, _extends({
    ref: ref,
    css: styledCheckboxCss(hasError)
  }, props));
});
var CHECKBOX_WIDTH = "20px";
var CHECKBOX_VERTICAL_OFFSET_CALC = "(1em - 16px) * 0.5";

var getCheckImage = function getCheckImage(color) {
  var encodedColor = encodeURIComponent(color);
  return "url(\"data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7.32505 15.1584L4.19049 10.8791C3.87533 10.423 3.95905 9.80199 4.38373 9.44564L4.38374 9.44564C4.80842 9.08929 5.43452 9.11468 5.82896 9.50424L9.49899 13.3343C10.0964 13.9243 10.0568 14.9003 9.41361 15.44L9.4136 15.44C8.7704 15.9797 7.80237 15.8492 7.32505 15.1584Z' fill='".concat(encodedColor, "'/%3E%3Cpath d='M7.58182 15.4296C6.92843 14.8813 6.86426 13.8988 7.44078 13.2703L14.7221 5.33129C15.0919 4.92814 15.7135 4.88754 16.1326 5.23917L16.1326 5.23917C16.5517 5.59081 16.6196 6.21003 16.2868 6.64418L9.73285 15.1935C9.21392 15.8704 8.23522 15.9779 7.58182 15.4296L7.58182 15.4296Z' fill='").concat(encodedColor, "'/%3E%3Cpath d='M7.747 11.5322C8.1138 11.9724 8.38279 12.2658 8.8474 11.7523C9.31202 11.2388 8.70068 13.0483 8.70068 13.0483L7.18457 12.5593L7.747 11.5322Z' fill='").concat(encodedColor, "'/%3E%3C/svg%3E\")");
};

var _getTheme = getTheme(),
    staticColors = _getTheme.colors;

var styledCheckboxCss = function styledCheckboxCss(hasError) {
  return function (theme) {
    return {
      position: "absolute",
      opacity: 0,
      "&:focus + label::before": _objectSpread2({}, getFocusStyles(theme, hasError)),
      "&:checked + label::before": {
        backgroundColor: theme.colors.purple[60],
        borderColor: theme.colors.purple[60],
        backgroundOrigin: "border-box",
        backgroundImage: getCheckImage(staticColors.white)
      },
      "&:checked:disabled + label::before": {
        backgroundImage: getCheckImage(staticColors.grey[40])
      },
      "&:disabled + label::before": {
        backgroundColor: theme.colors.grey[10],
        borderColor: theme.colors.grey[30],
        cursor: "not-allowed"
      }
    };
  };
};

var sharedStyles = function sharedStyles(theme) {
  return {
    display: "block",
    marginLeft: 0,
    paddingLeft: "calc(".concat(CHECKBOX_WIDTH, " + ").concat(theme.space[4], ")")
  };
};

function CheckboxFieldWrapper(props) {
  return core.jsx("div", props);
}

var labelCss = function labelCss(theme) {
  return {
    cursor: "pointer",
    alignItems: "flex-start",
    marginBottom: 0,
    position: "relative",
    lineHeight: 1.3,
    ":before": {
      backgroundColor: theme.colors.white,
      border: "2px solid ".concat(theme.colors.grey[30]),
      borderRadius: "3px",
      content: "\"\"",
      display: "block",
      height: CHECKBOX_WIDTH,
      marginRight: theme.space[3],
      position: "absolute",
      top: 0,
      left: 0,
      transition: "0.1s ease-in-out",
      transform: "translate(0, calc(".concat(CHECKBOX_VERTICAL_OFFSET_CALC, "))"),
      width: CHECKBOX_WIDTH
    }
  };
};

var labelWithErrorOrHintCss = function labelWithErrorOrHintCss(theme) {
  return {
    marginBottom: theme.space[1]
  };
};

var labelWithErrorCss = function labelWithErrorCss(theme) {
  return {
    ":before": {
      border: "1px solid ".concat(theme.colors.red[60])
    }
  };
};

function CheckboxFieldLabel(_ref) {
  var children = _ref.children,
      size = _ref.size,
      isRequired = _ref.isRequired,
      props = _objectWithoutProperties(_ref, ["children", "size", "isRequired"]);

  var _useFormFieldSkeleton2 = useFormFieldSkeleton(),
      hasError = _useFormFieldSkeleton2.hasError,
      hasHint = _useFormFieldSkeleton2.hasHint;

  var _useStyledFieldLabel = useStyledFieldLabel(children, {
    size: size,
    isRequired: isRequired
  }),
      _css = _useStyledFieldLabel.css,
      styledProps = _objectWithoutProperties(_useStyledFieldLabel, ["css"]);

  return core.jsx(CheckboxFieldSkeletonLabel, _extends({}, props, styledProps, {
    css: function css(theme) {
      return [_css(theme), labelCss(theme), (hasError || hasHint) && labelWithErrorOrHintCss(theme), hasError && labelWithErrorCss(theme), sharedStyles(theme)];
    }
  }));
}
function CheckboxFieldError(_ref2) {
  var children = _ref2.children,
      props = _objectWithoutProperties(_ref2, ["children"]);

  var _useStyledFieldError = useStyledFieldError(children),
      _css2 = _useStyledFieldError.css,
      styledProps = _objectWithoutProperties(_useStyledFieldError, ["css"]);

  return core.jsx(CheckboxFieldSkeletonError, _extends({}, props, styledProps, {
    css: function css(theme) {
      return [_css2(theme), sharedStyles(theme)];
    }
  }));
}
function CheckboxFieldHint(props) {
  var _useStyledFieldHint = useStyledFieldHint(),
      _css3 = _useStyledFieldHint.css,
      styledProps = _objectWithoutProperties(_useStyledFieldHint, ["css"]);

  return core.jsx(CheckboxFieldSkeletonHint, _extends({}, props, styledProps, {
    css: function css(theme) {
      return [_css3(theme), sharedStyles(theme)];
    }
  }));
}
CheckboxField.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxField"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxField.tsx"] = {
    name: "CheckboxField",
    docgenInfo: CheckboxField.__docgenInfo,
    path: "src/components/form/components/CheckboxField.tsx"
  };
}

CheckboxFieldControl.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxFieldControl"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxField.tsx"] = {
    name: "CheckboxFieldControl",
    docgenInfo: CheckboxFieldControl.__docgenInfo,
    path: "src/components/form/components/CheckboxField.tsx"
  };
}

CheckboxFieldWrapper.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxFieldWrapper"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxField.tsx"] = {
    name: "CheckboxFieldWrapper",
    docgenInfo: CheckboxFieldWrapper.__docgenInfo,
    path: "src/components/form/components/CheckboxField.tsx"
  };
}

CheckboxFieldLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxFieldLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxField.tsx"] = {
    name: "CheckboxFieldLabel",
    docgenInfo: CheckboxFieldLabel.__docgenInfo,
    path: "src/components/form/components/CheckboxField.tsx"
  };
}

CheckboxFieldError.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxFieldError"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxField.tsx"] = {
    name: "CheckboxFieldError",
    docgenInfo: CheckboxFieldError.__docgenInfo,
    path: "src/components/form/components/CheckboxField.tsx"
  };
}

CheckboxFieldHint.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxFieldHint"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxField.tsx"] = {
    name: "CheckboxFieldHint",
    docgenInfo: CheckboxFieldHint.__docgenInfo,
    path: "src/components/form/components/CheckboxField.tsx"
  };
}

var CheckboxFieldBlock = React__default.forwardRef(function CheckboxFieldBlock(props, ref) {
  var id = props.id,
      label = props.label,
      labelSize = props.labelSize,
      error = props.error,
      hint = props.hint,
      className = props.className,
      validationMode = props.validationMode,
      rest = _objectWithoutProperties(props, ["id", "label", "labelSize", "error", "hint", "className", "validationMode"]);

  return core.jsx(CheckboxField, {
    id: id,
    hasError: !!error,
    hasHint: !!hint
  }, core.jsx(CheckboxFieldWrapper, {
    className: className
  }, core.jsx(CheckboxFieldControl, _extends({
    ref: ref
  }, rest)), core.jsx(CheckboxFieldLabel, {
    size: labelSize,
    isRequired: !!rest.required
  }, label), core.jsx(CheckboxFieldHint, null, hint), core.jsx(CheckboxFieldError, {
    validationMode: validationMode
  }, error)));
});
CheckboxFieldBlock.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxFieldBlock"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxFieldBlock.tsx"] = {
    name: "CheckboxFieldBlock",
    docgenInfo: CheckboxFieldBlock.__docgenInfo,
    path: "src/components/form/components/CheckboxFieldBlock.tsx"
  };
}

var CheckboxConnectedField = React__default.forwardRef(function CheckboxConnectedField(props, ref) {
  var _useConnectedField = useConnectedField(props.name),
      _useConnectedField2 = _slicedToArray(_useConnectedField, 1),
      connectedProps = _useConnectedField2[0];

  return core.jsx(CheckboxFieldBlock, _extends({
    ref: ref
  }, connectedProps, props));
});
CheckboxConnectedField.propTypes = {
  name: _pt__default.string.isRequired,
  id: _pt__default.string,
  label: _pt__default.node
};
CheckboxConnectedField.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxConnectedField"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxConnectedField.tsx"] = {
    name: "CheckboxConnectedField",
    docgenInfo: CheckboxConnectedField.__docgenInfo,
    path: "src/components/form/components/CheckboxConnectedField.tsx"
  };
}

function FormGroupFieldSkeleton(_ref) {
  var id = _ref.id,
      hasError = _ref.hasError,
      hasHint = _ref.hasHint,
      children = _ref.children,
      className = _ref.className,
      style = _ref.style;
  return /*#__PURE__*/React__default.createElement(FormFieldSkeleton, {
    id: id,
    hasError: hasError,
    hasHint: hasHint
  }, /*#__PURE__*/React__default.createElement("div", {
    role: "group",
    id: id,
    "aria-labelledby": "".concat(id, "__legend"),
    className: className,
    style: style
  }, children));
}
var FormGroupFieldSkeletonLabel = function FormGroupFieldSkeletonLabel(props) {
  var _useFormFieldSkeleton = useFormFieldSkeleton(),
      id = _useFormFieldSkeleton.id;

  return /*#__PURE__*/React__default.createElement("div", _extends({}, props, {
    id: "".concat(id, "__legend")
  }));
};
var FormGroupFieldSkeletonOption = React__default.forwardRef(function FormGroupFieldSkeletonOption(props, ref) {
  var _useFormFieldSkeleton2 = useFormFieldSkeleton(),
      id = _useFormFieldSkeleton2.id,
      hasError = _useFormFieldSkeleton2.hasError,
      meta = _useFormFieldSkeleton2.meta; // We have to set aria-describedby for EACH option (see https://russmaxdesign.github.io/accessible-error-fieldset/)


  return /*#__PURE__*/React__default.createElement("input", _extends({
    id: getGroupOptionId(id, props.value)
  }, props, {
    "aria-describedby": getFinalAriaDescribedBy(meta.controlDescribedBy, props["aria-describedby"]),
    "aria-invalid": hasError,
    ref: ref
  }));
});
FormGroupFieldSkeletonOption.propTypes = {
  name: _pt__default.string.isRequired,
  value: _pt__default.string.isRequired
};
var FormGroupFieldSkeletonOptionLabel = function FormGroupFieldSkeletonOptionLabel(_ref2) {
  var optionValue = _ref2.optionValue,
      rest = _objectWithoutProperties(_ref2, ["optionValue"]);

  var _useFormFieldSkeleton3 = useFormFieldSkeleton(),
      id = _useFormFieldSkeleton3.id;

  return /*#__PURE__*/React__default.createElement("label", _extends({
    htmlFor: getGroupOptionId(id, optionValue)
  }, rest));
};
FormGroupFieldSkeletonOptionLabel.propTypes = {
  optionValue: _pt__default.string.isRequired
};

function getGroupOptionId(fieldId, optionValue) {
  return "".concat(fieldId, "__option--").concat(optionValue);
}

FormGroupFieldSkeleton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "FormGroupFieldSkeleton"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/FormGroupFieldSkeleton.tsx"] = {
    name: "FormGroupFieldSkeleton",
    docgenInfo: FormGroupFieldSkeleton.__docgenInfo,
    path: "src/components/form-skeletons/components/FormGroupFieldSkeleton.tsx"
  };
}

FormGroupFieldSkeletonLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "FormGroupFieldSkeletonLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/FormGroupFieldSkeleton.tsx"] = {
    name: "FormGroupFieldSkeletonLabel",
    docgenInfo: FormGroupFieldSkeletonLabel.__docgenInfo,
    path: "src/components/form-skeletons/components/FormGroupFieldSkeleton.tsx"
  };
}

FormGroupFieldSkeletonOption.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "FormGroupFieldSkeletonOption"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/FormGroupFieldSkeleton.tsx"] = {
    name: "FormGroupFieldSkeletonOption",
    docgenInfo: FormGroupFieldSkeletonOption.__docgenInfo,
    path: "src/components/form-skeletons/components/FormGroupFieldSkeleton.tsx"
  };
}

FormGroupFieldSkeletonOptionLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "FormGroupFieldSkeletonOptionLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/FormGroupFieldSkeleton.tsx"] = {
    name: "FormGroupFieldSkeletonOptionLabel",
    docgenInfo: FormGroupFieldSkeletonOptionLabel.__docgenInfo,
    path: "src/components/form-skeletons/components/FormGroupFieldSkeleton.tsx"
  };
}

function CheckboxGroupFieldSkeleton(props) {
  return /*#__PURE__*/React__default.createElement(FormGroupFieldSkeleton, props);
}
function CheckboxGroupFieldSkeletonLabel(props) {
  return /*#__PURE__*/React__default.createElement(FormGroupFieldSkeletonLabel, props);
}
function CheckboxGroupFieldSkeletonHint(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonHint, props);
}
function CheckboxGroupFieldSkeletonError(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonError, props);
}
var CheckboxGroupFieldSkeletonOption = React__default.forwardRef(function CheckboxGroupFieldSkeletonOption(props, ref) {
  return /*#__PURE__*/React__default.createElement(FormGroupFieldSkeletonOption, _extends({
    ref: ref,
    type: "checkbox"
  }, props));
});
function CheckboxGroupFieldSkeletonOptionLabel(props) {
  return /*#__PURE__*/React__default.createElement(FormGroupFieldSkeletonOptionLabel, props);
}
CheckboxGroupFieldSkeleton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxGroupFieldSkeleton"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/CheckboxGroupFieldSkeleton.tsx"] = {
    name: "CheckboxGroupFieldSkeleton",
    docgenInfo: CheckboxGroupFieldSkeleton.__docgenInfo,
    path: "src/components/form-skeletons/components/CheckboxGroupFieldSkeleton.tsx"
  };
}

CheckboxGroupFieldSkeletonLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxGroupFieldSkeletonLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/CheckboxGroupFieldSkeleton.tsx"] = {
    name: "CheckboxGroupFieldSkeletonLabel",
    docgenInfo: CheckboxGroupFieldSkeletonLabel.__docgenInfo,
    path: "src/components/form-skeletons/components/CheckboxGroupFieldSkeleton.tsx"
  };
}

CheckboxGroupFieldSkeletonHint.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxGroupFieldSkeletonHint"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/CheckboxGroupFieldSkeleton.tsx"] = {
    name: "CheckboxGroupFieldSkeletonHint",
    docgenInfo: CheckboxGroupFieldSkeletonHint.__docgenInfo,
    path: "src/components/form-skeletons/components/CheckboxGroupFieldSkeleton.tsx"
  };
}

CheckboxGroupFieldSkeletonError.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxGroupFieldSkeletonError"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/CheckboxGroupFieldSkeleton.tsx"] = {
    name: "CheckboxGroupFieldSkeletonError",
    docgenInfo: CheckboxGroupFieldSkeletonError.__docgenInfo,
    path: "src/components/form-skeletons/components/CheckboxGroupFieldSkeleton.tsx"
  };
}

CheckboxGroupFieldSkeletonOption.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxGroupFieldSkeletonOption"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/CheckboxGroupFieldSkeleton.tsx"] = {
    name: "CheckboxGroupFieldSkeletonOption",
    docgenInfo: CheckboxGroupFieldSkeletonOption.__docgenInfo,
    path: "src/components/form-skeletons/components/CheckboxGroupFieldSkeleton.tsx"
  };
}

CheckboxGroupFieldSkeletonOptionLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxGroupFieldSkeletonOptionLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/CheckboxGroupFieldSkeleton.tsx"] = {
    name: "CheckboxGroupFieldSkeletonOptionLabel",
    docgenInfo: CheckboxGroupFieldSkeletonOptionLabel.__docgenInfo,
    path: "src/components/form-skeletons/components/CheckboxGroupFieldSkeleton.tsx"
  };
}

var INPUT_WIDTH = "20px";
var INPUT_VERTICAL_OFFSET_CALC = "(1em - 14px) * 0.5";
var FormGroupFieldContext = React__default.createContext({
  optionsDirection: undefined
});
// TODO we can probably do away with context for optionsDirection
// it can be replaced with passing props since in most cases we're going to use *Block or *ConnectedField components
function FormGroupFieldProvider(_ref) {
  var optionsDirection = _ref.optionsDirection,
      children = _ref.children;
  var fieldContext = React__default.useMemo(function () {
    return {
      optionsDirection: optionsDirection
    };
  }, [optionsDirection]);
  return core.jsx(FormGroupFieldContext.Provider, {
    value: fieldContext
  }, children);
}
FormGroupFieldProvider.propTypes = {
  optionsDirection: _pt__default.oneOf(["row", "column"]),
  children: _pt__default.node
};
var formGroupFieldCss = function formGroupFieldCss() {
  return {
    padding: 0,
    margin: 0,
    border: 0
  };
};
function useStyledGroupFieldLabel() {
  var _useStyledFieldLabel = useStyledFieldLabel.apply(void 0, arguments),
      baseCss = _useStyledFieldLabel.css,
      rest = _objectWithoutProperties(_useStyledFieldLabel, ["css"]);

  return _objectSpread2({
    css: function css(theme) {
      return [baseCss(theme), {
        padding: 0,
        marginRight: 0,
        marginLeft: 0,
        width: "100%"
      }];
    }
  }, rest);
}
function useStyledGroupFieldHint() {
  var _useStyledFieldHint = useStyledFieldHint.apply(void 0, arguments),
      baseCss = _useStyledFieldHint.css,
      baseStyledProps = _objectWithoutProperties(_useStyledFieldHint, ["css"]);

  return _objectSpread2({
    css: function css(theme) {
      return [baseCss(theme)];
    }
  }, baseStyledProps);
}
function useStyledGroupFieldError() {
  var _useStyledFieldError = useStyledFieldError.apply(void 0, arguments),
      baseCss = _useStyledFieldError.css,
      baseStyledProps = _objectWithoutProperties(_useStyledFieldError, ["css"]);

  return _objectSpread2({
    css: function css(theme) {
      return [baseCss(theme)];
    }
  }, baseStyledProps);
}

var horizontalOptionsCss = function horizontalOptionsCss(_theme) {
  return {
    display: "flex",
    flexWrap: "wrap"
  };
};

var verticalOptionsCss = function verticalOptionsCss(theme) {
  return [{
    paddingTop: theme.space[3],
    paddingBottom: theme.space[3]
  }];
};

var FormGroupFieldOptions = function FormGroupFieldOptions(props) {
  var _useFormGroupField = useFormGroupField(),
      optionsDirection = _useFormGroupField.optionsDirection;

  var isHorizontal = optionsDirection === "row";
  return isHorizontal ? core.jsx("div", _extends({
    css: horizontalOptionsCss
  }, props)) : core.jsx("div", _extends({
    css: verticalOptionsCss
  }, props));
};
function useStyledGroupFieldOptionLabel(_ref2) {
  var _ref2$size = _ref2.size,
      size = _ref2$size === void 0 ? "L" : _ref2$size;

  var _useFormGroupField2 = useFormGroupField(),
      optionsDirection = _useFormGroupField2.optionsDirection;

  var isHorizontal = optionsDirection === "row";
  return {
    css: function css(theme) {
      return [getLabelFontSize(size, theme), {
        color: theme.colors.grey[90],
        cursor: "pointer",
        justifyContent: "flex-start",
        lineHeight: 1.3,
        paddingLeft: "calc(".concat(INPUT_WIDTH, " + ").concat(isHorizontal ? theme.space[2] : theme.space[4], ")"),
        position: "relative"
      }];
    }
  };
}
var FormGroupFieldOptionWrapper = function FormGroupFieldOptionWrapper(_ref3) {
  var noSpacing = _ref3.noSpacing,
      rest = _objectWithoutProperties(_ref3, ["noSpacing"]);

  var _useFormGroupField3 = useFormGroupField(),
      optionsDirection = _useFormGroupField3.optionsDirection;

  var isHorizontal = optionsDirection === "row";
  return core.jsx("div", _extends({
    css: function css(theme) {
      return [{
        display: "flex",
        alignItems: "center",
        flexShrink: 0
      }, !noSpacing && [{
        marginBottom: theme.space[4]
      }, isHorizontal ? {
        marginRight: theme.space[6]
      } : {
        "&:last-of-type": {
          marginBottom: 0
        }
      }]];
    }
  }, rest));
};
FormGroupFieldOptionWrapper.propTypes = {
  noSpacing: _pt__default.bool
};
function useFormGroupField() {
  return React__default.useContext(FormGroupFieldContext);
}
FormGroupFieldProvider.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "FormGroupFieldProvider",
  "props": {
    "optionsDirection": {
      "required": false,
      "tsType": {
        "name": "union",
        "raw": "`row` | `column`",
        "elements": [{
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }]
      },
      "description": ""
    },
    "children": {
      "required": false,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/FormGroupField.tsx"] = {
    name: "FormGroupFieldProvider",
    docgenInfo: FormGroupFieldProvider.__docgenInfo,
    path: "src/components/form/components/FormGroupField.tsx"
  };
}

FormGroupFieldOptions.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "FormGroupFieldOptions"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/FormGroupField.tsx"] = {
    name: "FormGroupFieldOptions",
    docgenInfo: FormGroupFieldOptions.__docgenInfo,
    path: "src/components/form/components/FormGroupField.tsx"
  };
}

FormGroupFieldOptionWrapper.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "FormGroupFieldOptionWrapper"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/FormGroupField.tsx"] = {
    name: "FormGroupFieldOptionWrapper",
    docgenInfo: FormGroupFieldOptionWrapper.__docgenInfo,
    path: "src/components/form/components/FormGroupField.tsx"
  };
}

function CheckboxGroupField(_ref) {
  var optionsDirection = _ref.optionsDirection,
      rest = _objectWithoutProperties(_ref, ["optionsDirection"]);

  return core.jsx(FormGroupFieldProvider, {
    optionsDirection: optionsDirection
  }, core.jsx(CheckboxGroupFieldSkeleton, _extends({
    css: formGroupFieldCss
  }, rest)));
}
var CheckboxGroupFieldOption = React__default.forwardRef(function CheckboxGroupFieldOption(props, ref) {
  var _useFormFieldSkeleton = useFormFieldSkeleton(),
      hasError = _useFormFieldSkeleton.hasError;

  return core.jsx(CheckboxGroupFieldSkeletonOption, _extends({
    ref: ref,
    css: styledCheckboxCss(hasError)
  }, props));
});
var CheckboxGroupFieldOptionLabel = function CheckboxGroupFieldOptionLabel(_ref2) {
  var size = _ref2.size,
      rest = _objectWithoutProperties(_ref2, ["size"]);

  var _useFormFieldSkeleton2 = useFormFieldSkeleton(),
      hasError = _useFormFieldSkeleton2.hasError;

  var _useStyledGroupFieldO = useStyledGroupFieldOptionLabel({
    size: size
  }),
      _css = _useStyledGroupFieldO.css,
      styledProps = _objectWithoutProperties(_useStyledGroupFieldO, ["css"]);

  return core.jsx(CheckboxGroupFieldSkeletonOptionLabel, _extends({
    css: function css(theme) {
      return [_css(theme), {
        "&:before": {
          backgroundColor: theme.colors.white,
          border: hasError ? "1px solid ".concat(theme.colors.red[60]) : "2px solid ".concat(theme.colors.grey[30]),
          borderRadius: "3px",
          content: "\"\"",
          display: "block",
          height: INPUT_WIDTH,
          marginRight: theme.space[3],
          position: "absolute",
          top: 0,
          left: 0,
          transition: "border-color 0.15s ease-in-out, background 0.15s ease-in-out",
          transform: "translate(0, calc(".concat(INPUT_VERTICAL_OFFSET_CALC, "))"),
          width: INPUT_WIDTH
        }
      }];
    }
  }, rest, styledProps));
};
function CheckboxGroupFieldLabel(_ref3) {
  var children = _ref3.children,
      size = _ref3.size,
      isRequired = _ref3.isRequired,
      props = _objectWithoutProperties(_ref3, ["children", "size", "isRequired"]);

  var styledProps = useStyledGroupFieldLabel(children, {
    size: size,
    isRequired: isRequired
  });
  return core.jsx(CheckboxGroupFieldSkeletonLabel, _extends({}, props, styledProps));
}
function CheckboxGroupFieldHint(props) {
  var styledProps = useStyledGroupFieldHint();
  return core.jsx(CheckboxGroupFieldSkeletonHint, _extends({}, props, styledProps));
}
function CheckboxGroupFieldError(props) {
  var styledProps = useStyledGroupFieldError(props.children);
  return core.jsx(CheckboxGroupFieldSkeletonError, _extends({}, props, styledProps));
}
function CheckboxGroupFieldOptions(props) {
  return core.jsx(FormGroupFieldOptions, props);
}
function CheckboxGroupFieldOptionWrapper(props) {
  return core.jsx(FormGroupFieldOptionWrapper, props);
}
function CheckboxGroupFieldOptionItem(_ref4) {
  var label = _ref4.label,
      value = _ref4.value,
      rest = _objectWithoutProperties(_ref4, ["label", "value"]);

  return core.jsx(CheckboxGroupFieldOptionWrapper, null, core.jsx(CheckboxGroupFieldOption, _extends({
    value: value
  }, rest)), core.jsx(CheckboxGroupFieldOptionLabel, {
    optionValue: value
  }, label));
}
CheckboxGroupFieldOptionItem.propTypes = {
  label: _pt__default.node.isRequired
};
CheckboxGroupField.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxGroupField"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxGroupField.tsx"] = {
    name: "CheckboxGroupField",
    docgenInfo: CheckboxGroupField.__docgenInfo,
    path: "src/components/form/components/CheckboxGroupField.tsx"
  };
}

CheckboxGroupFieldOption.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxGroupFieldOption"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxGroupField.tsx"] = {
    name: "CheckboxGroupFieldOption",
    docgenInfo: CheckboxGroupFieldOption.__docgenInfo,
    path: "src/components/form/components/CheckboxGroupField.tsx"
  };
}

CheckboxGroupFieldOptionLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxGroupFieldOptionLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxGroupField.tsx"] = {
    name: "CheckboxGroupFieldOptionLabel",
    docgenInfo: CheckboxGroupFieldOptionLabel.__docgenInfo,
    path: "src/components/form/components/CheckboxGroupField.tsx"
  };
}

CheckboxGroupFieldLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxGroupFieldLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxGroupField.tsx"] = {
    name: "CheckboxGroupFieldLabel",
    docgenInfo: CheckboxGroupFieldLabel.__docgenInfo,
    path: "src/components/form/components/CheckboxGroupField.tsx"
  };
}

CheckboxGroupFieldHint.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxGroupFieldHint"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxGroupField.tsx"] = {
    name: "CheckboxGroupFieldHint",
    docgenInfo: CheckboxGroupFieldHint.__docgenInfo,
    path: "src/components/form/components/CheckboxGroupField.tsx"
  };
}

CheckboxGroupFieldError.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxGroupFieldError"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxGroupField.tsx"] = {
    name: "CheckboxGroupFieldError",
    docgenInfo: CheckboxGroupFieldError.__docgenInfo,
    path: "src/components/form/components/CheckboxGroupField.tsx"
  };
}

CheckboxGroupFieldOptions.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxGroupFieldOptions"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxGroupField.tsx"] = {
    name: "CheckboxGroupFieldOptions",
    docgenInfo: CheckboxGroupFieldOptions.__docgenInfo,
    path: "src/components/form/components/CheckboxGroupField.tsx"
  };
}

CheckboxGroupFieldOptionWrapper.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxGroupFieldOptionWrapper"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxGroupField.tsx"] = {
    name: "CheckboxGroupFieldOptionWrapper",
    docgenInfo: CheckboxGroupFieldOptionWrapper.__docgenInfo,
    path: "src/components/form/components/CheckboxGroupField.tsx"
  };
}

CheckboxGroupFieldOptionItem.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxGroupFieldOptionItem",
  "props": {
    "label": {
      "required": true,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxGroupField.tsx"] = {
    name: "CheckboxGroupFieldOptionItem",
    docgenInfo: CheckboxGroupFieldOptionItem.__docgenInfo,
    path: "src/components/form/components/CheckboxGroupField.tsx"
  };
}

var CheckboxGroupFieldBlock = function CheckboxGroupFieldBlock(props) {
  var id = props.id,
      label = props.label,
      layout = props.layout,
      optionsDirection = props.optionsDirection,
      labelSize = props.labelSize,
      options = props.options,
      error = props.error,
      hint = props.hint,
      className = props.className,
      validationMode = props.validationMode,
      fieldValue = props.value,
      rest = _objectWithoutProperties(props, ["id", "label", "layout", "optionsDirection", "labelSize", "options", "error", "hint", "className", "validationMode", "value"]);

  var layoutProps = useFormFieldContainerProps(layout);
  return core.jsx(CheckboxGroupField, _extends({
    id: id,
    hasError: !!error,
    hasHint: !!hint,
    optionsDirection: optionsDirection,
    className: className
  }, layoutProps), core.jsx(CheckboxGroupFieldLabel, {
    size: labelSize,
    isRequired: !!rest.required,
    css: function css(_theme) {
      return [layout === "horizontal" && {
        alignSelf: "baseline"
      }];
    }
  }, label), core.jsx(CheckboxGroupFieldOptions, {
    css: function css(_theme) {
      return [layout === "horizontal" && {
        paddingTop: 0
      }];
    }
  }, options.map(function (_ref) {
    var value = _ref.value,
        label = _ref.label,
        restOption = _objectWithoutProperties(_ref, ["value", "label"]);

    return core.jsx(CheckboxGroupFieldOptionItem, _extends({
      key: value,
      value: value // Support uncontrolled field
      ,
      checked: fieldValue === undefined ? undefined : fieldValue.includes(value),
      label: label
    }, rest, restOption));
  })), core.jsx(CheckboxGroupFieldHint, null, hint), core.jsx(CheckboxGroupFieldError, {
    validationMode: validationMode
  }, error));
};
CheckboxGroupFieldBlock.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxGroupFieldBlock"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxGroupFieldBlock.tsx"] = {
    name: "CheckboxGroupFieldBlock",
    docgenInfo: CheckboxGroupFieldBlock.__docgenInfo,
    path: "src/components/form/components/CheckboxGroupFieldBlock.tsx"
  };
}

var CheckboxGroupConnectedField = function CheckboxGroupConnectedField(props) {
  var _useConnectedField = useConnectedField(props.name),
      _useConnectedField2 = _slicedToArray(_useConnectedField, 4),
      connectedProps = _useConnectedField2[0],
      _field = _useConnectedField2[1],
      _meta = _useConnectedField2[2],
      helpers = _useConnectedField2[3];

  var value = connectedProps.value || [];
  return core.jsx(CheckboxGroupFieldBlock, _extends({}, connectedProps, props, {
    onChange: function onChange(e) {
      var target = e.currentTarget;
      var newValue;

      if (target.checked) {
        newValue = [].concat(_toConsumableArray(value), [target.value]);
      } else {
        newValue = value.filter(function (optionValue) {
          return optionValue !== target.value;
        });
      }

      helpers.setValue(newValue);
    },
    onBlur: function onBlur() {
      helpers.setTouched(true);
    }
  }));
};
CheckboxGroupConnectedField.propTypes = {
  name: _pt__default.string.isRequired,
  id: _pt__default.string,
  label: _pt__default.node,
  value: _pt__default.arrayOf(_pt__default.string)
};
CheckboxGroupConnectedField.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "CheckboxGroupConnectedField"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/CheckboxGroupConnectedField.tsx"] = {
    name: "CheckboxGroupConnectedField",
    docgenInfo: CheckboxGroupConnectedField.__docgenInfo,
    path: "src/components/form/components/CheckboxGroupConnectedField.tsx"
  };
}

function RadioButtonFieldSkeleton(props) {
  return /*#__PURE__*/React__default.createElement(FormGroupFieldSkeleton, props);
}
function RadioButtonFieldSkeletonLabel(props) {
  return /*#__PURE__*/React__default.createElement(FormGroupFieldSkeletonLabel, props);
}
function RadioButtonFieldSkeletonHint(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonHint, props);
}
function RadioButtonFieldSkeletonError(props) {
  return /*#__PURE__*/React__default.createElement(FormFieldSkeletonError, props);
}
var RadioButtonFieldSkeletonOption = React__default.forwardRef(function RadioButtonFieldSkeletonOption(props, ref) {
  return /*#__PURE__*/React__default.createElement(FormGroupFieldSkeletonOption, _extends({
    ref: ref,
    type: "radio"
  }, props));
});
function RadioButtonFieldSkeletonOptionLabel(props) {
  return /*#__PURE__*/React__default.createElement(FormGroupFieldSkeletonOptionLabel, props);
}
RadioButtonFieldSkeleton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RadioButtonFieldSkeleton"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/RadioButtonFieldSkeleton.tsx"] = {
    name: "RadioButtonFieldSkeleton",
    docgenInfo: RadioButtonFieldSkeleton.__docgenInfo,
    path: "src/components/form-skeletons/components/RadioButtonFieldSkeleton.tsx"
  };
}

RadioButtonFieldSkeletonLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RadioButtonFieldSkeletonLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/RadioButtonFieldSkeleton.tsx"] = {
    name: "RadioButtonFieldSkeletonLabel",
    docgenInfo: RadioButtonFieldSkeletonLabel.__docgenInfo,
    path: "src/components/form-skeletons/components/RadioButtonFieldSkeleton.tsx"
  };
}

RadioButtonFieldSkeletonHint.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RadioButtonFieldSkeletonHint"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/RadioButtonFieldSkeleton.tsx"] = {
    name: "RadioButtonFieldSkeletonHint",
    docgenInfo: RadioButtonFieldSkeletonHint.__docgenInfo,
    path: "src/components/form-skeletons/components/RadioButtonFieldSkeleton.tsx"
  };
}

RadioButtonFieldSkeletonError.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RadioButtonFieldSkeletonError"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/RadioButtonFieldSkeleton.tsx"] = {
    name: "RadioButtonFieldSkeletonError",
    docgenInfo: RadioButtonFieldSkeletonError.__docgenInfo,
    path: "src/components/form-skeletons/components/RadioButtonFieldSkeleton.tsx"
  };
}

RadioButtonFieldSkeletonOption.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RadioButtonFieldSkeletonOption"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/RadioButtonFieldSkeleton.tsx"] = {
    name: "RadioButtonFieldSkeletonOption",
    docgenInfo: RadioButtonFieldSkeletonOption.__docgenInfo,
    path: "src/components/form-skeletons/components/RadioButtonFieldSkeleton.tsx"
  };
}

RadioButtonFieldSkeletonOptionLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RadioButtonFieldSkeletonOptionLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form-skeletons/components/RadioButtonFieldSkeleton.tsx"] = {
    name: "RadioButtonFieldSkeletonOptionLabel",
    docgenInfo: RadioButtonFieldSkeletonOptionLabel.__docgenInfo,
    path: "src/components/form-skeletons/components/RadioButtonFieldSkeleton.tsx"
  };
}

function RadioButtonField(_ref) {
  var optionsDirection = _ref.optionsDirection,
      rest = _objectWithoutProperties(_ref, ["optionsDirection"]);

  return core.jsx(FormGroupFieldProvider, {
    optionsDirection: optionsDirection
  }, core.jsx(RadioButtonFieldSkeleton, _extends({
    css: function css(theme) {
      return [formGroupFieldCss()];
    }
  }, rest)));
}

var getCheckImage$1 = function getCheckImage(color) {
  var encodedColor = encodeURIComponent(color);
  return "url(\"data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M20 0H0V20H20V0ZM10 14C12.2091 14 14 12.2091 14 10C14 7.79086 12.2091 6 10 6C7.79086 6 6 7.79086 6 10C6 12.2091 7.79086 14 10 14Z' fill='".concat(encodedColor, "'/%3E%3C/svg%3E%0A\")");
};

var _getTheme$1 = getTheme(),
    staticColors$1 = _getTheme$1.colors;

var RadioButtonFieldOption = React__default.forwardRef(function RadioButtonFieldOption(props, ref) {
  return core.jsx(RadioButtonFieldSkeletonOption, _extends({
    ref: ref,
    css: function css(theme) {
      return [{
        position: "absolute",
        opacity: 0,
        "&:checked + label": {
          borderColor: theme.colors.purple[60]
        },
        "&:checked + label::before": {
          borderColor: theme.colors.purple[60],
          backgroundColor: theme.colors.purple[60],
          backgroundOrigin: "border-box",
          backgroundImage: getCheckImage$1(staticColors$1.white)
        },
        "&:not(:checked):not(:disabled):hover + label::before": {
          borderColor: theme.colors.purple[40]
        },
        "&:disabled + label::before": {
          backgroundColor: theme.colors.grey[10],
          borderColor: theme.colors.grey[30],
          cursor: "not-allowed"
        },
        "&:checked:disabled + label::before": {
          backgroundImage: getCheckImage$1(staticColors$1.grey[10]),
          backgroundColor: theme.colors.grey[40]
        },
        "&:focus + label::before": _objectSpread2({}, getFocusStyles(theme), {
          transition: "border-color 0.15s ease-in-out, background 0.15s ease-in-out"
        })
      }];
    }
  }, props));
});

var getFrameStyles = function getFrameStyles(theme) {
  return {
    border: "2px solid ".concat(theme.colors.white),
    borderRadius: theme.radii[3],
    margin: 0,
    width: "100%",
    transition: "border .15s ease-in-out"
  };
};

var RadioButtonFieldOptionLabel = function RadioButtonFieldOptionLabel(_ref2) {
  var size = _ref2.size,
      variant = _ref2.variant,
      rest = _objectWithoutProperties(_ref2, ["size", "variant"]);

  var _useFormFieldSkeleton = useFormFieldSkeleton(),
      hasError = _useFormFieldSkeleton.hasError;

  var _useStyledGroupFieldO = useStyledGroupFieldOptionLabel({
    size: size
  }),
      _css = _useStyledGroupFieldO.css,
      styledProps = _objectWithoutProperties(_useStyledGroupFieldO, ["css"]);

  return core.jsx(RadioButtonFieldSkeletonOptionLabel, _extends({
    css: function css(theme) {
      return [_css(theme), {
        display: "block",
        margin: 0,
        "&:before": {
          backgroundColor: theme.colors.white,
          border: hasError ? "1px solid ".concat(theme.colors.red[60]) : "2px solid ".concat(theme.colors.grey[30]),
          display: "block",
          borderRadius: "50%",
          content: "\"\"",
          height: INPUT_WIDTH,
          position: "absolute",
          top: 0,
          left: 0,
          transition: "border-color 0.15s ease-in-out",
          transform: "translate(0, calc(".concat(INPUT_VERTICAL_OFFSET_CALC, "))"),
          width: INPUT_WIDTH
        }
      }, variant === "framed" && [getFrameStyles(theme), {
        padding: "".concat(theme.space[4], " ").concat(theme.space[5]),
        paddingLeft: "calc(".concat(INPUT_WIDTH, " + ").concat(theme.space[7], ")"),
        "&:before": {
          left: theme.space[4],
          top: theme.space[4]
        }
      }]];
    }
  }, rest, styledProps));
};
RadioButtonFieldOptionLabel.propTypes = {
  variant: _pt__default.oneOf(["default", "framed"]).isRequired
};
function RadioButtonFieldLabel(_ref3) {
  var children = _ref3.children,
      size = _ref3.size,
      isRequired = _ref3.isRequired,
      props = _objectWithoutProperties(_ref3, ["children", "size", "isRequired"]);

  var styledProps = useStyledGroupFieldLabel(children, {
    size: size,
    isRequired: isRequired
  });
  return core.jsx(RadioButtonFieldSkeletonLabel, _extends({}, props, styledProps));
}
function RadioButtonFieldHint(props) {
  var styledProps = useStyledGroupFieldHint();
  return core.jsx(RadioButtonFieldSkeletonHint, _extends({}, props, styledProps));
}
function RadioButtonFieldError(props) {
  var styledProps = useStyledGroupFieldError(props.children);
  return core.jsx(RadioButtonFieldSkeletonError, _extends({}, props, styledProps));
}
function RadioButtonFieldOptions(props) {
  return core.jsx(FormGroupFieldOptions, props);
}
function RadioButtonFieldOptionWrapper(_ref4) {
  var variant = _ref4.variant,
      rest = _objectWithoutProperties(_ref4, ["variant"]);

  return core.jsx(FormGroupFieldOptionWrapper, _extends({}, rest, {
    noSpacing: variant === "framed"
  }));
}
RadioButtonFieldOptionWrapper.propTypes = {
  variant: _pt__default.oneOf(["default", "framed"]).isRequired
};
function RadioButtonFieldOptionItem(_ref5) {
  var label = _ref5.label,
      value = _ref5.value,
      _ref5$variant = _ref5.variant,
      variant = _ref5$variant === void 0 ? "default" : _ref5$variant,
      rest = _objectWithoutProperties(_ref5, ["label", "value", "variant"]);

  return core.jsx(RadioButtonFieldOptionWrapper, {
    variant: variant
  }, core.jsx(RadioButtonFieldOption, _extends({
    value: value
  }, rest)), core.jsx(RadioButtonFieldOptionLabel, {
    optionValue: value,
    variant: variant
  }, label));
}
RadioButtonFieldOptionItem.propTypes = {
  label: _pt__default.node.isRequired,
  variant: _pt__default.oneOf(["default", "framed"])
};
RadioButtonField.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RadioButtonField"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/RadioButtonField.tsx"] = {
    name: "RadioButtonField",
    docgenInfo: RadioButtonField.__docgenInfo,
    path: "src/components/form/components/RadioButtonField.tsx"
  };
}

RadioButtonFieldOption.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RadioButtonFieldOption"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/RadioButtonField.tsx"] = {
    name: "RadioButtonFieldOption",
    docgenInfo: RadioButtonFieldOption.__docgenInfo,
    path: "src/components/form/components/RadioButtonField.tsx"
  };
}

RadioButtonFieldOptionLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RadioButtonFieldOptionLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/RadioButtonField.tsx"] = {
    name: "RadioButtonFieldOptionLabel",
    docgenInfo: RadioButtonFieldOptionLabel.__docgenInfo,
    path: "src/components/form/components/RadioButtonField.tsx"
  };
}

RadioButtonFieldLabel.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RadioButtonFieldLabel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/RadioButtonField.tsx"] = {
    name: "RadioButtonFieldLabel",
    docgenInfo: RadioButtonFieldLabel.__docgenInfo,
    path: "src/components/form/components/RadioButtonField.tsx"
  };
}

RadioButtonFieldHint.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RadioButtonFieldHint"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/RadioButtonField.tsx"] = {
    name: "RadioButtonFieldHint",
    docgenInfo: RadioButtonFieldHint.__docgenInfo,
    path: "src/components/form/components/RadioButtonField.tsx"
  };
}

RadioButtonFieldError.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RadioButtonFieldError"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/RadioButtonField.tsx"] = {
    name: "RadioButtonFieldError",
    docgenInfo: RadioButtonFieldError.__docgenInfo,
    path: "src/components/form/components/RadioButtonField.tsx"
  };
}

RadioButtonFieldOptions.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RadioButtonFieldOptions"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/RadioButtonField.tsx"] = {
    name: "RadioButtonFieldOptions",
    docgenInfo: RadioButtonFieldOptions.__docgenInfo,
    path: "src/components/form/components/RadioButtonField.tsx"
  };
}

RadioButtonFieldOptionWrapper.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RadioButtonFieldOptionWrapper",
  "props": {
    "variant": {
      "required": true,
      "tsType": {
        "name": "union",
        "raw": "\"default\" | \"framed\"",
        "elements": [{
          "name": "literal",
          "value": "\"default\""
        }, {
          "name": "literal",
          "value": "\"framed\""
        }]
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/RadioButtonField.tsx"] = {
    name: "RadioButtonFieldOptionWrapper",
    docgenInfo: RadioButtonFieldOptionWrapper.__docgenInfo,
    path: "src/components/form/components/RadioButtonField.tsx"
  };
}

RadioButtonFieldOptionItem.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RadioButtonFieldOptionItem",
  "props": {
    "variant": {
      "defaultValue": {
        "value": "`default`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "union",
        "raw": "\"default\" | \"framed\"",
        "elements": [{
          "name": "literal",
          "value": "\"default\""
        }, {
          "name": "literal",
          "value": "\"framed\""
        }]
      },
      "description": ""
    },
    "label": {
      "required": true,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/RadioButtonField.tsx"] = {
    name: "RadioButtonFieldOptionItem",
    docgenInfo: RadioButtonFieldOptionItem.__docgenInfo,
    path: "src/components/form/components/RadioButtonField.tsx"
  };
}

var RadioButtonFieldBlock = function RadioButtonFieldBlock(props) {
  var id = props.id,
      label = props.label,
      labelSize = props.labelSize,
      error = props.error,
      hint = props.hint,
      className = props.className,
      validationMode = props.validationMode,
      fieldValue = props.value,
      options = props.options,
      layout = props.layout,
      optionsDirection = props.optionsDirection,
      variant = props.variant,
      rest = _objectWithoutProperties(props, ["id", "label", "labelSize", "error", "hint", "className", "validationMode", "value", "options", "layout", "optionsDirection", "variant"]);

  var layoutProps = useFormFieldContainerProps(layout);
  return core.jsx(RadioButtonField, _extends({
    id: id,
    hasError: !!error,
    hasHint: !!hint,
    optionsDirection: optionsDirection,
    className: className
  }, layoutProps), core.jsx(RadioButtonFieldLabel, {
    size: labelSize,
    isRequired: !!rest.required,
    css: function css(_theme) {
      return [layout === "horizontal" && {
        alignSelf: "baseline"
      }];
    }
  }, label), core.jsx(RadioButtonFieldOptions, {
    css: function css(_theme) {
      return [layout === "horizontal" && {
        paddingTop: 0
      }];
    }
  }, options.map(function (_ref) {
    var value = _ref.value,
        label = _ref.label,
        restOption = _objectWithoutProperties(_ref, ["value", "label"]);

    return core.jsx(RadioButtonFieldOptionItem, _extends({
      key: value,
      value: value // Support uncontrolled field
      ,
      checked: fieldValue === undefined ? undefined : value === fieldValue,
      label: label,
      variant: variant
    }, rest, restOption));
  })), core.jsx(RadioButtonFieldHint, null, hint), core.jsx(RadioButtonFieldError, {
    validationMode: validationMode
  }, error));
};
RadioButtonFieldBlock.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RadioButtonFieldBlock"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/RadioButtonFieldBlock.tsx"] = {
    name: "RadioButtonFieldBlock",
    docgenInfo: RadioButtonFieldBlock.__docgenInfo,
    path: "src/components/form/components/RadioButtonFieldBlock.tsx"
  };
}

var RadioButtonConnectedField = function RadioButtonConnectedField(props) {
  var _useConnectedField = useConnectedField(props.name),
      _useConnectedField2 = _slicedToArray(_useConnectedField, 1),
      connectedProps = _useConnectedField2[0];

  return core.jsx(RadioButtonFieldBlock, _extends({}, connectedProps, props));
};
RadioButtonConnectedField.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "RadioButtonConnectedField"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/form/components/RadioButtonConnectedField.tsx"] = {
    name: "RadioButtonConnectedField",
    docgenInfo: RadioButtonConnectedField.__docgenInfo,
    path: "src/components/form/components/RadioButtonConnectedField.tsx"
  };
}

var concealedValueContainerCss = function concealedValueContainerCss(theme) {
  return {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    padding: theme.space[2],
    width: "100%"
  };
};
var concealedValueContentCss = function concealedValueContentCss(theme) {
  return {
    overflow: "hidden",
    flexGrow: 1,
    marginRight: theme.space[4]
  };
};
var concealedValueActionsCss = {};
var concealedValueInputCss = function concealedValueInputCss(theme) {
  return {
    border: "none",
    overflow: "hidden",
    fontFamily: theme.fonts.heading,
    fontSize: theme.fontSizes[1],
    color: theme.tones["NEUTRAL"].text,
    width: "100%"
  };
};
var concealedValueButtonCss = function concealedValueButtonCss(theme) {
  return {
    marginLeft: theme.space[2]
  };
};

function ConcealedValue(_ref) {
  var value = _ref.value,
      ariaLabel = _ref.ariaLabel,
      _ref$concealed = _ref.concealed,
      concealed = _ref$concealed === void 0 ? true : _ref$concealed,
      _ref$delay = _ref.delay,
      delay = _ref$delay === void 0 ? 5000 : _ref$delay;

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isCopied = _useState2[0],
      setIsCopied = _useState2[1];

  var _useState3 = React.useState(concealed),
      _useState4 = _slicedToArray(_useState3, 2),
      isConcealed = _useState4[0],
      setIsConcealed = _useState4[1];

  var copyHandler = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return copyToClipboard(value);

            case 2:
              setIsCopied(true);
              setTimeout(function () {
                setIsCopied(false);
              }, delay);

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function copyHandler() {
      return _ref2.apply(this, arguments);
    };
  }();

  var revealHandler = function revealHandler() {
    setIsConcealed(!isConcealed);
  };

  return core.jsx("div", {
    css: concealedValueContainerCss
  }, core.jsx("div", {
    css: concealedValueContentCss
  }, isConcealed ? // classic password dots
  core.jsx("input", {
    css: concealedValueInputCss,
    type: "text",
    value: "\u2022 \u2022 \u2022 \u2022 \u2022 \u2022",
    "aria-label": "Hidden value of ".concat(ariaLabel),
    readOnly: true
  }) : // unmasked value
  core.jsx("input", {
    css: concealedValueInputCss,
    type: "text",
    value: value,
    "aria-label": ariaLabel,
    readOnly: true
  })), core.jsx("div", {
    css: concealedValueActionsCss
  }, core.jsx(Button, {
    size: "S",
    tone: "NEUTRAL",
    variant: "SECONDARY",
    css: concealedValueButtonCss,
    onClick: copyHandler
  }, isCopied ? "Copied" : "Copy"), core.jsx(Button, {
    size: "S",
    tone: "NEUTRAL",
    variant: "SECONDARY",
    css: concealedValueButtonCss,
    onClick: revealHandler
  }, isConcealed ? "Reveal" : "Conceal")));
}
ConcealedValue.propTypes = {
  value: _pt__default.string.isRequired,
  ariaLabel: _pt__default.string.isRequired,
  delay: _pt__default.number,
  concealed: _pt__default.bool
};
ConcealedValue.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "ConcealedValue",
  "props": {
    "concealed": {
      "defaultValue": {
        "value": "true",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "boolean"
      },
      "description": ""
    },
    "delay": {
      "defaultValue": {
        "value": "5000",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "number"
      },
      "description": ""
    },
    "value": {
      "required": true,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "ariaLabel": {
      "required": true,
      "tsType": {
        "name": "string"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/ConcealedValue/ConcealedValue.tsx"] = {
    name: "ConcealedValue",
    docgenInfo: ConcealedValue.__docgenInfo,
    path: "src/components/ConcealedValue/ConcealedValue.tsx"
  };
}

function _extends$9() {
  _extends$9 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$9.apply(this, arguments);
}

function _objectWithoutPropertiesLoose$b(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

// Actions

var CLEAR_SELECTION_INDEX = "CLEAR_SELECTION_INDEX";
var CLICK_MENU_ITEM = "CLICK_MENU_ITEM";
var CLOSE_MENU = "CLOSE_MENU";
var OPEN_MENU_AT_FIRST_ITEM = "OPEN_MENU_AT_FIRST_ITEM";
var OPEN_MENU_CLEARED = "OPEN_MENU_CLEARED";
var SEARCH_FOR_ITEM = "SEARCH_FOR_ITEM";
var SELECT_ITEM_AT_INDEX = "SELECT_ITEM_AT_INDEX";
var SET_BUTTON_ID = "SET_BUTTON_ID";
var MenuDescendantContext = /*#__PURE__*/createDescendantContext("MenuDescendantContext");
var MenuContext = /*#__PURE__*/createNamedContext("MenuContext", {});
var initialState = {
  // The button ID is needed for aria controls and can be set directly and
  // updated for top-level use via context. Otherwise a default is set by useId.
  // TODO: Consider deprecating direct ID in 1.0 in favor of id at the top level
  //       for passing deterministic IDs to descendent components.
  buttonId: null,
  // Whether or not the menu is expanded
  isExpanded: false,
  // When a user begins typing a character string, the selection will change if
  // a matching item is found
  typeaheadQuery: "",
  // The index of the current selected item. When the selection is cleared a
  // value of -1 is used.
  selectionIndex: -1
}; ////////////////////////////////////////////////////////////////////////////////

/**
 * Menu
 *
 * The wrapper component for the other components. No DOM element is rendered.
 *
 * @see Docs https://reacttraining.com/reach-ui/menu-button#menu
 */

var Menu = function Menu(_ref) {
  var id = _ref.id,
      children = _ref.children;
  var buttonRef = React.useRef(null);
  var menuRef = React.useRef(null);
  var popoverRef = React.useRef(null);

  var _useDescendantsInit = useDescendantsInit(),
      descendants = _useDescendantsInit[0],
      setDescendants = _useDescendantsInit[1];

  var _useReducer = React.useReducer(reducer$1, initialState),
      state = _useReducer[0],
      dispatch = _useReducer[1];

  var _id = useId(id);

  var menuId = id || makeId("menu", _id); // We use an event listener attached to the window to capture outside clicks
  // that close the menu. We don't want the initial button click to trigger this
  // when a menu is closed, so we can track this behavior in a ref for now.
  // We shouldn't need this when we rewrite with state machine logic.

  var buttonClickedRef = React.useRef(false); // We will put children callbacks in a ref to avoid triggering endless render
  // loops when using render props if the app code doesn't useCallback
  // https://github.com/reach/reach-ui/issues/523

  var selectCallbacks = React.useRef([]);
  var context = {
    buttonRef: buttonRef,
    dispatch: dispatch,
    menuId: menuId,
    menuRef: menuRef,
    popoverRef: popoverRef,
    buttonClickedRef: buttonClickedRef,
    selectCallbacks: selectCallbacks,
    state: state
  }; // When the menu is open, focus is placed on the menu itself so that
  // keyboard navigation is still possible.

  React.useEffect(function () {
    if (state.isExpanded) {
      // @ts-ignore
      window.__REACH_DISABLE_TOOLTIPS = true;
      window.requestAnimationFrame(function () {
        focus(menuRef.current);
      });
    } else {
      // We want to ignore the immediate focus of a tooltip so it doesn't pop
      // up again when the menu closes, only pops up when focus returns again
      // to the tooltip (like native OS tooltips).
      // @ts-ignore
      window.__REACH_DISABLE_TOOLTIPS = false;
    }
  }, [state.isExpanded]);
  React.useEffect(function () {
    return checkStyles("menu-button");
  }, []);
  return React__default.createElement(DescendantProvider, {
    context: MenuDescendantContext,
    items: descendants,
    set: setDescendants
  }, React__default.createElement(MenuContext.Provider, {
    value: context
  }, isFunction$2(children) ? children({
    isExpanded: state.isExpanded,
    // TODO: Remove in 1.0
    isOpen: state.isExpanded
  }) : children));
};

if (process.env.NODE_ENV !== "production") {
  Menu.displayName = "Menu";
  Menu.propTypes = {
    children: /*#__PURE__*/_pt__default.oneOfType([_pt__default.func, _pt__default.node])
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * MenuButton
 *
 * Wraps a DOM `button` that toggles the opening and closing of the dropdown
 * menu. Must be rendered inside of a `<Menu>`.
 *
 * @see Docs https://reacttraining.com/reach-ui/menu-button#menubutton
 */


var MenuButton = /*#__PURE__*/forwardRefWithAs(function MenuButton(_ref2, forwardedRef) {
  var _ref2$as = _ref2.as,
      Comp = _ref2$as === void 0 ? "button" : _ref2$as,
      onKeyDown = _ref2.onKeyDown,
      onMouseDown = _ref2.onMouseDown,
      id = _ref2.id,
      props = _objectWithoutPropertiesLoose$b(_ref2, ["as", "onKeyDown", "onMouseDown", "id"]);

  var _useContext = React.useContext(MenuContext),
      buttonRef = _useContext.buttonRef,
      buttonClickedRef = _useContext.buttonClickedRef,
      menuId = _useContext.menuId,
      _useContext$state = _useContext.state,
      buttonId = _useContext$state.buttonId,
      isExpanded = _useContext$state.isExpanded,
      dispatch = _useContext.dispatch;

  var ref = useForkedRef(buttonRef, forwardedRef);
  React.useEffect(function () {
    var newButtonId = id != null ? id : menuId ? makeId("menu-button", menuId) : "menu-button";

    if (buttonId !== newButtonId) {
      dispatch({
        type: SET_BUTTON_ID,
        payload: newButtonId
      });
    }
  }, [buttonId, dispatch, id, menuId]);

  function handleKeyDown(event) {
    switch (event.key) {
      case "ArrowDown":
      case "ArrowUp":
        event.preventDefault(); // prevent scroll

        dispatch({
          type: OPEN_MENU_AT_FIRST_ITEM
        });
        break;

      case "Enter":
      case " ":
        dispatch({
          type: OPEN_MENU_AT_FIRST_ITEM
        });
        break;
    }
  }

  function handleMouseDown(event) {
    if (!isExpanded) {
      buttonClickedRef.current = true;
    }

    if (isRightClick(event.nativeEvent)) {
      return;
    } else if (isExpanded) {
      dispatch({
        type: CLOSE_MENU,
        payload: {
          buttonRef: buttonRef
        }
      });
    } else {
      dispatch({
        type: OPEN_MENU_CLEARED
      });
    }
  }

  return React__default.createElement(Comp // When the menu is displayed, the element with role `button` has
  // `aria-expanded` set to `true`. When the menu is hidden, it is
  // recommended that `aria-expanded` is not present.
  // https://www.w3.org/TR/wai-aria-practices-1.2/#menubutton
  , Object.assign({
    "aria-expanded": isExpanded ? true : undefined,
    "aria-haspopup": true,
    "aria-controls": menuId
  }, props, {
    ref: ref,
    "data-reach-menu-button": "",
    id: buttonId || undefined,
    onKeyDown: wrapEvent(onKeyDown, handleKeyDown),
    onMouseDown: wrapEvent(onMouseDown, handleMouseDown),
    type: "button"
  }));
});

if (process.env.NODE_ENV !== "production") {
  MenuButton.displayName = "MenuButton";
  MenuButton.propTypes = {
    children: _pt__default.node
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * MenuItemImpl
 *
 * MenuItem and MenuLink share most of the same functionality captured here.
 */


var MenuItemImpl = /*#__PURE__*/forwardRefWithAs(function MenuItemImpl(_ref3, forwardedRef) {
  var Comp = _ref3.as,
      indexProp = _ref3.index,
      _ref3$isLink = _ref3.isLink,
      isLink = _ref3$isLink === void 0 ? false : _ref3$isLink,
      onClick = _ref3.onClick,
      onDragStart = _ref3.onDragStart,
      onMouseDown = _ref3.onMouseDown,
      onMouseEnter = _ref3.onMouseEnter,
      onMouseLeave = _ref3.onMouseLeave,
      onMouseMove = _ref3.onMouseMove,
      onMouseUp = _ref3.onMouseUp,
      onSelect = _ref3.onSelect,
      valueTextProp = _ref3.valueText,
      props = _objectWithoutPropertiesLoose$b(_ref3, ["as", "index", "isLink", "onClick", "onDragStart", "onMouseDown", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseUp", "onSelect", "valueText"]);

  var _useContext2 = React.useContext(MenuContext),
      buttonRef = _useContext2.buttonRef,
      dispatch = _useContext2.dispatch,
      selectCallbacks = _useContext2.selectCallbacks,
      selectionIndex = _useContext2.state.selectionIndex;

  var ownRef = React.useRef(null); // After the ref is mounted to the DOM node, we check to see if we have an
  // explicit valueText prop before looking for the node's textContent for
  // typeahead functionality.

  var _useState = React.useState(valueTextProp || ""),
      valueText = _useState[0],
      setValueText = _useState[1];

  var setValueTextFromDom = React.useCallback(function (node) {
    if (node) {
      ownRef.current = node;

      if (!valueTextProp || node.textContent && valueText !== node.textContent) {
        setValueText(node.textContent);
      }
    }
  }, [valueText, valueTextProp]);
  var ref = useForkedRef(forwardedRef, setValueTextFromDom);
  var mouseEventStarted = React.useRef(false);
  var index = useDescendant({
    element: ownRef.current,
    key: valueText,
    isLink: isLink
  }, MenuDescendantContext, indexProp);
  var isSelected = index === selectionIndex; // Update the callback ref array on every render

  selectCallbacks.current[index] = onSelect;

  function select() {
    focus(buttonRef.current);
    onSelect && onSelect();
    dispatch({
      type: CLICK_MENU_ITEM
    });
  }

  function handleClick(event) {
    if (isLink && !isRightClick(event.nativeEvent)) {
      select();
    }
  }

  function handleDragStart(event) {
    // Because we don't preventDefault on mousedown for links (we need the
    // native click event), clicking and holding on a link triggers a
    // dragstart which we don't want.
    if (isLink) {
      event.preventDefault();
    }
  }

  function handleMouseDown(event) {
    if (isRightClick(event.nativeEvent)) return;

    if (isLink) {
      // Signal that the mouse is down so we can react call the right function
      // if the user is clicking on a link.
      mouseEventStarted.current = true;
    } else {
      event.preventDefault();
    }
  }

  function handleMouseEnter(event) {
    if (!isSelected && index != null) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: index
        }
      });
    }
  }

  function handleMouseLeave(event) {
    // Clear out selection when mouse over a non-menu item child.
    dispatch({
      type: CLEAR_SELECTION_INDEX
    });
  }

  function handleMouseMove(event) {
    if (!isSelected && index != null) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: index
        }
      });
    }
  }

  function handleMouseUp(event) {
    if (isRightClick(event.nativeEvent)) return;

    if (isLink) {
      // If a mousedown event was initiated on a menu link followed by a
      // mouseup event on the same link, we do nothing; a click event will
      // come next and handle selection. Otherwise, we trigger a click event.
      if (mouseEventStarted.current) {
        mouseEventStarted.current = false;
      } else if (ownRef.current) {
        ownRef.current.click();
      }
    } else {
      select();
    }
  } // Any time a mouseup event occurs anywhere in the document, we reset the
  // mouseEventStarted ref so we can check it again when needed.


  React.useEffect(function () {
    var ownerDocument = getOwnerDocument(ownRef.current) || document;

    var listener = function listener() {
      return mouseEventStarted.current = false;
    };

    ownerDocument.addEventListener("mouseup", listener);
    return function () {
      return ownerDocument.removeEventListener("mouseup", listener);
    };
  }, []);
  return React__default.createElement(Comp, Object.assign({
    role: "menuitem",
    id: useMenuItemId(index),
    tabIndex: -1
  }, props, {
    ref: ref,
    "data-reach-menu-item": "",
    "data-selected": isSelected ? "" : undefined,
    "data-valuetext": valueText,
    onClick: wrapEvent(onClick, handleClick),
    onDragStart: wrapEvent(onDragStart, handleDragStart),
    onMouseDown: wrapEvent(onMouseDown, handleMouseDown),
    onMouseEnter: wrapEvent(onMouseEnter, handleMouseEnter),
    onMouseLeave: wrapEvent(onMouseLeave, handleMouseLeave),
    onMouseMove: wrapEvent(onMouseMove, handleMouseMove),
    onMouseUp: wrapEvent(onMouseUp, handleMouseUp)
  }));
}); ////////////////////////////////////////////////////////////////////////////////

/**
 * MenuItem
 *
 * Handles menu selection. Must be a direct child of a `<MenuList>`.
 *
 * @see Docs https://reacttraining.com/reach-ui/menu-button#menuitem
 */

var MenuItem = /*#__PURE__*/forwardRefWithAs(function MenuItem(_ref4, forwardedRef) {
  var _ref4$as = _ref4.as,
      as = _ref4$as === void 0 ? "div" : _ref4$as,
      props = _objectWithoutPropertiesLoose$b(_ref4, ["as"]);

  return React__default.createElement(MenuItemImpl, Object.assign({}, props, {
    ref: forwardedRef,
    as: as
  }));
});

if (process.env.NODE_ENV !== "production") {
  MenuItem.displayName = "MenuItem";
  MenuItem.propTypes = {
    as: _pt__default.any,
    onSelect: _pt__default.func.isRequired
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * MenuItems
 *
 * A low-level wrapper for menu items. Compose it with `MenuPopover` for more
 * control over the nested components and their rendered DOM nodes, or if you
 * need to nest arbitrary components between the outer wrapper and your list.
 *
 * @see Docs https://reacttraining.com/reach-ui/menu-button#menuitems
 */


var MenuItems = /*#__PURE__*/forwardRefWithAs(function MenuItems(_ref5, forwardedRef) {
  var _ref5$as = _ref5.as,
      Comp = _ref5$as === void 0 ? "div" : _ref5$as,
      children = _ref5.children,
      id = _ref5.id,
      onKeyDown = _ref5.onKeyDown,
      props = _objectWithoutPropertiesLoose$b(_ref5, ["as", "children", "id", "onKeyDown"]);

  var _useContext3 = React.useContext(MenuContext),
      menuId = _useContext3.menuId,
      dispatch = _useContext3.dispatch,
      buttonRef = _useContext3.buttonRef,
      menuRef = _useContext3.menuRef,
      selectCallbacks = _useContext3.selectCallbacks,
      _useContext3$state = _useContext3.state,
      isExpanded = _useContext3$state.isExpanded,
      buttonId = _useContext3$state.buttonId,
      selectionIndex = _useContext3$state.selectionIndex,
      typeaheadQuery = _useContext3$state.typeaheadQuery;

  var menuItems = useDescendants(MenuDescendantContext);
  var ref = useForkedRef(menuRef, forwardedRef);
  React.useEffect(function () {
    // Respond to user char key input with typeahead
    var match = findItemFromTypeahead(menuItems, typeaheadQuery);

    if (typeaheadQuery && match != null) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: match
        }
      });
    }

    var timeout = window.setTimeout(function () {
      return typeaheadQuery && dispatch({
        type: SEARCH_FOR_ITEM,
        payload: ""
      });
    }, 1000);
    return function () {
      return window.clearTimeout(timeout);
    };
  }, [dispatch, menuItems, typeaheadQuery]);
  var prevMenuItemsLength = usePrevious(menuItems.length);
  var prevSelected = usePrevious(menuItems[selectionIndex]);
  var prevSelectionIndex = usePrevious(selectionIndex);
  React.useEffect(function () {
    if (selectionIndex > menuItems.length - 1) {
      // If for some reason our selection index is larger than our possible
      // index range (let's say the last item is selected and the list
      // dynamically updates), we need to select the last item in the list.
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: menuItems.length - 1
        }
      });
    } else if ( // Checks if
    //  - menu length has changed
    //  - selection index has not changed BUT selected item has changed
    //
    // This prevents any dynamic adding/removing of menu items from actually
    // changing a user's expected selection.
    prevMenuItemsLength !== menuItems.length && selectionIndex > -1 && prevSelected && prevSelectionIndex === selectionIndex && menuItems[selectionIndex] !== prevSelected) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: menuItems.findIndex(function (i) {
            return i.key === prevSelected.key;
          })
        }
      });
    }
  }, [dispatch, menuItems, prevMenuItemsLength, prevSelected, prevSelectionIndex, selectionIndex]);
  var handleKeyDown = wrapEvent(function handleKeyDown(event) {
    var key = event.key;

    if (!isExpanded) {
      return;
    }

    switch (key) {
      case "Enter":
      case " ":
        var selected = menuItems.find(function (item) {
          return item.index === selectionIndex;
        }); // For links, the Enter key will trigger a click by default, but for
        // consistent behavior across menu items we'll trigger a click when
        // the spacebar is pressed.

        if (selected) {
          if (selected.isLink && selected.element) {
            selected.element.click();
          } else {
            event.preventDefault(); // Focus the button first by default when an item is selected.
            // We fire the onSelect callback next so the app can manage
            // focus if needed.

            focus(buttonRef.current);
            selectCallbacks.current[selected.index] && selectCallbacks.current[selected.index]();
            dispatch({
              type: CLICK_MENU_ITEM
            });
          }
        }

        break;

      case "Escape":
        focus(buttonRef.current);
        dispatch({
          type: CLOSE_MENU,
          payload: {
            buttonRef: buttonRef
          }
        });
        break;

      case "Tab":
        // prevent leaving
        event.preventDefault();
        break;

      default:
        // Check if a user is typing some char keys and respond by setting
        // the query state.
        if (isString(key) && key.length === 1) {
          var query = typeaheadQuery + key.toLowerCase();
          dispatch({
            type: SEARCH_FOR_ITEM,
            payload: query
          });
        }

        break;
    }
  }, useDescendantKeyDown(MenuDescendantContext, {
    currentIndex: selectionIndex,
    orientation: "vertical",
    rotate: false,
    callback: function callback(index) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: index
        }
      });
    },
    key: "index"
  }));
  return (// TODO: Should probably file a but in jsx-a11y, but this is correct
    // according to https://www.w3.org/TR/wai-aria-practices-1.2/examples/menu-button/menu-button-actions-active-descendant.html
    // eslint-disable-next-line jsx-a11y/aria-activedescendant-has-tabindex
    React__default.createElement(Comp // Refers to the descendant menuitem element that is visually indicated
    // as focused.
    // https://www.w3.org/TR/wai-aria-practices-1.2/examples/menu-button/menu-button-actions-active-descendant.html
    , Object.assign({
      "aria-activedescendant": useMenuItemId(selectionIndex) || undefined,
      "aria-labelledby": buttonId || undefined,
      // The element that contains the menu items displayed by activating the
      // button has role menu.
      // https://www.w3.org/TR/wai-aria-practices-1.2/#menubutton
      role: "menu",
      tabIndex: -1
    }, props, {
      ref: ref,
      "data-reach-menu-items": "",
      id: menuId,
      onKeyDown: wrapEvent(onKeyDown, handleKeyDown)
    }), children)
  );
});

if (process.env.NODE_ENV !== "production") {
  MenuItems.displayName = "MenuItems";
  MenuItems.propTypes = {
    children: _pt__default.node
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * MenuLink
 *
 * Handles linking to a different page in the menu. By default it renders `<a>`,
 * but also accepts any other kind of Link as long as the `Link` uses the
 * `React.forwardRef` API.
 *
 * Must be a direct child of a `<MenuList>`.
 *
 * @see Docs https://reacttraining.com/reach-ui/menu-button#menulink
 */


var MenuLink = /*#__PURE__*/forwardRefWithAs(function MenuLink(_ref6, forwardedRef) {
  var _ref6$as = _ref6.as,
      as = _ref6$as === void 0 ? "a" : _ref6$as,
      component = _ref6.component,
      onSelect = _ref6.onSelect,
      props = _objectWithoutPropertiesLoose$b(_ref6, ["as", "component", "onSelect"]);

  if (component) {
    console.warn("[@reach/menu-button]: Please use the `as` prop instead of `component`.");
  }

  return React__default.createElement("div", {
    role: "none",
    tabIndex: -1
  }, React__default.createElement(MenuItemImpl, Object.assign({}, props, {
    ref: forwardedRef,
    "data-reach-menu-link": "",
    as: as,
    isLink: true,
    onSelect: onSelect || noop
  })));
});

if (process.env.NODE_ENV !== "production") {
  MenuLink.displayName = "MenuLink";
  MenuLink.propTypes = {
    as: _pt__default.any,
    component: _pt__default.any
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * MenuList
 *
 * Wraps a DOM element that renders the menu items. Must be rendered inside of
 * a `<Menu>`.
 *
 * @see Docs https://reacttraining.com/reach-ui/menu-button#menulist
 */


var MenuList = /*#__PURE__*/React.forwardRef(function MenuList(_ref7, forwardedRef) {
  var _ref7$portal = _ref7.portal,
      portal = _ref7$portal === void 0 ? true : _ref7$portal,
      props = _objectWithoutPropertiesLoose$b(_ref7, ["portal"]);

  return React__default.createElement(MenuPopover, {
    portal: portal
  }, React__default.createElement(MenuItems, Object.assign({}, props, {
    ref: forwardedRef,
    "data-reach-menu-list": ""
  })));
});

if (process.env.NODE_ENV !== "production") {
  MenuList.displayName = "MenuList";
  MenuList.propTypes = {
    children: _pt__default.node.isRequired
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * MenuPopover
 *
 * A low-level wrapper for the popover that appears when a menu button is open.
 * You can compose it with `MenuItems` for more control over the nested
 * components and their rendered DOM nodes, or if you need to nest arbitrary
 * components between the outer wrapper and your list.
 *
 * @see Docs https://reacttraining.com/reach-ui/menu-button#menupopover
 */


var MenuPopover = /*#__PURE__*/React.forwardRef(function MenuPopover(_ref8, forwardedRef) {
  var children = _ref8.children,
      _ref8$portal = _ref8.portal,
      portal = _ref8$portal === void 0 ? true : _ref8$portal,
      position = _ref8.position,
      props = _objectWithoutPropertiesLoose$b(_ref8, ["children", "portal", "position"]);

  var _useContext4 = React.useContext(MenuContext),
      buttonRef = _useContext4.buttonRef,
      buttonClickedRef = _useContext4.buttonClickedRef,
      dispatch = _useContext4.dispatch,
      menuRef = _useContext4.menuRef,
      popoverRef = _useContext4.popoverRef,
      isExpanded = _useContext4.state.isExpanded;

  var ref = useForkedRef(popoverRef, forwardedRef);
  React.useEffect(function () {
    function listener(event) {
      if (buttonClickedRef.current) {
        buttonClickedRef.current = false;
      } else {
        var relatedTarget = event.relatedTarget,
            target = event.target; // We on want to close only if focus rests outside the menu

        if (isExpanded && popoverRef.current) {
          var _popoverRef$current;

          if (!((_popoverRef$current = popoverRef.current) === null || _popoverRef$current === void 0 ? void 0 : _popoverRef$current.contains(relatedTarget || target))) {
            dispatch({
              type: CLOSE_MENU,
              payload: {
                buttonRef: buttonRef
              }
            });
          }
        }
      }
    }

    window.addEventListener("mousedown", listener);
    return function () {
      window.removeEventListener("mousedown", listener);
    };
  }, [buttonClickedRef, buttonRef, dispatch, isExpanded, menuRef, popoverRef]);

  var commonProps = _extends$9({
    ref: ref,
    // TODO: remove in 1.0
    "data-reach-menu": "",
    "data-reach-menu-popover": "",
    hidden: !isExpanded,
    children: children
  }, props);

  return portal ? React__default.createElement(Popover, Object.assign({}, commonProps, {
    targetRef: buttonRef,
    position: position
  })) : React__default.createElement("div", Object.assign({}, commonProps));
});

if (process.env.NODE_ENV !== "production") {
  MenuPopover.displayName = "MenuPopover";
  MenuPopover.propTypes = {
    children: _pt__default.node
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * A hook that exposes data for a given `Menu` component to its descendants.
 *
 * @see Docs https://reacttraining.com/reach-ui/menu-button#usemenubuttoncontext
 */


function useMenuButtonContext() {
  var _useContext5 = React.useContext(MenuContext),
      isExpanded = _useContext5.state.isExpanded;

  return React.useMemo(function () {
    return {
      isExpanded: isExpanded
    };
  }, [isExpanded]);
} ////////////////////////////////////////////////////////////////////////////////

/**
 * When a user's typed input matches the string displayed in a menu item, it is
 * expected that the matching menu item is selected. This is our matching
 * function.
 */

function findItemFromTypeahead(items, string) {
  if (string === void 0) {
    string = "";
  }

  if (!string) {
    return null;
  }

  var found = items.find(function (_ref9) {
    var _element$dataset, _element$dataset$valu;

    var element = _ref9.element;
    return element === null || element === void 0 ? void 0 : (_element$dataset = element.dataset) === null || _element$dataset === void 0 ? void 0 : (_element$dataset$valu = _element$dataset.valuetext) === null || _element$dataset$valu === void 0 ? void 0 : _element$dataset$valu.toLowerCase().startsWith(string);
  });
  return found ? items.indexOf(found) : null;
}

function useMenuItemId(index) {
  var _useContext6 = React.useContext(MenuContext),
      menuId = _useContext6.menuId;

  return index != null && index > -1 ? makeId("option-" + index, menuId) : undefined;
}

function isRightClick(nativeEvent) {
  return nativeEvent.which === 3 || nativeEvent.button === 2;
}

function focus(element) {
  element && element.focus();
}

function reducer$1(state, action) {
  if (action === void 0) {
    action = {};
  }

  switch (action.type) {
    case CLICK_MENU_ITEM:
      return _extends$9(_extends$9({}, state), {}, {
        isExpanded: false,
        selectionIndex: -1
      });

    case CLOSE_MENU:
      return _extends$9(_extends$9({}, state), {}, {
        isExpanded: false,
        selectionIndex: -1
      });

    case OPEN_MENU_AT_FIRST_ITEM:
      return _extends$9(_extends$9({}, state), {}, {
        isExpanded: true,
        selectionIndex: 0
      });

    case OPEN_MENU_CLEARED:
      return _extends$9(_extends$9({}, state), {}, {
        isExpanded: true,
        selectionIndex: -1
      });

    case SELECT_ITEM_AT_INDEX:
      if (action.payload.index >= 0) {
        return _extends$9(_extends$9({}, state), {}, {
          selectionIndex: action.payload.max != null ? Math.min(Math.max(action.payload.index, 0), action.payload.max) : Math.max(action.payload.index, 0)
        });
      }

      return state;

    case CLEAR_SELECTION_INDEX:
      return _extends$9(_extends$9({}, state), {}, {
        selectionIndex: -1
      });

    case SET_BUTTON_ID:
      return _extends$9(_extends$9({}, state), {}, {
        buttonId: action.payload
      });

    case SEARCH_FOR_ITEM:
      if (typeof action.payload !== "undefined") {
        return _extends$9(_extends$9({}, state), {}, {
          typeaheadQuery: action.payload
        });
      }

      return state;

    default:
      return state;
  }
}

function _templateObject$b() {
  var data = _taggedTemplateLiteral(["\nto {\n  transform: translate(0, 0) perspective(1000px) rotateX(0);\n}\n"]);

  _templateObject$b = function _templateObject() {
    return data;
  };

  return data;
}
var enter = core.keyframes(_templateObject$b());
var dropdownCss$1 = function dropdownCss(theme) {
  return _defineProperty({
    background: theme.colors.primaryBackground,
    border: "1px solid ".concat(theme.colors.grey[10]),
    borderRadius: theme.radii[3],
    outline: "none",
    boxShadow: theme.shadows.floating,
    width: "80vw",
    transform: "translate(0, 0) perspective(1000px) rotateX(-35deg)",
    animation: "".concat(enter, " 0.5s ease forwards"),
    transformOrigin: "top center",
    overflow: "auto",
    maxHeight: "20rem",
    "[data-selected]": {
      background: theme.colors.purple[10],
      color: theme.colors.gatsby
    }
  }, theme.mediaQueries.phablet, {
    maxWidth: "20rem"
  });
};
var menuItemCss = function menuItemCss(theme) {
  return {
    cursor: "pointer",
    color: theme.colors.grey[90],
    fontSize: theme.fontSizes[1],
    padding: "".concat(theme.space[4], " ").concat(theme.space[5]),
    overflow: "hidden"
  };
};
var dropdownButtonCss = function dropdownButtonCss(theme) {
  return {
    cursor: "pointer",
    display: "flex",
    alignItems: "center",
    border: "1px solid ".concat(theme.colors.grey[30]),
    borderRadius: theme.radii[2],
    color: theme.colors.grey[90],
    fontSize: theme.fontSizes[2],
    padding: "".concat(theme.space[2], " ").concat(theme.space[4]),
    width: "100%",
    "&:focus": {
      borderColor: theme.colors.purple[40],
      boxShadow: "0 0 0 3px ".concat(theme.colors.purple[20]),
      outline: 0,
      transition: "box-shadow 0.15s ease-in-out"
    }
  };
};
var dropdownButtonIconCss = function dropdownButtonIconCss(_theme) {
  return {
    marginInlineStart: "auto",
    transition: "transform .3s",
    "[aria-expanded] > &": {
      transform: "rotate(180deg)"
    }
  };
};

var DropdownMenu = function DropdownMenu(props) {
  return core.jsx(React__default.Fragment, null, core.jsx(DisableReachStyleCheck, {
    reachComponent: "menu-button"
  }), core.jsx(Menu, props));
};
var DropdownMenuButton = function DropdownMenuButton(props) {
  return core.jsx(MenuButton, props);
};
var DropdownMenuButtonStyled = function DropdownMenuButtonStyled(_ref) {
  var children = _ref.children,
      props = _objectWithoutProperties(_ref, ["children"]);

  return core.jsx(DropdownMenuButton, _extends({}, props, {
    css: dropdownButtonCss
  }), children, core.jsx(md.MdKeyboardArrowDown, {
    css: dropdownButtonIconCss
  }));
};
var DropdownMenuItems = function DropdownMenuItems(props) {
  return core.jsx(MenuList, _extends({}, props, {
    css: dropdownCss$1
  }));
};
var DropdownMenuItem = function DropdownMenuItem(props) {
  return core.jsx(MenuItem, _extends({}, props, {
    css: menuItemCss
  }));
};
function DropdownMenuLink(props) {
  return core.jsx(MenuLink, props);
}
function DropdownMenuPopover(props) {
  return core.jsx(MenuPopover, props);
}
function useDropdownMenuContext() {
  return useMenuButtonContext();
}
DropdownMenu.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "DropdownMenu"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/DropdownMenu/DropdownMenu.tsx"] = {
    name: "DropdownMenu",
    docgenInfo: DropdownMenu.__docgenInfo,
    path: "src/components/DropdownMenu/DropdownMenu.tsx"
  };
}

DropdownMenuButton.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "DropdownMenuButton"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/DropdownMenu/DropdownMenu.tsx"] = {
    name: "DropdownMenuButton",
    docgenInfo: DropdownMenuButton.__docgenInfo,
    path: "src/components/DropdownMenu/DropdownMenu.tsx"
  };
}

DropdownMenuButtonStyled.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "DropdownMenuButtonStyled"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/DropdownMenu/DropdownMenu.tsx"] = {
    name: "DropdownMenuButtonStyled",
    docgenInfo: DropdownMenuButtonStyled.__docgenInfo,
    path: "src/components/DropdownMenu/DropdownMenu.tsx"
  };
}

DropdownMenuItems.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "DropdownMenuItems"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/DropdownMenu/DropdownMenu.tsx"] = {
    name: "DropdownMenuItems",
    docgenInfo: DropdownMenuItems.__docgenInfo,
    path: "src/components/DropdownMenu/DropdownMenu.tsx"
  };
}

DropdownMenuItem.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "DropdownMenuItem"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/DropdownMenu/DropdownMenu.tsx"] = {
    name: "DropdownMenuItem",
    docgenInfo: DropdownMenuItem.__docgenInfo,
    path: "src/components/DropdownMenu/DropdownMenu.tsx"
  };
}

DropdownMenuLink.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "DropdownMenuLink"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/DropdownMenu/DropdownMenu.tsx"] = {
    name: "DropdownMenuLink",
    docgenInfo: DropdownMenuLink.__docgenInfo,
    path: "src/components/DropdownMenu/DropdownMenu.tsx"
  };
}

DropdownMenuPopover.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "DropdownMenuPopover"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/DropdownMenu/DropdownMenu.tsx"] = {
    name: "DropdownMenuPopover",
    docgenInfo: DropdownMenuPopover.__docgenInfo,
    path: "src/components/DropdownMenu/DropdownMenu.tsx"
  };
}

var baseCss$c = function baseCss(theme) {
  return {
    listStyle: "none",
    margin: 0,
    padding: 0,
    position: "relative",
    display: "flex",
    justifyContent: "center",
    textAlign: "center",
    paddingTop: theme.space[9],
    counterReset: "section",
    ":after": {
      borderBottom: "1px solid ".concat(theme.colors.standardLine),
      bottom: 0,
      content: "\"\"",
      left: 0,
      position: "absolute",
      width: "100%",
      zIndex: 1
    }
  };
};

function StepIndicator(_ref) {
  var children = _ref.children;
  return core.jsx("ul", {
    css: function css(theme) {
      return [baseCss$c(theme)];
    }
  }, children);
}
StepIndicator.propTypes = {
  children: _pt__default.node
};
StepIndicator.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "StepIndicator",
  "props": {
    "children": {
      "required": false,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/StepIndicator/StepIndicator.tsx"] = {
    name: "StepIndicator",
    docgenInfo: StepIndicator.__docgenInfo,
    path: "src/components/StepIndicator/StepIndicator.tsx"
  };
}

var baseCss$d = function baseCss(theme) {
  return _defineProperty({
    display: "inline-flex",
    alignItems: "center",
    borderRadius: "".concat(theme.radii[2], " ").concat(theme.radii[2], " 0 0"),
    backgroundColor: theme.colors.secondaryBackground,
    border: "1px solid ".concat(theme.colors.standardLine),
    color: theme.colors.blackFade[70],
    fontFamily: theme.fonts.heading,
    fontSize: theme.fontSizes[3],
    fontWeight: theme.fontWeights.bold,
    height: "3.5rem",
    margin: "0 ".concat(theme.space[2]),
    padding: "".concat(theme.space[1], " ").concat(theme.space[5], " 0"),
    position: "relative",
    zIndex: 0
  }, theme.mediaQueries.phablet, {
    padding: "".concat(theme.space[1], " ").concat(theme.space[7], " 0")
  });
};
var activeCss = function activeCss(theme) {
  return {
    background: theme.colors.primaryBackground,
    borderBottomColor: theme.colors.secondaryBackground,
    color: theme.colors.grey[90],
    zIndex: 2,
    ":before, :after": {
      border: "1px solid ".concat(theme.colors.standardLine),
      bottom: "-1px",
      content: "\"\"",
      height: "6px",
      position: "absolute",
      width: "6px"
    },
    ":before": {
      borderBottomRightRadius: "6px",
      borderWidth: "0 1px 1px 0",
      boxShadow: "2px 2px 0 #fff",
      left: "-6px"
    },
    ":after": {
      borderBottomLeftRadius: "6px",
      borderWidth: "0 0 1px 1px",
      boxShadow: "-2px 2px 0 #fff",
      right: "-6px"
    }
  };
};
var linkCss = function linkCss(theme) {
  return {
    display: "flex",
    alignItems: "center",
    textDecoration: "none",
    color: theme.colors.purple[40],
    "&:active": {
      color: "inherit"
    }
  };
};
var labelCss$1 = function labelCss(theme) {
  return _defineProperty({
    display: "none"
  }, theme.mediaQueries.tablet, {
    display: "inline"
  });
};
var labelActiveCss = function labelActiveCss(_theme) {
  return {
    display: "inline"
  };
};
var stepNumberCss = function stepNumberCss(theme) {
  var _ref3;

  return _ref3 = {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    background: theme.colors.grey[40],
    color: theme.colors.white,
    fontFamily: theme.fonts.system,
    fontSize: theme.fontSizes[0],
    fontWeight: theme.fontWeights.bold,
    lineHeight: theme.lineHeights.solid,
    height: "20px",
    width: "20px",
    borderRadius: theme.radii[6]
  }, _defineProperty(_ref3, theme.mediaQueries.tablet, {
    marginRight: theme.space[4]
  }), _defineProperty(_ref3, ":before", {
    counterIncrement: "section",
    content: "counters(section,\".\") \" \""
  }), _ref3;
};
var stepNumberActiveCss = function stepNumberActiveCss(theme) {
  return {
    background: theme.colors.purple[40],
    marginRight: theme.space[4]
  };
};
var stepNumberDoneCss = function stepNumberDoneCss(theme) {
  return {
    background: theme.colors.purple[30]
  };
};

function StepIndicatorStep(_ref) {
  var children = _ref.children,
      to = _ref.to,
      _ref$status = _ref.status,
      status = _ref$status === void 0 ? "DEFAULT" : _ref$status,
      onClick = _ref.onClick;
  var label = core.jsx(React__default.Fragment, null, core.jsx("span", {
    css: function css(theme) {
      return [stepNumberCss(theme), status === "ACTIVE" && stepNumberActiveCss(theme), status === "DONE" && stepNumberDoneCss(theme)];
    }
  }), core.jsx("span", {
    css: function css(theme) {
      return [labelCss$1(theme), status === "ACTIVE" && labelActiveCss()];
    }
  }, children));
  return core.jsx("li", {
    css: function css(theme) {
      return [baseCss$d(theme), status === "ACTIVE" && activeCss(theme)];
    }
  }, to ? core.jsx(gatsby.Link, {
    to: to,
    onClick: onClick,
    css: linkCss
  }, label) : label);
}
StepIndicatorStep.propTypes = {
  children: _pt__default.node,
  to: _pt__default.string,
  status: _pt__default.oneOf(["DEFAULT", "ACTIVE", "DONE"])
};
StepIndicatorStep.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "StepIndicatorStep",
  "props": {
    "status": {
      "defaultValue": {
        "value": "`DEFAULT`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "union",
        "raw": "`DEFAULT` | `ACTIVE` | `DONE`",
        "elements": [{
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }]
      },
      "description": ""
    },
    "children": {
      "required": false,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    },
    "to": {
      "required": false,
      "tsType": {
        "name": "string"
      },
      "description": ""
    },
    "onClick": {
      "required": false,
      "tsType": {
        "name": "GatsbyLinkProps[\"onClick\"]",
        "raw": "GatsbyLinkProps<any>[\"onClick\"]"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/StepIndicator/StepIndicatorStep.tsx"] = {
    name: "StepIndicatorStep",
    docgenInfo: StepIndicatorStep.__docgenInfo,
    path: "src/components/StepIndicator/StepIndicatorStep.tsx"
  };
}

var DensityContext = React__default.createContext("DEFAULT");
function DensityProvider(_ref) {
  var _ref$density = _ref.density,
      density = _ref$density === void 0 ? "DEFAULT" : _ref$density,
      children = _ref.children;
  return core.jsx(DensityContext.Provider, {
    value: density
  }, children);
}
DensityProvider.propTypes = {
  density: _pt__default.oneOf(["DENSE", "DEFAULT", "LOOSE"]),
  children: _pt__default.node
};
function useDensity() {
  return React__default.useContext(DensityContext);
}
DensityProvider.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "DensityProvider",
  "props": {
    "density": {
      "defaultValue": {
        "value": "`DEFAULT`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "union",
        "raw": "`DENSE` | `DEFAULT` | `LOOSE`",
        "elements": [{
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }]
      },
      "description": ""
    },
    "children": {
      "required": false,
      "tsType": {
        "name": "ReactReactNode",
        "raw": "React.ReactNode"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/DensityProvider/DensityProvider.tsx"] = {
    name: "DensityProvider",
    docgenInfo: DensityProvider.__docgenInfo,
    path: "src/components/DensityProvider/DensityProvider.tsx"
  };
}

var verticalCss = function verticalCss(_theme) {
  return {
    display: "block",
    width: "unset"
  };
};

var horizontalCss = function horizontalCss(_theme) {
  return {
    display: "inline-block",
    height: "unset"
  };
};

function Spacer(_ref) {
  var size = _ref.size,
      _ref$direction = _ref.direction,
      direction = _ref$direction === void 0 ? "vertical" : _ref$direction,
      _ref$responsiveSize = _ref.responsiveSize,
      responsiveSize = _ref$responsiveSize === void 0 ? {} : _ref$responsiveSize,
      _ref$responsiveDirect = _ref.responsiveDirection,
      responsiveDirection = _ref$responsiveDirect === void 0 ? {} : _ref$responsiveDirect,
      className = _ref.className;
  var theme = useTheme();
  var breakpoints = Object.keys(theme.mediaQueries);
  var responsiveStyles = {};

  for (var _i = 0, _breakpoints = breakpoints; _i < _breakpoints.length; _i++) {
    var breakpoint = _breakpoints[_i];
    var sizeForBreakpoint = responsiveSize[breakpoint] || size;
    var directionForBreakpoint = responsiveDirection[breakpoint] || direction;
    var sizePropertyForBreakpoint = directionForBreakpoint === "horizontal" ? "width" : "height";
    var mediaQuery = theme.mediaQueries[breakpoint];
    responsiveStyles[mediaQuery] = [_defineProperty({}, sizePropertyForBreakpoint, theme.space[sizeForBreakpoint]), directionForBreakpoint === "horizontal" ? horizontalCss() : verticalCss()];
  }

  var defaultSizeProperty = direction === "horizontal" ? "width" : "height";
  return core.jsx("div", {
    css: [_defineProperty({}, defaultSizeProperty, theme.space[size]), direction === "horizontal" ? horizontalCss() : verticalCss(), responsiveStyles],
    "aria-hidden": true,
    className: className
  });
}
Spacer.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "Spacer",
  "props": {
    "direction": {
      "defaultValue": {
        "value": "`vertical`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "union",
        "raw": "`horizontal` | `vertical`",
        "elements": [{
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }]
      },
      "description": ""
    },
    "responsiveSize": {
      "defaultValue": {
        "value": "{}",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "Partial",
        "elements": [{
          "name": "signature",
          "type": "object",
          "raw": "{\n  [MediaBreakpoint in ThemeMediaBreakpoint]: SpacerSize\n}",
          "signature": {
            "properties": [{
              "key": {
                "name": "ThemeMediaBreakpoint",
                "required": true
              },
              "value": {
                "name": "ThemeSpace"
              }
            }]
          }
        }],
        "raw": "Partial<\n  {\n    [MediaBreakpoint in ThemeMediaBreakpoint]: SpacerSize\n  }\n>"
      },
      "description": ""
    },
    "responsiveDirection": {
      "defaultValue": {
        "value": "{}",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "Partial",
        "elements": [{
          "name": "signature",
          "type": "object",
          "raw": "{\n  [MediaBreakpoint in ThemeMediaBreakpoint]: SpacerDirection\n}",
          "signature": {
            "properties": [{
              "key": {
                "name": "ThemeMediaBreakpoint",
                "required": true
              },
              "value": {
                "name": "union",
                "raw": "`horizontal` | `vertical`",
                "elements": [{
                  "name": "literal",
                  "value": "undefined"
                }, {
                  "name": "literal",
                  "value": "undefined"
                }]
              }
            }]
          }
        }],
        "raw": "Partial<\n  {\n    [MediaBreakpoint in ThemeMediaBreakpoint]: SpacerDirection\n  }\n>"
      },
      "description": ""
    },
    "size": {
      "required": true,
      "tsType": {
        "name": "ThemeSpace"
      },
      "description": ""
    },
    "className": {
      "required": false,
      "tsType": {
        "name": "string"
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Spacer/Spacer.tsx"] = {
    name: "Spacer",
    docgenInfo: Spacer.__docgenInfo,
    path: "src/components/Spacer/Spacer.tsx"
  };
}

var defaultGetProgressColor = function defaultGetProgressColor(theme, progression) {
  if (progression < 33) {
    return theme.colors.red[50];
  }

  if (progression < 66) {
    return theme.colors.orange[50];
  }

  return theme.colors.green[50];
};

var progressCss = function progressCss(theme, progression, getProgressColor) {
  return {
    display: "block",
    width: "100%",
    height: "6px",
    borderRadius: theme.radii[2],
    position: "relative",
    "&:before": {
      content: "''",
      width: "".concat(progression, "%"),
      height: "6px",
      position: "absolute",
      backgroundColor: getProgressColor(theme, progression),
      borderRadius: theme.radii[2]
    },
    background: theme.colors.grey[20]
  };
};

var ProgressBar = function ProgressBar(_ref) {
  var max = _ref.max,
      _ref$min = _ref.min,
      min = _ref$min === void 0 ? 0 : _ref$min,
      value = _ref.value,
      _ref$getProgressColor = _ref.getProgressColor,
      getProgressColor = _ref$getProgressColor === void 0 ? defaultGetProgressColor : _ref$getProgressColor,
      props = _objectWithoutProperties(_ref, ["max", "min", "value", "getProgressColor"]);

  var normalizedValue = value > max ? max : value < min ? min : value;
  var progression = normalizedValue / max * 100;
  return core.jsx("div", {
    "aria-describedby": props["aria-describedby"],
    role: "progressbar",
    "aria-valuenow": normalizedValue,
    "aria-valuemin": min,
    "aria-valuemax": max,
    css: function css(theme) {
      return progressCss(theme, progression, getProgressColor);
    }
  }, core.jsx("span", {
    css: visuallyHiddenCss
  }, normalizedValue, "/", max));
};
ProgressBar.propTypes = {
  max: _pt__default.number.isRequired,
  min: _pt__default.number,
  value: _pt__default.number.isRequired,
  "aria-describedby": _pt__default.string.isRequired,
  getProgressColor: _pt__default.func
};
ProgressBar.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "ProgressBar",
  "props": {
    "min": {
      "defaultValue": {
        "value": "0",
        "computed": false
      },
      "required": false
    },
    "getProgressColor": {
      "defaultValue": {
        "value": "(\n  theme: Theme,\n  progression: number\n) => {\n  if (progression < 33) {\n    return theme.colors.red[50]\n  }\n\n  if (progression < 66) {\n    return theme.colors.orange[50]\n  }\n\n  return theme.colors.green[50]\n}",
        "computed": false
      },
      "required": false
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/ProgressBar/ProgressBar.tsx"] = {
    name: "ProgressBar",
    docgenInfo: ProgressBar.__docgenInfo,
    path: "src/components/ProgressBar/ProgressBar.tsx"
  };
}

/** @jsx jsx */

var baseCss$e = function baseCss(_theme) {
  return {
    fontWeight: 500
  };
};

var planTypeFreeCss = function planTypeFreeCss(theme) {
  return {
    borderColor: theme.colors.orange[10],
    backgroundColor: theme.colors.orange[10],
    color: theme.colors.orange[90]
  };
};

var planTypeProfessionalCss = function planTypeProfessionalCss(theme) {
  return {
    borderColor: theme.colors.blue[10],
    backgroundColor: theme.colors.blue[10],
    color: theme.colors.blue[90]
  };
};

var planTypeBusinessCss = function planTypeBusinessCss(theme) {
  return {
    borderColor: theme.colors.purple[10],
    backgroundColor: theme.colors.purple[10],
    color: theme.colors.purple[70]
  };
};

var planTypeEnterpriseCss = function planTypeEnterpriseCss(theme) {
  return {
    borderColor: theme.colors.purple[80],
    backgroundColor: theme.colors.purple[80],
    color: theme.colors.white
  };
};

var planTypeTrialingCss = function planTypeTrialingCss(theme) {
  return {
    borderColor: theme.colors.green[10],
    backgroundColor: theme.colors.green[10],
    color: theme.colors.green[70]
  };
};

var planTypeCss = {
  FREE: planTypeFreeCss,
  PROFESSIONAL: planTypeProfessionalCss,
  BUSINESS: planTypeBusinessCss,
  ENTERPRISE: planTypeEnterpriseCss,
  TRIALING: planTypeTrialingCss
};
var planTypeLabels = {
  FREE: "Free",
  PROFESSIONAL: "Professional",
  BUSINESS: "Business",
  ENTERPRISE: "Enterprise",
  TRIALING: "Professional Trial"
};
var planTypeIcons = {
  FREE: FreePlanIcon,
  PROFESSIONAL: ProfessionalPlanIcon,
  BUSINESS: BusinessPlanIcon,
  ENTERPRISE: EnterprisePlanIcon,
  TRIALING: undefined
};
function PlanIndicator(_ref) {
  var planType = _ref.planType;
  var label = planTypeLabels[planType];
  var Icon = planTypeIcons[planType];
  return core.jsx(Badge, {
    size: "M",
    textVariant: "DEFAULT",
    Icon: Icon,
    "aria-label": "Plan: ".concat(label),
    css: function css(theme) {
      return [baseCss$e(), planTypeCss[planType](theme)];
    }
  }, label);
}
PlanIndicator.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "PlanIndicator",
  "props": {
    "planType": {
      "required": true,
      "tsType": {
        "name": "union",
        "raw": "`FREE`\n| `PROFESSIONAL`\n| `BUSINESS`\n| `ENTERPRISE`\n| `TRIALING`",
        "elements": [{
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }]
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/PlanIndicator/PlanIndicator.tsx"] = {
    name: "PlanIndicator",
    docgenInfo: PlanIndicator.__docgenInfo,
    path: "src/components/PlanIndicator/PlanIndicator.tsx"
  };
}

var ALIGN_TO_CSS_ALIGN = {
  stretch: "stretch",
  center: "center",
  right: "flex-end",
  left: "flex-start"
};

function getGapVal(gap, t) {
  if (t && t.space[gap]) {
    return t.space[gap];
  }

  return gap;
}

function getStackStyles(params) {
  var _ref = params || {},
      _ref$gap = _ref.gap,
      gap = _ref$gap === void 0 ? 0 : _ref$gap,
      _ref$responsiveGap = _ref.responsiveGap,
      responsiveGap = _ref$responsiveGap === void 0 ? {} : _ref$responsiveGap,
      _ref$align = _ref.align,
      align = _ref$align === void 0 ? "stretch" : _ref$align,
      _ref$direction = _ref.direction,
      direction = _ref$direction === void 0 ? "column" : _ref$direction,
      t = _ref.theme;

  var isHorizontal = direction === "row";
  var responsiveGapCss = {};

  if (t && t.mediaQueries) {
    responsiveGapCss = Object.entries(responsiveGap).reduce(function (acc, _ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
          breakpoint = _ref3[0],
          gap = _ref3[1];

      var mediaQuery = t.mediaQueries[breakpoint];

      if (mediaQuery && gap !== undefined && gap !== null) {
        acc[mediaQuery] = {
          marginTop: !isHorizontal ? getGapVal(gap, t) : undefined,
          marginLeft: isHorizontal ? getGapVal(gap, t) : undefined
        };
      }

      return acc;
    }, {});
  }

  var stackCss = {
    display: "flex",
    flexDirection: isHorizontal ? "row" : "column",
    alignItems: !isHorizontal ? ALIGN_TO_CSS_ALIGN[align || "stretch"] : undefined,
    justifyContent: isHorizontal ? ALIGN_TO_CSS_ALIGN[align || "left"] : undefined,
    overflow: isHorizontal ? "auto" : undefined
  };

  var stackItemCss = _objectSpread2({
    marginTop: !isHorizontal ? getGapVal(gap, t) : undefined,
    marginLeft: isHorizontal ? getGapVal(gap, t) : undefined,
    flexShrink: isHorizontal ? 0 : undefined,
    "&:first-child": {
      marginTop: !isHorizontal ? 0 : undefined,
      marginLeft: isHorizontal ? 0 : undefined
    }
  }, responsiveGapCss);

  return {
    stackCss: stackCss,
    stackItemCss: stackItemCss
  };
}

var ALIGN_TO_CSS_ALIGN$1 = {
  center: "center",
  right: "flex-end",
  left: "flex-start"
};

function pickProperGap(gap, verticalGap) {
  return verticalGap ? verticalGap : gap;
}

function getGapVal$1(gap, t) {
  if (t && t.space[gap]) {
    return t.space[gap];
  }

  return gap;
}

function getClusterGapCalc(gap) {
  return "calc(".concat(gap, " / 2 * -1)");
}

function getClusterItemGapCalc(gap) {
  return "calc(".concat(gap, " / 2)");
}

function getMarginsCssValues(params) {
  var gap = params.gap,
      verticalGap = params.verticalGap,
      _params$target = params.target,
      target = _params$target === void 0 ? "cluster" : _params$target,
      t = params.theme;
  var calcGetter = target === "clusterItem" ? getClusterItemGapCalc : getClusterGapCalc;
  return {
    margin: calcGetter(getGapVal$1(gap, t)),
    marginBottom: calcGetter(getGapVal$1(pickProperGap(gap, verticalGap), t)),
    marginTop: calcGetter(getGapVal$1(pickProperGap(gap, verticalGap), t))
  };
}

function getClusterStyles(params) {
  var _ref = params || {},
      _ref$gap = _ref.gap,
      gap = _ref$gap === void 0 ? 0 : _ref$gap,
      _ref$verticalGap = _ref.verticalGap,
      verticalGap = _ref$verticalGap === void 0 ? 0 : _ref$verticalGap,
      _ref$responsiveGaps = _ref.responsiveGaps,
      responsiveGaps = _ref$responsiveGaps === void 0 ? {} : _ref$responsiveGaps,
      _ref$align = _ref.align,
      align = _ref$align === void 0 ? "left" : _ref$align,
      t = _ref.theme;

  var clusterResponsiveGapsCss = {};
  var clusterItemResponsiveGapsCss = {};

  if (t && t.mediaQueries) {
    Object.entries(responsiveGaps).forEach(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
          breakpoint = _ref3[0],
          gaps = _ref3[1];

      var mediaQuery = t.mediaQueries[breakpoint];

      var _ref4 = gaps || {},
          gap = _ref4.gap,
          verticalGap = _ref4.verticalGap;

      if (mediaQuery && gap !== undefined && gap !== null) {
        clusterResponsiveGapsCss[mediaQuery] = getMarginsCssValues({
          gap: gap,
          verticalGap: verticalGap,
          target: "cluster",
          theme: t
        });
        clusterItemResponsiveGapsCss[mediaQuery] = getMarginsCssValues({
          gap: gap,
          verticalGap: verticalGap,
          target: "clusterItem",
          theme: t
        });
      }
    });
  }

  var clusterCss = _objectSpread2({
    alignItems: ALIGN_TO_CSS_ALIGN$1[align || "justify"],
    display: "flex",
    flexWrap: "wrap",
    justifyContent: align ? ALIGN_TO_CSS_ALIGN$1[align] : "center"
  }, getMarginsCssValues({
    gap: gap,
    verticalGap: verticalGap,
    target: "cluster",
    theme: t
  }), {}, clusterResponsiveGapsCss);

  var clusterItemCss = _objectSpread2({}, getMarginsCssValues({
    gap: gap,
    verticalGap: verticalGap,
    target: "clusterItem",
    theme: t
  }), {}, clusterItemResponsiveGapsCss);

  return {
    clusterCss: clusterCss,
    clusterItemCss: clusterItemCss
  };
}

var baseCss$f = function baseCss(theme) {
  return {
    display: "inline-block",
    fontFamily: theme.fonts.sans,
    fontSize: theme.fontSizes[0],
    lineHeight: theme.lineHeights.solid,
    fontWeight: theme.fontWeights.semiBold,
    backgroundColor: theme.colors.grey[20],
    color: theme.colors.grey[60],
    paddingLeft: "calc(3 * ".concat(theme.space[1], ")"),
    paddingRight: "calc(3 * ".concat(theme.space[1], ")"),
    paddingTop: theme.space[1],
    paddingBottom: theme.space[1],
    borderRadius: "10px"
  };
};

var toneCss = {
  DANGER: function DANGER(theme) {
    return {
      backgroundColor: theme.tones.DANGER.lighter,
      color: theme.tones.DANGER.superDark
    };
  },
  WARNING: function WARNING(theme) {
    return {
      backgroundColor: theme.tones.WARNING.light,
      color: theme.tones.WARNING.textInverted
    };
  },
  NEUTRAL: function NEUTRAL(theme) {
    return {
      backgroundColor: theme.tones.NEUTRAL.light,
      color: theme.tones.NEUTRAL.dark
    };
  }
};
function NumberBadge(_ref) {
  var _ref$tone = _ref.tone,
      tone = _ref$tone === void 0 ? "NEUTRAL" : _ref$tone,
      rest = _objectWithoutProperties(_ref, ["tone"]);

  return core.jsx("span", _extends({
    css: function css(theme) {
      return [baseCss$f(theme), toneCss[tone](theme)];
    }
  }, rest));
}
NumberBadge.propTypes = {
  tone: _pt__default.oneOf(["DANGER", "WARNING", "NEUTRAL"])
};
NumberBadge.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "NumberBadge",
  "props": {
    "tone": {
      "defaultValue": {
        "value": "`NEUTRAL`",
        "computed": false
      },
      "required": false,
      "tsType": {
        "name": "union",
        "raw": "`DANGER` | `WARNING` | `NEUTRAL`",
        "elements": [{
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }, {
          "name": "literal",
          "value": "undefined"
        }]
      },
      "description": ""
    }
  }
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/NumberBadge/NumberBadge.tsx"] = {
    name: "NumberBadge",
    docgenInfo: NumberBadge.__docgenInfo,
    path: "src/components/NumberBadge/NumberBadge.tsx"
  };
}

function _objectWithoutPropertiesLoose$c(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var TabsDescendantsContext = /*#__PURE__*/createDescendantContext("TabsDescendantsContext");
var TabPanelDescendantsContext = /*#__PURE__*/createDescendantContext("TabPanelDescendantsContext");
var TabsContext = /*#__PURE__*/createNamedContext("TabsContext", {});


(function (TabsKeyboardActivation) {
  TabsKeyboardActivation["Auto"] = "auto";
  TabsKeyboardActivation["Manual"] = "manual";
})(exports.TabsKeyboardActivation || (exports.TabsKeyboardActivation = {}));

var TabsOrientation;

(function (TabsOrientation) {
  TabsOrientation["Horizontal"] = "horizontal";
  TabsOrientation["Vertical"] = "vertical";
})(TabsOrientation || (TabsOrientation = {})); ////////////////////////////////////////////////////////////////////////////////

/**
 * Tabs
 *
 * The parent component of the tab interface.
 *
 * @see Docs https://reacttraining.com/reach-ui/tabs#tabs
 */


var Tabs = /*#__PURE__*/forwardRefWithAs(function Tabs(_ref, ref) {
  var _props$id;

  var _ref$as = _ref.as,
      Comp = _ref$as === void 0 ? "div" : _ref$as,
      children = _ref.children,
      defaultIndex = _ref.defaultIndex,
      _ref$orientation = _ref.orientation,
      orientation = _ref$orientation === void 0 ? TabsOrientation.Horizontal : _ref$orientation,
      _ref$index = _ref.index,
      controlledIndex = _ref$index === void 0 ? undefined : _ref$index,
      _ref$keyboardActivati = _ref.keyboardActivation,
      keyboardActivation = _ref$keyboardActivati === void 0 ? exports.TabsKeyboardActivation.Auto : _ref$keyboardActivati,
      onChange = _ref.onChange,
      _ref$readOnly = _ref.readOnly,
      readOnly = _ref$readOnly === void 0 ? false : _ref$readOnly,
      props = _objectWithoutPropertiesLoose$c(_ref, ["as", "children", "defaultIndex", "orientation", "index", "keyboardActivation", "onChange", "readOnly"]);

  var isControlled = React.useRef(controlledIndex != null);
  useControlledSwitchWarning(controlledIndex, "index", "Tabs");

  var _id = useId(props.id);

  var id = (_props$id = props.id) !== null && _props$id !== void 0 ? _props$id : makeId("tabs", _id); // We only manage focus if the user caused the update vs. a new controlled
  // index coming in.

  var userInteractedRef = React.useRef(false);
  var selectedPanelRef = React.useRef(null);
  var isRTL = React.useRef(false);

  var _useControlledState = useControlledState(controlledIndex, defaultIndex !== null && defaultIndex !== void 0 ? defaultIndex : 0),
      selectedIndex = _useControlledState[0],
      setSelectedIndex = _useControlledState[1];

  var _useState = React.useState(-1),
      focusedIndex = _useState[0],
      setFocusedIndex = _useState[1];

  var _useDescendantsInit = useDescendantsInit(),
      tabs = _useDescendantsInit[0],
      setTabs = _useDescendantsInit[1];

  var context = React.useMemo(function () {
    return {
      focusedIndex: focusedIndex,
      id: id,
      isControlled: isControlled.current,
      isRTL: isRTL,
      keyboardActivation: keyboardActivation,
      onFocusPanel: function onFocusPanel() {
        var _selectedPanelRef$cur;

        (_selectedPanelRef$cur = selectedPanelRef.current) === null || _selectedPanelRef$cur === void 0 ? void 0 : _selectedPanelRef$cur.focus();
      },
      onSelectTab: readOnly ? noop : function (index) {
        userInteractedRef.current = true;
        onChange && onChange(index);
        setSelectedIndex(index);
      },
      onSelectTabWithKeyboard: readOnly ? noop : function (index) {
        var _tabs$index$element;

        userInteractedRef.current = true;

        switch (keyboardActivation) {
          case exports.TabsKeyboardActivation.Manual:
            (_tabs$index$element = tabs[index].element) === null || _tabs$index$element === void 0 ? void 0 : _tabs$index$element.focus();
            return;

          case exports.TabsKeyboardActivation.Auto:
          default:
            onChange && onChange(index);
            setSelectedIndex(index);
            return;
        }
      },
      orientation: orientation,
      selectedIndex: selectedIndex,
      selectedPanelRef: selectedPanelRef,
      setFocusedIndex: setFocusedIndex,
      setSelectedIndex: setSelectedIndex,
      userInteractedRef: userInteractedRef
    };
  }, [focusedIndex, id, keyboardActivation, onChange, orientation, readOnly, selectedIndex, setSelectedIndex, tabs]);
  React.useEffect(function () {
    return checkStyles("tabs");
  }, []);
  return React__default.createElement(DescendantProvider, {
    context: TabsDescendantsContext,
    items: tabs,
    set: setTabs
  }, React__default.createElement(TabsContext.Provider, {
    value: context
  }, React__default.createElement(Comp, Object.assign({}, props, {
    ref: ref,
    "data-reach-tabs": "",
    "data-orientation": orientation,
    id: props.id
  }), isFunction$2(children) ? children({
    focusedIndex: focusedIndex,
    id: id,
    selectedIndex: selectedIndex
  }) : children)));
});

if (process.env.NODE_ENV !== "production") {
  Tabs.displayName = "Tabs";
  Tabs.propTypes = {
    children: _pt__default.node.isRequired,
    onChange: _pt__default.func,
    orientation: /*#__PURE__*/_pt__default.oneOf( /*#__PURE__*/Object.values(TabsOrientation)),
    index: function index(props, name, compName, location, propName) {
      var val = props[name];

      if (props.index > -1 && props.onChange == null && props.readOnly !== true) {
        return new Error("You provided a value prop to `" + compName + "` without an `onChange` handler. This will render a read-only tabs element. If the tabs should be mutable use `defaultIndex`. Otherwise, set `onChange`.");
      } else if (props[name] != null && !isNumber(props[name])) {
        return new Error("Invalid prop `" + propName + "` supplied to `" + compName + "`. Expected `number`, received `" + (Array.isArray(val) ? "array" : typeof val) + "`.");
      }

      return null;
    },
    defaultIndex: _pt__default.number
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * TabList
 *
 * The parent component of the tabs.
 *
 * @see Docs https://reacttraining.com/reach-ui/tabs#tablist
 */


var TabListImpl = /*#__PURE__*/forwardRefWithAs(function TabList(_ref2, forwardedRef) {
  var children = _ref2.children,
      _ref2$as = _ref2.as,
      Comp = _ref2$as === void 0 ? "div" : _ref2$as,
      onKeyDown = _ref2.onKeyDown,
      props = _objectWithoutPropertiesLoose$c(_ref2, ["children", "as", "onKeyDown"]);

  var _useContext = React.useContext(TabsContext),
      focusedIndex = _useContext.focusedIndex,
      isControlled = _useContext.isControlled,
      isRTL = _useContext.isRTL,
      keyboardActivation = _useContext.keyboardActivation,
      onSelectTabWithKeyboard = _useContext.onSelectTabWithKeyboard,
      orientation = _useContext.orientation,
      selectedIndex = _useContext.selectedIndex,
      setSelectedIndex = _useContext.setSelectedIndex;

  var tabs = useDescendants(TabsDescendantsContext);
  var ownRef = React.useRef(null);
  var ref = useForkedRef(forwardedRef, ownRef);
  React.useEffect(function () {
    if (ownRef.current && (ownRef.current.ownerDocument && ownRef.current.ownerDocument.dir === "rtl" || getElementComputedStyle(ownRef.current, "direction") === "rtl")) {
      isRTL.current = true;
    }
  }, [isRTL]);
  var handleKeyDown = useEventCallback(wrapEvent(onKeyDown, useDescendantKeyDown(TabsDescendantsContext, {
    currentIndex: keyboardActivation === exports.TabsKeyboardActivation.Manual ? focusedIndex : selectedIndex,
    orientation: orientation,
    rotate: true,
    callback: onSelectTabWithKeyboard,
    filter: function filter(tab) {
      return !tab.disabled;
    },
    rtl: isRTL.current
  })));
  useIsomorphicLayoutEffect(function () {
    var _tabs$selectedIndex;

    // In the event an uncontrolled component's selected index is disabled,
    // (this should only happen if the first tab is disabled and no default
    // index is set), we need to override the selection to the next selectable
    // index value.
    if (!isControlled && boolOrBoolString((_tabs$selectedIndex = tabs[selectedIndex]) === null || _tabs$selectedIndex === void 0 ? void 0 : _tabs$selectedIndex.disabled)) {
      var next = tabs.find(function (tab) {
        return !tab.disabled;
      });

      if (next) {
        setSelectedIndex(next.index);
      }
    }
  }, [tabs, isControlled, selectedIndex, setSelectedIndex]);
  return React__default.createElement(Comp // The element that serves as the container for the set of tabs has role
  // `tablist`
  // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel
  , Object.assign({
    // The element that serves as the container for the set of tabs has role
    // `tablist`
    // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel
    role: "tablist",
    "aria-orientation": orientation
  }, props, {
    "data-reach-tab-list": "",
    ref: ref,
    onKeyDown: handleKeyDown
  }), React.Children.map(children, function (child, index) {
    // TODO: Remove in 1.0
    return cloneValidElement(child, {
      isSelected: index === selectedIndex
    });
  }));
});
var TabList = /*#__PURE__*/React.memo(TabListImpl);

if (process.env.NODE_ENV !== "production") {
  TabList.displayName = "TabList";
  TabListImpl.displayName = "TabList";
  TabListImpl.propTypes = {
    as: _pt__default.any,
    children: _pt__default.node
  };
}

/**
 * Tab
 *
 * The interactive element that changes the selected panel.
 *
 * @see Docs https://reacttraining.com/reach-ui/tabs#tab
 */

var Tab = /*#__PURE__*/forwardRefWithAs(function Tab(_ref3, forwardedRef) {
  var children = _ref3.children,
      _ = _ref3.isSelected,
      _ref3$as = _ref3.as,
      Comp = _ref3$as === void 0 ? "button" : _ref3$as,
      indexProp = _ref3.index,
      disabled = _ref3.disabled,
      onBlur = _ref3.onBlur,
      onFocus = _ref3.onFocus,
      props = _objectWithoutPropertiesLoose$c(_ref3, ["children", "isSelected", "as", "index", "disabled", "onBlur", "onFocus"]);

  var _useContext2 = React.useContext(TabsContext),
      tabsId = _useContext2.id,
      onSelectTab = _useContext2.onSelectTab,
      orientation = _useContext2.orientation,
      selectedIndex = _useContext2.selectedIndex,
      userInteractedRef = _useContext2.userInteractedRef,
      setFocusedIndex = _useContext2.setFocusedIndex;

  var ownRef = React.useRef(null);
  var ref = useForkedRef(forwardedRef, ownRef);
  var index = useDescendant({
    element: ownRef.current,
    disabled: !!disabled
  }, TabsDescendantsContext, indexProp);
  var htmlType = Comp === "button" && props.type == null ? "button" : props.type;
  var isSelected = index === selectedIndex;

  function onSelect() {
    onSelectTab(index);
  }

  useUpdateEffect(function () {
    if (isSelected && ownRef.current && userInteractedRef.current) {
      userInteractedRef.current = false;
      ownRef.current.focus();
    }
  }, [isSelected, userInteractedRef]);
  var handleFocus = useEventCallback(wrapEvent(onFocus, function () {
    setFocusedIndex(index);
  }));
  var handleBlur = useEventCallback(wrapEvent(onFocus, function () {
    setFocusedIndex(-1);
  }));
  return React__default.createElement(Comp // Each element with role `tab` has the property `aria-controls` referring
  // to its associated `tabpanel` element.
  // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel
  , Object.assign({
    "aria-controls": makeId(tabsId, "panel", index),
    "aria-disabled": disabled,
    "aria-selected": isSelected,
    // Each element that serves as a tab has role `tab` and is contained
    // within the element with role `tablist`.
    // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel
    role: "tab",
    tabIndex: isSelected ? 0 : -1
  }, props, {
    ref: ref,
    "data-reach-tab": "",
    "data-orientation": orientation,
    "data-selected": isSelected ? "" : undefined,
    disabled: disabled,
    id: makeId(tabsId, "tab", index),
    onClick: onSelect,
    onFocus: handleFocus,
    onBlur: handleBlur,
    type: htmlType
  }), children);
});

if (process.env.NODE_ENV !== "production") {
  Tab.displayName = "Tab";
  Tab.propTypes = {
    children: _pt__default.node,
    disabled: _pt__default.bool
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * TabPanels
 *
 * The parent component of the panels.
 *
 * @see Docs https://reacttraining.com/reach-ui/tabs#tabpanels
 */


var TabPanelsImpl = /*#__PURE__*/forwardRefWithAs(function TabPanels(_ref4, forwardedRef) {
  var children = _ref4.children,
      _ref4$as = _ref4.as,
      Comp = _ref4$as === void 0 ? "div" : _ref4$as,
      props = _objectWithoutPropertiesLoose$c(_ref4, ["children", "as"]);

  var ownRef = React.useRef();
  var ref = useForkedRef(ownRef, forwardedRef);

  var _useDescendantsInit2 = useDescendantsInit(),
      tabPanels = _useDescendantsInit2[0],
      setTabPanels = _useDescendantsInit2[1];

  return React__default.createElement(DescendantProvider, {
    context: TabPanelDescendantsContext,
    items: tabPanels,
    set: setTabPanels
  }, React__default.createElement(Comp, Object.assign({}, props, {
    ref: ref,
    "data-reach-tab-panels": ""
  }), children));
});
var TabPanels = /*#__PURE__*/React.memo(TabPanelsImpl);

if (process.env.NODE_ENV !== "production") {
  TabPanels.displayName = "TabPanels";
  TabPanelsImpl.displayName = "TabPanels";
  TabPanelsImpl.propTypes = {
    as: _pt__default.any,
    children: _pt__default.node
  };
}

/**
 * TabPanel
 *
 * The panel that displays when it's corresponding tab is active.
 *
 * @see Docs https://reacttraining.com/reach-ui/tabs#tabpanel
 */

var TabPanel = /*#__PURE__*/forwardRefWithAs(function TabPanel(_ref5, forwardedRef) {
  var children = _ref5.children,
      ariaLabel = _ref5["aria-label"],
      _ref5$as = _ref5.as,
      Comp = _ref5$as === void 0 ? "div" : _ref5$as,
      props = _objectWithoutPropertiesLoose$c(_ref5, ["children", "aria-label", "as"]);

  var _useContext3 = React.useContext(TabsContext),
      selectedPanelRef = _useContext3.selectedPanelRef,
      selectedIndex = _useContext3.selectedIndex,
      tabsId = _useContext3.id;

  var ownRef = React.useRef(null);
  var index = useDescendant({
    element: ownRef.current
  }, TabPanelDescendantsContext);
  var isSelected = index === selectedIndex;
  var id = makeId(tabsId, "panel", index);
  var ref = useForkedRef(forwardedRef, ownRef, isSelected ? selectedPanelRef : null);
  return React__default.createElement(Comp // Each element with role `tabpanel` has the property `aria-labelledby`
  // referring to its associated tab element.
  , Object.assign({
    "aria-labelledby": makeId(tabsId, "tab", index),
    hidden: !isSelected,
    // Each element that contains the content panel for a tab has role
    // `tabpanel`.
    // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel
    role: "tabpanel",
    tabIndex: isSelected ? 0 : -1
  }, props, {
    ref: ref,
    "data-reach-tab-panel": "",
    id: id
  }), children);
});

if (process.env.NODE_ENV !== "production") {
  TabPanel.displayName = "TabPanel";
  TabPanel.propTypes = {
    as: _pt__default.any,
    children: _pt__default.node
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * A hook that exposes data for a given `Tabs` component to its descendants.
 *
 * @see Docs https://reacttraining.com/reach-ui/tabs#usetabscontext
 */


function useTabsContext() {
  var _useContext4 = React.useContext(TabsContext),
      focusedIndex = _useContext4.focusedIndex,
      id = _useContext4.id,
      selectedIndex = _useContext4.selectedIndex;

  return React.useMemo(function () {
    return {
      focusedIndex: focusedIndex,
      id: id,
      selectedIndex: selectedIndex
    };
  }, [focusedIndex, id, selectedIndex]);
}

var reachUIDefaultStyles = {
  tabs: function tabs(_theme) {
    return {
      '[data-orientation="vertical"]': {
        display: "flex"
      }
    };
  },
  tabList: function tabList(_theme) {
    return {
      display: "flex",
      '[aria-orientation="vertical"]': {
        flexDirection: "column"
      }
    };
  },
  tab: function tab(_theme) {
    return {
      display: "inline-block",
      border: "none",
      background: "none",
      color: "inherit",
      font: "inherit",
      cursor: "pointer",
      WebkitAppearance: "none",
      MozAppearance: "none"
    };
  }
};

var tabsCss = function tabsCss(theme) {
  return [reachUIDefaultStyles.tabs(theme)];
};

var tabsListCss = function tabsListCss(theme) {
  return [reachUIDefaultStyles.tabList(theme), {
    display: "flex",
    flexGrow: 1,
    flexShrink: 0,
    listStyleType: "none",
    margin: 0,
    position: "relative",
    overflowX: "auto",
    WebkitOverflowScrolling: "touch",
    "&::-webkit-scrollbar": {
      display: "none"
    },
    borderBottom: "1px solid ".concat(theme.colors.blackFade[10])
  }];
};

var tabCss = function tabCss(theme) {
  return [reachUIDefaultStyles.tab(theme), {
    flexShrink: 0,
    margin: 0,
    padding: 0,
    position: "relative",
    "&:not(:last-of-type)": {
      marginRight: theme.space[5]
    }
  }];
};

var tabButtonCss = function tabButtonCss(theme) {
  return {
    alignItems: "center",
    display: "flex",
    margin: 0,
    padding: "".concat(theme.space[4], " ").concat(theme.space[3]),
    position: "relative",
    overflowY: "hidden",
    color: theme.colors.grey[60],
    fontFamily: theme.fonts.system,
    fontSize: theme.fontSizes[2],
    background: "none",
    border: "none",
    cursor: "pointer",
    "&:after": {
      borderTopLeftRadius: theme.radii[1],
      borderTopRightRadius: theme.radii[1],
      bottom: 0,
      content: "\"\"",
      left: 0,
      height: "4px",
      position: "absolute",
      transition: "transform ".concat(theme.transitions.speed["default"]),
      width: "100%",
      background: theme.colors.purple[30],
      transform: "translateY(100%)"
    },
    "&:hover": {
      "&:after": {
        transform: "translateY(40%)"
      }
    }
  };
};

var tabButtonSelectedCss = function tabButtonSelectedCss(theme) {
  return {
    fontWeight: theme.fontWeights.bold,
    color: theme.colors.grey[70],
    "&:after": {
      background: theme.colors.purple[60],
      transform: "translateY(40%)"
    }
  };
};

var tabsStyles = {
  tabs: tabsCss,
  tabList: tabsListCss,
  tab: tabCss,
  tabButton: tabButtonCss,
  tabButtonSelected: tabButtonSelectedCss
};

function Tabs$1(props) {
  return core.jsx(React__default.Fragment, null, core.jsx(Tabs, _extends({
    css: tabsStyles.tabs
  }, props, {
    orientation: TabsOrientation.Horizontal
  })), core.jsx(DisableReachStyleCheck, {
    reachComponent: "tabs"
  }));
}
function TabList$1(props) {
  return core.jsx(TabList, _extends({
    css: tabsStyles.tabList
  }, props));
}
function TabPanels$1(props) {
  return core.jsx(TabPanels, props);
}
function TabPanel$1(props) {
  return core.jsx(TabPanel, props);
}
function Tab$1(props) {
  return core.jsx(Tab, _extends({
    css: function css(theme) {
      return [tabsStyles.tab(theme), tabsStyles.tabButton(theme), {
        "&[data-selected]": tabsStyles.tabButtonSelected(theme)
      }];
    }
  }, props));
}
function useTabsContext$1() {
  return useTabsContext();
}
Tabs$1.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "Tabs"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Tabs/Tabs.tsx"] = {
    name: "Tabs",
    docgenInfo: Tabs$1.__docgenInfo,
    path: "src/components/Tabs/Tabs.tsx"
  };
}

TabList$1.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "TabList"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Tabs/Tabs.tsx"] = {
    name: "TabList",
    docgenInfo: TabList$1.__docgenInfo,
    path: "src/components/Tabs/Tabs.tsx"
  };
}

TabPanels$1.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "TabPanels"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Tabs/Tabs.tsx"] = {
    name: "TabPanels",
    docgenInfo: TabPanels$1.__docgenInfo,
    path: "src/components/Tabs/Tabs.tsx"
  };
}

TabPanel$1.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "TabPanel"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Tabs/Tabs.tsx"] = {
    name: "TabPanel",
    docgenInfo: TabPanel$1.__docgenInfo,
    path: "src/components/Tabs/Tabs.tsx"
  };
}

Tab$1.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "Tab"
};

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/Tabs/Tabs.tsx"] = {
    name: "Tab",
    docgenInfo: Tab$1.__docgenInfo,
    path: "src/components/Tabs/Tabs.tsx"
  };
}

exports.AnchorButton = AnchorButton;
exports.Announcement = Announcement;
exports.Avatar = Avatar;
exports.AvatarsGroup = AvatarsGroup;
exports.Badge = Badge;
exports.BaseAnchor = BaseAnchor;
exports.BaseChip = BaseChip;
exports.BaseNavigation = BaseNavigation;
exports.BaseNavigationAnchorButton = BaseNavigationAnchorButton;
exports.BaseNavigationDropdown = BaseNavigationDropdown;
exports.BaseNavigationDropdownItem = BaseNavigationDropdownItem;
exports.BaseNavigationDropdownToggle = BaseNavigationDropdownToggle;
exports.BaseNavigationHamburgerIcon = BaseNavigationHamburgerIcon;
exports.BaseNavigationItemAnchor = BaseNavigationItemAnchor;
exports.BaseNavigationItemLink = BaseNavigationItemLink;
exports.BaseNavigationLinkButton = BaseNavigationLinkButton;
exports.BaseNavigationList = BaseNavigationList;
exports.BaseNavigationListItem = BaseNavigationListItem;
exports.BaseNavigationNav = BaseNavigationNav;
exports.BlogIcon = BlogIcon;
exports.Breadcrumb = Breadcrumb;
exports.BuildsIcon = BuildsIcon;
exports.BusinessPlanIcon = BusinessPlanIcon;
exports.Button = Button;
exports.CheckCircleIcon = CheckCircleIcon;
exports.CheckIcon = CheckIcon;
exports.CheckboxConnectedField = CheckboxConnectedField;
exports.CheckboxField = CheckboxField;
exports.CheckboxFieldBlock = CheckboxFieldBlock;
exports.CheckboxFieldControl = CheckboxFieldControl;
exports.CheckboxFieldError = CheckboxFieldError;
exports.CheckboxFieldHint = CheckboxFieldHint;
exports.CheckboxFieldLabel = CheckboxFieldLabel;
exports.CheckboxFieldSkeleton = CheckboxFieldSkeleton;
exports.CheckboxFieldSkeletonControl = CheckboxFieldSkeletonControl;
exports.CheckboxFieldSkeletonError = CheckboxFieldSkeletonError;
exports.CheckboxFieldSkeletonHint = CheckboxFieldSkeletonHint;
exports.CheckboxFieldSkeletonLabel = CheckboxFieldSkeletonLabel;
exports.CheckboxFieldWrapper = CheckboxFieldWrapper;
exports.CheckboxGroupConnectedField = CheckboxGroupConnectedField;
exports.CheckboxGroupField = CheckboxGroupField;
exports.CheckboxGroupFieldBlock = CheckboxGroupFieldBlock;
exports.CheckboxGroupFieldError = CheckboxGroupFieldError;
exports.CheckboxGroupFieldHint = CheckboxGroupFieldHint;
exports.CheckboxGroupFieldLabel = CheckboxGroupFieldLabel;
exports.CheckboxGroupFieldOption = CheckboxGroupFieldOption;
exports.CheckboxGroupFieldOptionItem = CheckboxGroupFieldOptionItem;
exports.CheckboxGroupFieldOptionLabel = CheckboxGroupFieldOptionLabel;
exports.CheckboxGroupFieldOptionWrapper = CheckboxGroupFieldOptionWrapper;
exports.CheckboxGroupFieldOptions = CheckboxGroupFieldOptions;
exports.CheckboxGroupFieldSkeleton = CheckboxGroupFieldSkeleton;
exports.CheckboxGroupFieldSkeletonError = CheckboxGroupFieldSkeletonError;
exports.CheckboxGroupFieldSkeletonHint = CheckboxGroupFieldSkeletonHint;
exports.CheckboxGroupFieldSkeletonLabel = CheckboxGroupFieldSkeletonLabel;
exports.CheckboxGroupFieldSkeletonOption = CheckboxGroupFieldSkeletonOption;
exports.CheckboxGroupFieldSkeletonOptionLabel = CheckboxGroupFieldSkeletonOptionLabel;
exports.Chip = Chip;
exports.CloseCircleIcon = CloseCircleIcon;
exports.Combobox = Combobox$1;
exports.ComboboxInput = ComboboxInput$1;
exports.ComboboxList = ComboboxList$1;
exports.ComboboxOption = ComboboxOption$1;
exports.ComboboxOptionText = ComboboxOptionText$1;
exports.ComboboxPopover = ComboboxPopover$1;
exports.ConcealedValue = ConcealedValue;
exports.CopyButton = CopyButton;
exports.DecorativeDots = DecorativeDots$1;
exports.DensityProvider = DensityProvider;
exports.DropdownMenu = DropdownMenu;
exports.DropdownMenuButton = DropdownMenuButton;
exports.DropdownMenuButtonStyled = DropdownMenuButtonStyled;
exports.DropdownMenuItem = DropdownMenuItem;
exports.DropdownMenuItems = DropdownMenuItems;
exports.DropdownMenuLink = DropdownMenuLink;
exports.DropdownMenuPopover = DropdownMenuPopover;
exports.EcommerceIcon = EcommerceIcon;
exports.EllipsisIcon = EllipsisIcon;
exports.EnterprisePlanIcon = EnterprisePlanIcon;
exports.FormFieldContainer = FormFieldContainer;
exports.FormFieldSkeleton = FormFieldSkeleton;
exports.FormFieldSkeletonError = FormFieldSkeletonError;
exports.FormFieldSkeletonHint = FormFieldSkeletonHint;
exports.FormFieldSkeletonLabel = FormFieldSkeletonLabel;
exports.FreePlanIcon = FreePlanIcon;
exports.GeneralIcon = GeneralIcon;
exports.Heading = Heading;
exports.InProgressIcon = InProgressIcon;
exports.InputConnectedField = InputConnectedField;
exports.InputField = InputField;
exports.InputFieldBlock = InputFieldBlock;
exports.InputFieldControl = InputFieldControl;
exports.InputFieldError = InputFieldError;
exports.InputFieldHint = InputFieldHint;
exports.InputFieldLabel = InputFieldLabel;
exports.InputFieldSkeleton = InputFieldSkeleton;
exports.InputFieldSkeletonControl = InputFieldSkeletonControl;
exports.InputFieldSkeletonError = InputFieldSkeletonError;
exports.InputFieldSkeletonHint = InputFieldSkeletonHint;
exports.InputFieldSkeletonLabel = InputFieldSkeletonLabel;
exports.IntegrationsIcon = IntegrationsIcon;
exports.Link = Link;
exports.LinkButton = LinkButton;
exports.Modal = Modal;
exports.ModalCard = ModalCard;
exports.ModalFullScreen = ModalFullScreen;
exports.ModalPanel = ModalPanel;
exports.Navigation = Navigation;
exports.Notification = Notification;
exports.NumberBadge = NumberBadge;
exports.PlanIndicator = PlanIndicator;
exports.PortfolioIcon = PortfolioIcon;
exports.ProfessionalPlanIcon = ProfessionalPlanIcon;
exports.ProgressBar = ProgressBar;
exports.RadioButtonConnectedField = RadioButtonConnectedField;
exports.RadioButtonField = RadioButtonField;
exports.RadioButtonFieldBlock = RadioButtonFieldBlock;
exports.RadioButtonFieldError = RadioButtonFieldError;
exports.RadioButtonFieldHint = RadioButtonFieldHint;
exports.RadioButtonFieldLabel = RadioButtonFieldLabel;
exports.RadioButtonFieldOption = RadioButtonFieldOption;
exports.RadioButtonFieldOptionItem = RadioButtonFieldOptionItem;
exports.RadioButtonFieldOptionLabel = RadioButtonFieldOptionLabel;
exports.RadioButtonFieldOptionWrapper = RadioButtonFieldOptionWrapper;
exports.RadioButtonFieldOptions = RadioButtonFieldOptions;
exports.RadioButtonFieldSkeleton = RadioButtonFieldSkeleton;
exports.RadioButtonFieldSkeletonError = RadioButtonFieldSkeletonError;
exports.RadioButtonFieldSkeletonHint = RadioButtonFieldSkeletonHint;
exports.RadioButtonFieldSkeletonLabel = RadioButtonFieldSkeletonLabel;
exports.RadioButtonFieldSkeletonOption = RadioButtonFieldSkeletonOption;
exports.RadioButtonFieldSkeletonOptionLabel = RadioButtonFieldSkeletonOptionLabel;
exports.ReportsIcon = ReportsIcon;
exports.SelectConnectedField = SelectConnectedField;
exports.SelectField = SelectField;
exports.SelectFieldBlock = SelectFieldBlock;
exports.SelectFieldControl = SelectFieldControl;
exports.SelectFieldError = SelectFieldError;
exports.SelectFieldHint = SelectFieldHint;
exports.SelectFieldLabel = SelectFieldLabel;
exports.SelectFieldSkeleton = SelectFieldSkeleton;
exports.SelectFieldSkeletonControl = SelectFieldSkeletonControl;
exports.SelectFieldSkeletonError = SelectFieldSkeletonError;
exports.SelectFieldSkeletonHint = SelectFieldSkeletonHint;
exports.SelectFieldSkeletonLabel = SelectFieldSkeletonLabel;
exports.SidebarNav = SidebarNav;
exports.SkullIcon = SkullIcon;
exports.Spacer = Spacer;
exports.StepIndicator = StepIndicator;
exports.StepIndicatorStep = StepIndicatorStep;
exports.StickyLipShadow = StickyLipShadow;
exports.StickyObservedContainer = StickyObservedContainer;
exports.StickyObserver = StickyObserver;
exports.StickyObserverProvider = StickyObserverProvider;
exports.StickyObserverSentinel = StickyObserverSentinel;
exports.StyledModal = StyledModal;
exports.StyledModalActions = StyledModalActions;
exports.StyledModalBody = StyledModalBody;
exports.StyledModalCloseButton = StyledModalCloseButton;
exports.StyledModalHeader = StyledModalHeader;
exports.StyledPanel = StyledPanel;
exports.StyledPanelActions = StyledPanelActions;
exports.StyledPanelBodySection = StyledPanelBodySection;
exports.StyledPanelCloseButton = StyledPanelCloseButton;
exports.StyledPanelHeader = StyledPanelHeader;
exports.SuccessIcon = SuccessIcon;
exports.Tab = Tab$1;
exports.TabList = TabList$1;
exports.TabPanel = TabPanel$1;
exports.TabPanels = TabPanels$1;
exports.Tabs = Tabs$1;
exports.Text = Text;
exports.TextAreaConnectedField = TextAreaConnectedField;
exports.TextAreaField = TextAreaField;
exports.TextAreaFieldBlock = TextAreaFieldBlock;
exports.TextAreaFieldControl = TextAreaFieldControl;
exports.TextAreaFieldError = TextAreaFieldError;
exports.TextAreaFieldHint = TextAreaFieldHint;
exports.TextAreaFieldLabel = TextAreaFieldLabel;
exports.TextAreaFieldSkeleton = TextAreaFieldSkeleton;
exports.TextAreaFieldSkeletonControl = TextAreaFieldSkeletonControl;
exports.TextAreaFieldSkeletonError = TextAreaFieldSkeletonError;
exports.TextAreaFieldSkeletonHint = TextAreaFieldSkeletonHint;
exports.TextAreaFieldSkeletonLabel = TextAreaFieldSkeletonLabel;
exports.ThemeProvider = ThemeProvider$1;
exports.ToastConsumer = ToastConsumer;
exports.ToastProvider = ToastProvider;
exports.ToggleCheckbox = ToggleCheckbox;
exports.ToggleSwitch = ToggleSwitch;
exports.Tooltip = Tooltip$1;
exports.breakpoints = breakpoints;
exports.colors = colors;
exports.dimensions = dimensions;
exports.fontSizes = b;
exports.fontWeights = t;
exports.fonts = i;
exports.getButtonCss = getButtonCss;
exports.getButtonStyles = getButtonStyles;
exports.getClusterStyles = getClusterStyles;
exports.getErrorId = getErrorId;
exports.getHintId = getHintId;
exports.getStackStyles = getStackStyles;
exports.getTheme = getTheme;
exports.hexToRGB = hexToRGB;
exports.hexToRGBA = hexToRGBA;
exports.letterSpacings = d;
exports.lineHeights = n;
exports.radii = S;
exports.shadows = u;
exports.space = space;
exports.styledCheckboxCss = styledCheckboxCss;
exports.tabsStyles = tabsStyles;
exports.transition = j;
exports.useBaseNavigationContext = useBaseNavigationContext;
exports.useComboboxContext = useComboboxContext$1;
exports.useConnectedField = useConnectedField;
exports.useDensity = useDensity;
exports.useDropdownMenuContext = useDropdownMenuContext;
exports.useFormFieldContainerProps = useFormFieldContainerProps;
exports.useFormFieldSkeleton = useFormFieldSkeleton;
exports.useShowErrorAlert = useShowErrorAlert;
exports.useShowErrorToast = useShowErrorToast;
exports.useShowSuccessToast = useShowSuccessToast;
exports.useShowToast = useShowToast;
exports.useStickyObserver = useStickyObserver;
exports.useStyledFieldError = useStyledFieldError;
exports.useStyledFieldHint = useStyledFieldHint;
exports.useStyledFieldLabel = useStyledFieldLabel;
exports.useStyledModalContext = useStyledModalContext;
exports.useTabsContext = useTabsContext$1;
exports.useTheme = useTheme;
exports.useToastActions = useToastActions;
exports.zIndices = zIndices;
//# sourceMappingURL=index.cjs.js.map
