import { memo, createElement } from 'react';
import _pt from 'prop-types';
import colors from '../../theme/colors.esm.js';
import { testSafeMathRandom, testSafeSample } from '../../utils/helpers/testSafeRandomness.esm.js';
import { getLikelihoodOfBeingBlank } from './DecorativeDots.helpers.esm.js';
import Dot from './Dot.esm.js';

// These colors were chosen somewhat haphazardly from previous assets.
// For now, this is not customizable, colors are meant to be semi-randomly
// drawn from our design palette.
var COLORS = [colors.red[40], colors.red[60], colors.orange[40], colors.orange[60], colors.yellow[40], colors.green[20], colors.green[40], colors.blue[20], colors.blue[40], colors.magenta[20], colors.magenta[50], colors.purple[40], colors.purple[60], colors.teal[20], colors.teal[50], colors.teal[70]]; // Every circle is given a random opacity, but it's weighted so that outliers
// don't happen much.

var OPACITIES = [0.15, 0.25, 0.25, 0.25, 0.5, 0.5, 0.75];

var generateDotData = function generateDotData(numRows, numCols, angle, dotSize, fadeStrength) {
  var dots = [];
  var dotSpacing = Math.round(dotSize / 10);
  var totalDotSpace = dotSize + dotSpacing;

  for (var rowIndex = 0; rowIndex < numRows; rowIndex++) {
    for (var colIndex = 0; colIndex < numCols; colIndex++) {
      var likelihoodOfBeingBlank = getLikelihoodOfBeingBlank(angle, colIndex, rowIndex, numCols, numRows);
      var isBlank = likelihoodOfBeingBlank * testSafeMathRandom() < fadeStrength;

      if (!isBlank) {
        dots.push({
          x: colIndex * totalDotSpace,
          y: rowIndex * totalDotSpace,
          color: testSafeSample(COLORS),
          opacity: testSafeSample(OPACITIES),
          size: dotSize
        });
      }
    }
  }

  return dots;
};

var dotSvgStyles = {
  // We want to let the circles at the edge of the SVG spill out, not get
  // cropped by the SVG boundaries. Cropping will naturally occur if we
  // position this SVG at an edge of the viewport =)
  overflow: "visible"
};

var DecorativeDots = function DecorativeDots(_ref) {
  var width = _ref.width,
      height = _ref.height,
      dotSize = _ref.dotSize,
      _ref$angle = _ref.angle,
      angle = _ref$angle === void 0 ? 0 : _ref$angle,
      _ref$fadeStrength = _ref.fadeStrength,
      fadeStrength = _ref$fadeStrength === void 0 ? 0.25 : _ref$fadeStrength;
  var numRows = Math.floor(height / dotSize);
  var numCols = Math.floor(width / dotSize);
  var dots = generateDotData(numRows, numCols, angle, dotSize, fadeStrength);
  return /*#__PURE__*/createElement("svg", {
    width: width,
    height: height,
    style: dotSvgStyles,
    "aria-hidden": true
  }, dots.map(function (dot, i) {
    return /*#__PURE__*/createElement(Dot, {
      key: i,
      x: dot.x,
      y: dot.y,
      color: dot.color,
      opacity: dot.opacity,
      size: dot.size
    });
  }));
};

DecorativeDots.propTypes = {
  width: _pt.number.isRequired,
  height: _pt.number.isRequired,
  dotSize: _pt.number.isRequired,
  angle: _pt.number,
  fadeStrength: _pt.number
};
DecorativeDots.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "DecorativeDots",
  "props": {
    "angle": {
      "defaultValue": {
        "value": "0",
        "computed": false
      },
      "required": false
    },
    "fadeStrength": {
      "defaultValue": {
        "value": "0.25",
        "computed": false
      },
      "required": false
    }
  }
};
var DecorativeDots$1 = memo(DecorativeDots);

if (typeof STORYBOOK_REACT_CLASSES !== "undefined") {
  STORYBOOK_REACT_CLASSES["src/components/DecorativeDots/DecorativeDots.tsx"] = {
    name: "DecorativeDots",
    docgenInfo: DecorativeDots.__docgenInfo,
    path: "src/components/DecorativeDots/DecorativeDots.tsx"
  };
}

export default DecorativeDots$1;
//# sourceMappingURL=DecorativeDots.esm.js.map
