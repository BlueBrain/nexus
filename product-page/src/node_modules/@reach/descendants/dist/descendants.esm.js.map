{"version":3,"file":"descendants.esm.js","sources":["../src/index.tsx"],"sourcesContent":["import React, { useCallback, useContext, useMemo, useState } from \"react\";\nimport {\n  createNamedContext,\n  noop,\n  useIsomorphicLayoutEffect,\n  usePrevious,\n} from \"@reach/utils\";\n\nexport function createDescendantContext<DescendantType extends Descendant>(\n  name: string,\n  initialValue = {}\n) {\n  type T = DescendantContextValue<DescendantType>;\n  const descendants: DescendantType[] = [];\n  return createNamedContext<T>(name, {\n    descendants,\n    registerDescendant: noop,\n    unregisterDescendant: noop,\n    ...initialValue,\n  });\n}\n\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\nexport function useDescendant<DescendantType extends Descendant>(\n  descendant: Omit<DescendantType, \"index\">,\n  context: React.Context<DescendantContextValue<DescendantType>>,\n  indexProp?: number\n) {\n  let [, forceUpdate] = useState();\n  let { registerDescendant, unregisterDescendant, descendants } = useContext(\n    context\n  );\n\n  // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants\n  // so that everything is up-to-date before the user interacts with a\n  // collection.\n  let index =\n    indexProp ??\n    descendants.findIndex((item) => item.element === descendant.element);\n\n  let previousDescendants = usePrevious(descendants);\n\n  // We also need to re-register descendants any time ANY of the other\n  // descendants have changed. My brain was melting when I wrote this and it\n  // feels a little off, but checking in render and using the result in the\n  // effect's dependency array works well enough.\n  let someDescendantsHaveChanged = descendants.some((descendant, index) => {\n    return descendant.element !== previousDescendants?.[index]?.element;\n  });\n\n  // Prevent any flashing\n  useIsomorphicLayoutEffect(() => {\n    if (!descendant.element) forceUpdate({});\n    registerDescendant({\n      ...descendant,\n      index,\n    } as DescendantType);\n    return () => unregisterDescendant(descendant.element);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    registerDescendant,\n    unregisterDescendant,\n    index,\n    someDescendantsHaveChanged,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    ...Object.values(descendant),\n  ]);\n\n  return index;\n}\n\nexport function useDescendantsInit<DescendantType extends Descendant>() {\n  return useState<DescendantType[]>([]);\n}\n\nexport function useDescendants<DescendantType extends Descendant>(\n  ctx: React.Context<DescendantContextValue<DescendantType>>\n) {\n  return useContext(ctx).descendants;\n}\n\nexport function DescendantProvider<DescendantType extends Descendant>({\n  context: Ctx,\n  children,\n  items,\n  set,\n}: {\n  context: React.Context<DescendantContextValue<DescendantType>>;\n  children: React.ReactNode;\n  items: DescendantType[];\n  set: React.Dispatch<React.SetStateAction<DescendantType[]>>;\n}) {\n  let registerDescendant = useCallback(\n    ({\n      element,\n      index: explicitIndex,\n      ...rest\n    }: Omit<DescendantType, \"index\"> & { index?: number | undefined }) => {\n      if (!element) {\n        return;\n      }\n\n      set((items) => {\n        let newItems: DescendantType[];\n        if (explicitIndex != null) {\n          newItems = [\n            ...items,\n            {\n              ...rest,\n              element,\n              index: explicitIndex,\n            } as DescendantType,\n          ];\n        } else if (items.length === 0) {\n          // If there are no items, register at index 0 and bail.\n          newItems = [\n            ...items,\n            {\n              ...rest,\n              element,\n              index: 0,\n            } as DescendantType,\n          ];\n        } else if (items.find((item) => item.element === element)) {\n          // If the element is already registered, just use the same array\n          newItems = items;\n        } else {\n          // When registering a descendant, we need to make sure we insert in\n          // into the array in the same order that it appears in the DOM. So as\n          // new descendants are added or maybe some are removed, we always know\n          // that the array is up-to-date and correct.\n          //\n          // So here we look at our registered descendants and see if the new\n          // element we are adding appears earlier than an existing descendant's\n          // DOM node via `node.compareDocumentPosition`. If it does, we insert\n          // the new element at this index. Because `registerDescendant` will be\n          // called in an effect every time the descendants state value changes,\n          // we should be sure that this index is accurate when descendent\n          // elements come or go from our component.\n          let index = items.findIndex((item) => {\n            if (!item.element || !element) {\n              return false;\n            }\n            // Does this element's DOM node appear before another item in the\n            // array in our DOM tree? If so, return true to grab the index at\n            // this point in the array so we know where to insert the new\n            // element.\n            return Boolean(\n              item.element.compareDocumentPosition(element as Node) &\n                Node.DOCUMENT_POSITION_PRECEDING\n            );\n          });\n\n          let newItem = {\n            ...rest,\n            element,\n            index,\n          } as DescendantType;\n\n          // If an index is not found we will push the element to the end.\n          if (index === -1) {\n            newItems = [...items, newItem];\n          } else {\n            newItems = [\n              ...items.slice(0, index),\n              newItem,\n              ...items.slice(index),\n            ];\n          }\n        }\n        return newItems.map((item, index) => ({ ...item, index }));\n      });\n    },\n    // set is a state setter initialized by the useDescendants hook.\n    // We can safely ignore the lint warning here because it will not change\n    // between renders.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  let unregisterDescendant = useCallback(\n    (element: DescendantType[\"element\"]) => {\n      if (!element) {\n        return;\n      }\n\n      set((items) => items.filter((item) => element !== item.element));\n    },\n    // set is a state setter initialized by the useDescendants hook.\n    // We can safely ignore the lint warning here because it will not change\n    // between renders.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  return (\n    <Ctx.Provider\n      value={useMemo(() => {\n        return {\n          descendants: items,\n          registerDescendant,\n          unregisterDescendant,\n        };\n      }, [items, registerDescendant, unregisterDescendant])}\n    >\n      {children}\n    </Ctx.Provider>\n  );\n}\n\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\nexport function useDescendantKeyDown<\n  DescendantType extends Descendant,\n  K extends keyof DescendantType = keyof DescendantType\n>(\n  context: React.Context<DescendantContextValue<DescendantType>>,\n  options: {\n    currentIndex: number | null | undefined;\n    key?: K | \"option\";\n    filter?: (descendant: DescendantType) => boolean;\n    orientation?: \"vertical\" | \"horizontal\" | \"both\";\n    rotate?: boolean;\n    rtl?: boolean;\n    callback(nextOption: DescendantType | DescendantType[K]): void;\n  }\n) {\n  let { descendants } = useContext(context);\n  let {\n    callback,\n    currentIndex,\n    filter,\n    key = \"index\" as K,\n    orientation = \"vertical\",\n    rotate = true,\n    rtl = false,\n  } = options;\n  let index = currentIndex ?? -1;\n\n  return function handleKeyDown(event: React.KeyboardEvent) {\n    if (\n      ![\n        \"ArrowDown\",\n        \"ArrowUp\",\n        \"ArrowLeft\",\n        \"ArrowRight\",\n        \"PageUp\",\n        \"PageDown\",\n        \"Home\",\n        \"End\",\n      ].includes(event.key)\n    ) {\n      return;\n    }\n\n    // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n    let selectableDescendants = filter\n      ? descendants.filter(filter)\n      : descendants;\n\n    // Current index should map to the updated array vs. the original\n    // descendants array.\n    if (filter) {\n      index = selectableDescendants.findIndex(\n        (descendant) => descendant.index === currentIndex\n      );\n    }\n\n    // We need some options for any of this to work!\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    function getNextOption() {\n      let atBottom = index === selectableDescendants.length - 1;\n      return atBottom\n        ? rotate\n          ? getFirstOption()\n          : selectableDescendants[index]\n        : selectableDescendants[(index + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      let atTop = index === 0;\n      return atTop\n        ? rotate\n          ? getLastOption()\n          : selectableDescendants[index]\n        : selectableDescendants[\n            (index - 1 + selectableDescendants.length) %\n              selectableDescendants.length\n          ];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          let next = getNextOption();\n          callback(key === \"option\" ? next : next[key]);\n        }\n        break;\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          let prev = getPreviousOption();\n          callback(key === \"option\" ? prev : prev[key]);\n        }\n        break;\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          let nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n          callback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n        }\n        break;\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          let prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n          callback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n        }\n        break;\n      case \"PageUp\":\n        event.preventDefault();\n        let prevOrFirst = (event.ctrlKey\n          ? getPreviousOption\n          : getFirstOption)();\n        callback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n        break;\n      case \"Home\":\n        event.preventDefault();\n        let first = getFirstOption();\n        callback(key === \"option\" ? first : first[key]);\n        break;\n      case \"PageDown\":\n        event.preventDefault();\n        let nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n        callback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n        break;\n      case \"End\":\n        event.preventDefault();\n        let last = getLastOption();\n        callback(key === \"option\" ? last : last[key]);\n        break;\n    }\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype SomeElement<T> = T extends Element ? T : HTMLElement;\n\nexport type Descendant<ElementType = HTMLElement> = {\n  element: SomeElement<ElementType> | null;\n  index: number;\n};\n\nexport interface DescendantContextValue<DescendantType extends Descendant> {\n  descendants: DescendantType[];\n  registerDescendant(descendant: DescendantType): void;\n  unregisterDescendant(element: DescendantType[\"element\"]): void;\n}\n"],"names":["createDescendantContext","name","initialValue","descendants","createNamedContext","registerDescendant","noop","unregisterDescendant","useDescendant","descendant","context","indexProp","useState","forceUpdate","useContext","index","findIndex","item","element","previousDescendants","usePrevious","someDescendantsHaveChanged","some","useIsomorphicLayoutEffect","Object","values","useDescendantsInit","useDescendants","ctx","DescendantProvider","Ctx","children","items","set","useCallback","explicitIndex","rest","newItems","length","find","Boolean","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","newItem","slice","map","filter","React","Provider","value","useMemo","useDescendantKeyDown","options","callback","currentIndex","key","orientation","rotate","rtl","handleKeyDown","event","includes","selectableDescendants","getNextOption","atBottom","getFirstOption","getPreviousOption","atTop","getLastOption","preventDefault","next","prev","nextOrPrev","prevOrNext","prevOrFirst","ctrlKey","first","nextOrLast","last"],"mappings":"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"}