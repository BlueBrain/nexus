{"version":3,"file":"descendants.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["import React, { useCallback, useContext, useMemo, useState } from \"react\";\nimport {\n  createNamedContext,\n  noop,\n  useIsomorphicLayoutEffect,\n  usePrevious,\n} from \"@reach/utils\";\n\nexport function createDescendantContext<DescendantType extends Descendant>(\n  name: string,\n  initialValue = {}\n) {\n  type T = DescendantContextValue<DescendantType>;\n  const descendants: DescendantType[] = [];\n  return createNamedContext<T>(name, {\n    descendants,\n    registerDescendant: noop,\n    unregisterDescendant: noop,\n    ...initialValue,\n  });\n}\n\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\nexport function useDescendant<DescendantType extends Descendant>(\n  descendant: Omit<DescendantType, \"index\">,\n  context: React.Context<DescendantContextValue<DescendantType>>,\n  indexProp?: number\n) {\n  let [, forceUpdate] = useState();\n  let { registerDescendant, unregisterDescendant, descendants } = useContext(\n    context\n  );\n\n  // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants\n  // so that everything is up-to-date before the user interacts with a\n  // collection.\n  let index =\n    indexProp ??\n    descendants.findIndex((item) => item.element === descendant.element);\n\n  let previousDescendants = usePrevious(descendants);\n\n  // We also need to re-register descendants any time ANY of the other\n  // descendants have changed. My brain was melting when I wrote this and it\n  // feels a little off, but checking in render and using the result in the\n  // effect's dependency array works well enough.\n  let someDescendantsHaveChanged = descendants.some((descendant, index) => {\n    return descendant.element !== previousDescendants?.[index]?.element;\n  });\n\n  // Prevent any flashing\n  useIsomorphicLayoutEffect(() => {\n    if (!descendant.element) forceUpdate({});\n    registerDescendant({\n      ...descendant,\n      index,\n    } as DescendantType);\n    return () => unregisterDescendant(descendant.element);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    registerDescendant,\n    unregisterDescendant,\n    index,\n    someDescendantsHaveChanged,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    ...Object.values(descendant),\n  ]);\n\n  return index;\n}\n\nexport function useDescendantsInit<DescendantType extends Descendant>() {\n  return useState<DescendantType[]>([]);\n}\n\nexport function useDescendants<DescendantType extends Descendant>(\n  ctx: React.Context<DescendantContextValue<DescendantType>>\n) {\n  return useContext(ctx).descendants;\n}\n\nexport function DescendantProvider<DescendantType extends Descendant>({\n  context: Ctx,\n  children,\n  items,\n  set,\n}: {\n  context: React.Context<DescendantContextValue<DescendantType>>;\n  children: React.ReactNode;\n  items: DescendantType[];\n  set: React.Dispatch<React.SetStateAction<DescendantType[]>>;\n}) {\n  let registerDescendant = useCallback(\n    ({\n      element,\n      index: explicitIndex,\n      ...rest\n    }: Omit<DescendantType, \"index\"> & { index?: number | undefined }) => {\n      if (!element) {\n        return;\n      }\n\n      set((items) => {\n        let newItems: DescendantType[];\n        if (explicitIndex != null) {\n          newItems = [\n            ...items,\n            {\n              ...rest,\n              element,\n              index: explicitIndex,\n            } as DescendantType,\n          ];\n        } else if (items.length === 0) {\n          // If there are no items, register at index 0 and bail.\n          newItems = [\n            ...items,\n            {\n              ...rest,\n              element,\n              index: 0,\n            } as DescendantType,\n          ];\n        } else if (items.find((item) => item.element === element)) {\n          // If the element is already registered, just use the same array\n          newItems = items;\n        } else {\n          // When registering a descendant, we need to make sure we insert in\n          // into the array in the same order that it appears in the DOM. So as\n          // new descendants are added or maybe some are removed, we always know\n          // that the array is up-to-date and correct.\n          //\n          // So here we look at our registered descendants and see if the new\n          // element we are adding appears earlier than an existing descendant's\n          // DOM node via `node.compareDocumentPosition`. If it does, we insert\n          // the new element at this index. Because `registerDescendant` will be\n          // called in an effect every time the descendants state value changes,\n          // we should be sure that this index is accurate when descendent\n          // elements come or go from our component.\n          let index = items.findIndex((item) => {\n            if (!item.element || !element) {\n              return false;\n            }\n            // Does this element's DOM node appear before another item in the\n            // array in our DOM tree? If so, return true to grab the index at\n            // this point in the array so we know where to insert the new\n            // element.\n            return Boolean(\n              item.element.compareDocumentPosition(element as Node) &\n                Node.DOCUMENT_POSITION_PRECEDING\n            );\n          });\n\n          let newItem = {\n            ...rest,\n            element,\n            index,\n          } as DescendantType;\n\n          // If an index is not found we will push the element to the end.\n          if (index === -1) {\n            newItems = [...items, newItem];\n          } else {\n            newItems = [\n              ...items.slice(0, index),\n              newItem,\n              ...items.slice(index),\n            ];\n          }\n        }\n        return newItems.map((item, index) => ({ ...item, index }));\n      });\n    },\n    // set is a state setter initialized by the useDescendants hook.\n    // We can safely ignore the lint warning here because it will not change\n    // between renders.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  let unregisterDescendant = useCallback(\n    (element: DescendantType[\"element\"]) => {\n      if (!element) {\n        return;\n      }\n\n      set((items) => items.filter((item) => element !== item.element));\n    },\n    // set is a state setter initialized by the useDescendants hook.\n    // We can safely ignore the lint warning here because it will not change\n    // between renders.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  return (\n    <Ctx.Provider\n      value={useMemo(() => {\n        return {\n          descendants: items,\n          registerDescendant,\n          unregisterDescendant,\n        };\n      }, [items, registerDescendant, unregisterDescendant])}\n    >\n      {children}\n    </Ctx.Provider>\n  );\n}\n\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\nexport function useDescendantKeyDown<\n  DescendantType extends Descendant,\n  K extends keyof DescendantType = keyof DescendantType\n>(\n  context: React.Context<DescendantContextValue<DescendantType>>,\n  options: {\n    currentIndex: number | null | undefined;\n    key?: K | \"option\";\n    filter?: (descendant: DescendantType) => boolean;\n    orientation?: \"vertical\" | \"horizontal\" | \"both\";\n    rotate?: boolean;\n    rtl?: boolean;\n    callback(nextOption: DescendantType | DescendantType[K]): void;\n  }\n) {\n  let { descendants } = useContext(context);\n  let {\n    callback,\n    currentIndex,\n    filter,\n    key = \"index\" as K,\n    orientation = \"vertical\",\n    rotate = true,\n    rtl = false,\n  } = options;\n  let index = currentIndex ?? -1;\n\n  return function handleKeyDown(event: React.KeyboardEvent) {\n    if (\n      ![\n        \"ArrowDown\",\n        \"ArrowUp\",\n        \"ArrowLeft\",\n        \"ArrowRight\",\n        \"PageUp\",\n        \"PageDown\",\n        \"Home\",\n        \"End\",\n      ].includes(event.key)\n    ) {\n      return;\n    }\n\n    // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n    let selectableDescendants = filter\n      ? descendants.filter(filter)\n      : descendants;\n\n    // Current index should map to the updated array vs. the original\n    // descendants array.\n    if (filter) {\n      index = selectableDescendants.findIndex(\n        (descendant) => descendant.index === currentIndex\n      );\n    }\n\n    // We need some options for any of this to work!\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    function getNextOption() {\n      let atBottom = index === selectableDescendants.length - 1;\n      return atBottom\n        ? rotate\n          ? getFirstOption()\n          : selectableDescendants[index]\n        : selectableDescendants[(index + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      let atTop = index === 0;\n      return atTop\n        ? rotate\n          ? getLastOption()\n          : selectableDescendants[index]\n        : selectableDescendants[\n            (index - 1 + selectableDescendants.length) %\n              selectableDescendants.length\n          ];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          let next = getNextOption();\n          callback(key === \"option\" ? next : next[key]);\n        }\n        break;\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          let prev = getPreviousOption();\n          callback(key === \"option\" ? prev : prev[key]);\n        }\n        break;\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          let nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n          callback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n        }\n        break;\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          let prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n          callback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n        }\n        break;\n      case \"PageUp\":\n        event.preventDefault();\n        let prevOrFirst = (event.ctrlKey\n          ? getPreviousOption\n          : getFirstOption)();\n        callback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n        break;\n      case \"Home\":\n        event.preventDefault();\n        let first = getFirstOption();\n        callback(key === \"option\" ? first : first[key]);\n        break;\n      case \"PageDown\":\n        event.preventDefault();\n        let nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n        callback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n        break;\n      case \"End\":\n        event.preventDefault();\n        let last = getLastOption();\n        callback(key === \"option\" ? last : last[key]);\n        break;\n    }\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype SomeElement<T> = T extends Element ? T : HTMLElement;\n\nexport type Descendant<ElementType = HTMLElement> = {\n  element: SomeElement<ElementType> | null;\n  index: number;\n};\n\nexport interface DescendantContextValue<DescendantType extends Descendant> {\n  descendants: DescendantType[];\n  registerDescendant(descendant: DescendantType): void;\n  unregisterDescendant(element: DescendantType[\"element\"]): void;\n}\n"],"names":["Ctx","context","children","items","set","registerDescendant","useCallback","element","explicitIndex","index","rest","newItems","length","find","item","findIndex","Boolean","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","newItem","slice","map","unregisterDescendant","filter","React","Provider","value","useMemo","descendants","name","initialValue","createNamedContext","noop","descendant","indexProp","forceUpdate","useState","useContext","previousDescendants","usePrevious","someDescendantsHaveChanged","some","_previousDescendants$","useIsomorphicLayoutEffect","Object","values","options","callback","currentIndex","key","orientation","rotate","rtl","event","includes","selectableDescendants","preventDefault","next","getNextOption","prev","getPreviousOption","nextOrPrev","prevOrNext","prevOrFirst","ctrlKey","getFirstOption","first","nextOrLast","getLastOption","last","ctx"],"mappings":"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"}