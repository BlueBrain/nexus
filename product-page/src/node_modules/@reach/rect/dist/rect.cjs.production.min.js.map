{"version":3,"file":"rect.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["/**\n * Welcome to @reach/rect!\n *\n * Measures DOM elements (aka. bounding client rect).\n *\n * @see getBoundingClientRect https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n * @see Docs                  https://reacttraining.com/reach-ui/rect\n * @see Source                https://github.com/reach/reach-ui/tree/main/packages/rect\n */\n\nimport React, { useRef, useState } from \"react\";\nimport PropTypes from \"prop-types\";\nimport observeRect from \"@reach/observe-rect\";\nimport { useIsomorphicLayoutEffect } from \"@reach/utils\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Rect\n *\n * @param props\n */\nexport const Rect: React.FC<RectProps> = ({\n  onChange,\n  observe = true,\n  children,\n}) => {\n  const ref = useRef<HTMLElement | null>(null);\n  const rect = useRect(ref, observe, onChange);\n  return children({ ref, rect });\n};\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/rect#rect-props\n */\nexport type RectProps = {\n  /**\n   * Tells `Rect` to observe the position of the node or not. While observing,\n   * the `children` render prop may call back very quickly (especially while\n   * scrolling) so it can be important for performance to avoid observing when\n   * you don't need to.\n   *\n   * This is typically used for elements that pop over other elements (like a\n   * dropdown menu), so you don't need to observe all the time, only when the\n   * popup is active.\n   *\n   * Pass `true` to observe, `false` to ignore.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/rect#rect-observe\n   */\n  observe?: boolean;\n  /**\n   * Calls back whenever the `rect` of the element changes.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/rect#rect-onchange\n   */\n  onChange?: (rect: PRect) => void;\n  /**\n   * A function that calls back to you with a `ref` to place on an element and\n   * the `rect` measurements of the dom node.\n   *\n   * **Note**: On the first render `rect` will be `undefined` because we can't\n   * measure a node that has not yet been rendered. Make sure your code accounts\n   * for this.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/rect#rect-onchange\n   */\n  children(args: {\n    rect: PRect | null;\n    ref: React.RefObject<any>;\n  }): JSX.Element;\n};\n\nif (__DEV__) {\n  Rect.displayName = \"Rect\";\n  Rect.propTypes = {\n    children: PropTypes.func.isRequired,\n    observe: PropTypes.bool,\n    onChange: PropTypes.func,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * useRect\n *\n * @param nodeRef\n * @param observe\n * @param onChange\n */\nexport function useRect<T extends Element = HTMLElement>(\n  nodeRef: React.RefObject<T | undefined | null>,\n  observe: boolean = true,\n  onChange?: (rect: DOMRect) => void\n): null | DOMRect {\n  let [element, setElement] = useState(nodeRef.current);\n  let initialRectIsSet = useRef(false);\n  let initialRefIsSet = useRef(false);\n  let [rect, setRect] = useState<DOMRect | null>(null);\n  let onChangeRef = useRef<typeof onChange>();\n\n  useIsomorphicLayoutEffect(() => {\n    onChangeRef.current = onChange;\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    if (element && !initialRectIsSet.current) {\n      initialRectIsSet.current = true;\n      setRect(element.getBoundingClientRect());\n    }\n  }, [element]);\n\n  useIsomorphicLayoutEffect(() => {\n    let observer: ReturnType<typeof observeRect>;\n    let elem = element;\n\n    // State initializes before refs are placed, meaning the element state will\n    // be undefined on the first render. We still want the rect on the first\n    // render, so initially we'll use the nodeRef that was passed instead of\n    // state for our measurements.\n    if (!initialRefIsSet.current) {\n      initialRefIsSet.current = true;\n      elem = nodeRef.current;\n    }\n\n    if (!elem) {\n      if (__DEV__) {\n        console.warn(\"You need to place the ref\");\n      }\n      return cleanup;\n    }\n\n    observer = observeRect(elem, (rect) => {\n      onChangeRef.current && onChangeRef.current(rect);\n      setRect(rect);\n    });\n\n    observe && observer.observe();\n    return cleanup;\n\n    function cleanup() {\n      observer && observer.unobserve();\n    }\n  }, [observe, element]);\n\n  return rect;\n}\n\nexport default Rect;\n\nexport type PRect = Partial<DOMRect> & {\n  readonly bottom: number;\n  readonly height: number;\n  readonly left: number;\n  readonly right: number;\n  readonly top: number;\n  readonly width: number;\n};\n"],"names":["Rect","onChange","observe","children","ref","useRef","rect","useRect","nodeRef","useState","current","element","setElement","initialRectIsSet","initialRefIsSet","setRect","onChangeRef","useIsomorphicLayoutEffect","getBoundingClientRect","observer","elem","observeRect","cleanup","unobserve"],"mappings":"qOAsBaA,EAA4B,gBACvCC,IAAAA,aACAC,QAAAA,gBACAC,IAAAA,SAEMC,EAAMC,SAA2B,aAEhCF,EAAS,CAAEC,IAAAA,EAAKE,KADVC,EAAQH,EAAKF,EAASD,eA+DrBM,EACdC,EACAN,EACAD,YADAC,IAAAA,GAAmB,SAGSO,WAASD,EAAQE,SAAxCC,OAASC,OACVC,EAAmBR,UAAO,GAC1BS,EAAkBT,UAAO,KACPI,WAAyB,MAA1CH,OAAMS,OACPC,EAAcX,kBAElBY,6BAA0B,WACxBD,EAAYN,QAAUT,EAClBO,EAAQE,UAAYC,GACtBC,EAAWJ,EAAQE,YAIvBO,6BAA0B,WACpBN,IAAYE,EAAiBH,UAC/BG,EAAiBH,SAAU,EAC3BK,EAAQJ,EAAQO,4BAEjB,CAACP,IAEJM,6BAA0B,eACpBE,EACAC,EAAOT,SAMNG,EAAgBJ,UACnBI,EAAgBJ,SAAU,EAC1BU,EAAOZ,EAAQE,SAGZU,GAOLD,EAAWE,EAAYD,GAAM,SAACd,GAC5BU,EAAYN,SAAWM,EAAYN,QAAQJ,GAC3CS,EAAQT,MAGVJ,GAAWiB,EAASjB,UACboB,GATEA,WAWAA,IACPH,GAAYA,EAASI,eAEtB,CAACrB,EAASS,IAENL"}