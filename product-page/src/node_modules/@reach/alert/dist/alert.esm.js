import React, { forwardRef, useRef, useMemo, useEffect } from 'react';
import { render } from 'react-dom';
import VisuallyHidden from '@reach/visually-hidden';
import { useForkedRef, usePrevious, getOwnerDocument } from '@reach/utils';
import PropTypes from 'prop-types';

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/*
 * Singleton state is fine because you don't server render
 * an alert (SRs don't read them on first load anyway)
 */

var keys = {
  polite: -1,
  assertive: -1
};
var elements = {
  polite: {},
  assertive: {}
};
var liveRegions = {
  polite: null,
  assertive: null
};
var renderTimer; ////////////////////////////////////////////////////////////////////////////////

/**
 * Alert
 *
 * Screen-reader-friendly alert messages. In many apps developers add "alert"
 * messages when network events or other things happen. Users with assistive
 * technologies may not know about the message unless you develop for it.
 *
 * @see Docs https://reacttraining.com/reach-ui/alert
 */

var Alert = /*#__PURE__*/forwardRef(function Alert(_ref, forwardedRef) {
  var children = _ref.children,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? "polite" : _ref$type,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "type"]);

  var ownRef = useRef(null);
  var ref = useForkedRef(forwardedRef, ownRef);
  var child = useMemo(function () {
    return React.createElement("div", Object.assign({}, props, {
      ref: ref,
      "data-reach-alert": true
    }), children);
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [children, props]);
  useMirrorEffects(type, child, ownRef);
  return child;
});

if (process.env.NODE_ENV !== "production") {
  Alert.displayName = "Alert";
  Alert.propTypes = {
    children: PropTypes.node,
    type: /*#__PURE__*/PropTypes.oneOf(["assertive", "polite"])
  };
}

function createMirror(type, doc) {
  var key = ++keys[type];

  var mount = function mount(element) {
    if (liveRegions[type]) {
      elements[type][key] = element;
      renderAlerts();
    } else {
      var node = doc.createElement("div");
      node.setAttribute("data-reach-live-" + type, "true");
      liveRegions[type] = node;
      doc.body.appendChild(liveRegions[type]);
      mount(element);
    }
  };

  var update = function update(element) {
    elements[type][key] = element;
    renderAlerts();
  };

  var unmount = function unmount() {
    delete elements[type][key];
    renderAlerts();
  };

  return {
    mount: mount,
    update: update,
    unmount: unmount
  };
}

function renderAlerts() {
  if (renderTimer != null) {
    window.clearTimeout(renderTimer);
  }

  renderTimer = window.setTimeout(function () {
    Object.keys(elements).forEach(function (elementType) {
      var type = elementType;
      var container = liveRegions[type];

      if (container) {
        render(React.createElement(VisuallyHidden, null, React.createElement("div", {
          // The status role is a type of live region and a container whose
          // content is advisory information for the user that is not
          // important enough to justify an alert, and is often presented as
          // a status bar. When the role is added to an element, the browser
          // will send out an accessible status event to assistive
          // technology products which can then notify the user about it.
          // https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_status_role
          role: type === "assertive" ? "alert" : "status",
          "aria-live": type
        }, Object.keys(elements[type]).map(function (key) {
          return React.cloneElement(elements[type][key], {
            key: key,
            ref: null
          });
        }))), liveRegions[type]);
      }
    });
  }, 500);
}

function useMirrorEffects(type, element, ref) {
  var prevType = usePrevious(type);
  var mirror = useRef(null);
  var mounted = useRef(false);
  useEffect(function () {
    var ownerDocument = getOwnerDocument(ref.current) || document;

    if (!mounted.current) {
      mounted.current = true;
      mirror.current = createMirror(type, ownerDocument);
      mirror.current.mount(element);
    } else if (prevType !== type) {
      mirror.current && mirror.current.unmount();
      mirror.current = createMirror(type, ownerDocument);
      mirror.current.mount(element);
    } else {
      mirror.current && mirror.current.update(element);
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [element, type, prevType]);
  useEffect(function () {
    return function () {
      mirror.current && mirror.current.unmount();
    };
  }, []);
}

export default Alert;
export { Alert };
//# sourceMappingURL=alert.esm.js.map
