import { Source, Subscription } from 'wonka';
import { Exchange, GraphQLRequest, Operation, OperationContext, OperationResult, OperationType, RequestPolicy, PromisifiedSource, DebugEvent } from './types';
import { DocumentNode } from 'graphql';
/** Options for configuring the URQL [client]{@link Client}. */
export interface ClientOptions {
    /** Target endpoint URL such as `https://my-target:8080/graphql`. */
    url: string;
    /** Any additional options to pass to fetch. */
    fetchOptions?: RequestInit | (() => RequestInit);
    /** An alternative fetch implementation. */
    fetch?: typeof fetch;
    /** An ordered array of Exchanges. */
    exchanges?: Exchange[];
    /** Activates support for Suspense. */
    suspense?: boolean;
    /** The default request policy for requests. */
    requestPolicy?: RequestPolicy;
    /** Use HTTP GET for queries. */
    preferGetMethod?: boolean;
    /** Mask __typename from results. */
    maskTypename?: boolean;
}
interface ActiveOperations {
    [operationKey: string]: number;
}
export declare const createClient: (opts: ClientOptions) => Client;
/** The URQL application-wide client library. Each execute method starts a GraphQL request and returns a stream of results. */
export declare class Client {
    /** Start an operation from an exchange */
    reexecuteOperation: (operation: Operation) => void;
    subscribeToDebugTarget?: (onEvent: (e: DebugEvent) => void) => Subscription;
    url: string;
    fetch?: typeof fetch;
    fetchOptions?: RequestInit | (() => RequestInit);
    suspense: boolean;
    preferGetMethod: boolean;
    requestPolicy: RequestPolicy;
    maskTypename: boolean;
    dispatchOperation: (operation?: Operation | void) => void;
    operations$: Source<Operation>;
    results$: Source<OperationResult>;
    activeOperations: ActiveOperations;
    queue: Operation[];
    constructor(opts: ClientOptions);
    private createOperationContext;
    createRequestOperation: (type: OperationType, request: GraphQLRequest, opts?: Partial<OperationContext> | undefined) => Operation;
    /** Counts up the active operation key and dispatches the operation */
    private onOperationStart;
    /** Deletes an active operation's result observable and sends a teardown signal through the exchange pipeline */
    private onOperationEnd;
    /** Executes an Operation by sending it through the exchange pipeline It returns an observable that emits all related exchange results and keeps track of this observable's subscribers. A teardown signal will be emitted when no subscribers are listening anymore. */
    executeRequestOperation(operation: Operation): Source<OperationResult>;
    query<Data = any, Variables extends object = {}>(query: DocumentNode | string, variables?: Variables, context?: Partial<OperationContext>): PromisifiedSource<OperationResult<Data>>;
    readQuery<Data = any, Variables extends object = {}>(query: DocumentNode | string, variables?: Variables, context?: Partial<OperationContext>): OperationResult<Data> | null;
    executeQuery: <Data = any>(query: GraphQLRequest, opts?: Partial<OperationContext> | undefined) => Source<OperationResult<Data>>;
    subscription<Data = any, Variables extends object = {}>(query: DocumentNode | string, variables?: Variables, context?: Partial<OperationContext>): Source<OperationResult<Data>>;
    executeSubscription: (query: GraphQLRequest, opts?: Partial<OperationContext> | undefined) => Source<OperationResult>;
    mutation<Data = any, Variables extends object = {}>(query: DocumentNode | string, variables?: Variables, context?: Partial<OperationContext>): PromisifiedSource<OperationResult<Data>>;
    executeMutation: <Data = any>(query: GraphQLRequest, opts?: Partial<OperationContext> | undefined) => Source<OperationResult<Data>>;
}
export {};
