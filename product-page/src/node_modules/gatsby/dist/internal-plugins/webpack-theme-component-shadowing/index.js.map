{"version":3,"sources":["../../../src/internal-plugins/webpack-theme-component-shadowing/index.js"],"names":["path","require","debug","fs","_","pathWithoutExtension","fullPath","parsed","parse","join","dir","name","module","exports","GatsbyThemeComponentShadowingResolverPlugin","constructor","projectRoot","themes","extensions","cache","map","themeName","apply","resolver","hooks","relative","tapAsync","request","stack","callback","matchingThemes","getMatchingThemesForPath","length","Error","theme","component","split","themeDir","context","issuer","requestPathIsIssuerShadowPath","requestPath","issuerPath","userSiteDir","doResolve","describedRelative","builtComponentPath","resolveComponentPath","matchingTheme","ogThemes","filter","themesArray","concat","Array","from","reverse","possibleComponentPath","readdirSync","dirname","e","existsDir","filepath","basename","isExactPath","includes","matchingExtension","find","ext","allMatchingThemes","uniqBy","getBaseShadowDirsForThemes","shadowFiles"],"mappings":"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","sourcesContent":["const path = require(`path`)\nconst debug = require(`debug`)(`gatsby:component-shadowing`)\nconst fs = require(`fs`)\nconst _ = require(`lodash`)\n\nconst pathWithoutExtension = fullPath => {\n  const parsed = path.parse(fullPath)\n  return path.join(parsed.dir, parsed.name)\n}\n\n// TO-DO:\n//  - implement ability to add/remove shadowed modules from the webpack chain as file are being created/deleted\n//    ( https://github.com/gatsbyjs/gatsby/issues/11456 ):\n//    - this will also need to add memo invalidation for page template shadowing:\n//      see memoized `shadowCreatePagePath` function used in `createPage` action creator.\n\nmodule.exports = class GatsbyThemeComponentShadowingResolverPlugin {\n  cache = {}\n\n  constructor({ projectRoot, themes, extensions }) {\n    debug(\n      `themes list`,\n      themes.map(({ themeName }) => themeName)\n    )\n    this.themes = themes\n    this.projectRoot = projectRoot\n    this.extensions = extensions\n  }\n\n  apply(resolver) {\n    resolver.hooks.relative.tapAsync(\n      `GatsbyThemeComponentShadowingResolverPlugin`,\n      (request, stack, callback) => {\n        const matchingThemes = this.getMatchingThemesForPath(request.path)\n\n        // 0 matching themes happens a lot for paths we don't want to handle\n        // > 1 matching theme means we have a path like\n        //   `gatsby-theme-blog/src/components/gatsby-theme-something/src/components`\n        if (matchingThemes.length > 1) {\n          throw new Error(\n            `Gatsby can't differentiate between themes ${matchingThemes\n              .map(theme => theme.themeName)\n              .join(` and `)} for path ${request.path}`\n          )\n        }\n\n        if (matchingThemes.length !== 1) {\n          return callback()\n        }\n\n        // theme is the theme package from which we're requiring the relative component\n        const [theme] = matchingThemes\n        // get the location of the component relative to src/\n        const [, component] = request.path.split(\n          path.join(theme.themeDir, `src`)\n        )\n\n        if (\n          /**\n           * if someone adds\n           * ```\n           * modules: [path.resolve(__dirname, 'src'), 'node_modules'],\n           * ```\n           * to the webpack config, `issuer` is `null`, so we skip this check.\n           * note that it's probably a bad idea in general to set `modules`\n           * like this in a theme, but we also shouldn't artificially break\n           * people that do.\n           */\n          request.context.issuer &&\n          /**\n           * An issuer is the file making the require request. It can\n           * be in a user's site or a theme. If the issuer is requesting\n           * a path in the shadow chain that it participates in, then we\n           * will let the request through as normal. Otherwise, we\n           * engage the shadowing algorithm.\n           */\n          this.requestPathIsIssuerShadowPath({\n            requestPath: request.path,\n            issuerPath: request.context.issuer,\n            userSiteDir: this.projectRoot,\n          })\n        ) {\n          return resolver.doResolve(\n            resolver.hooks.describedRelative,\n            request,\n            null,\n            {},\n            callback\n          )\n        }\n\n        // This is the shadowing algorithm.\n        const builtComponentPath = this.resolveComponentPath({\n          matchingTheme: theme.themeName,\n          themes: this.themes,\n          component,\n        })\n\n        return resolver.doResolve(\n          resolver.hooks.describedRelative,\n          { ...request, path: builtComponentPath || request.path },\n          null,\n          {},\n          callback\n        )\n      }\n    )\n  }\n\n  // check the cache, the user's project, and finally the theme files\n  resolveComponentPath({ matchingTheme: theme, themes: ogThemes, component }) {\n    // don't include matching theme in possible shadowing paths\n    const themes = ogThemes.filter(({ themeName }) => themeName !== theme)\n\n    const themesArray = [path.join(this.projectRoot, `src`, theme)].concat(\n      Array.from(themes)\n        .reverse()\n        .map(({ themeDir }) => path.join(themeDir, `src`, theme))\n    )\n\n    for (const theme of themesArray) {\n      const possibleComponentPath = path.join(theme, component)\n      debug(`possibleComponentPath`, possibleComponentPath)\n\n      let dir\n      try {\n        // we use fs/path instead of require.resolve to work with\n        // TypeScript and alternate syntaxes\n        dir = fs.readdirSync(path.dirname(possibleComponentPath))\n      } catch (e) {\n        continue\n      }\n      const existsDir = dir.map(filepath => path.basename(filepath))\n\n      const isExactPath = existsDir.includes(\n        path.basename(possibleComponentPath) // find if there is an exact path match\n      )\n\n      if (isExactPath) return possibleComponentPath\n\n      // if no exact path, search for extension\n      const matchingExtension = this.extensions.find(ext =>\n        existsDir.includes(path.basename(possibleComponentPath) + ext)\n      )\n      if (matchingExtension) return possibleComponentPath + matchingExtension // if extension matches, create path\n    }\n    return null\n  }\n\n  getMatchingThemesForPath(filepath) {\n    // find out which theme's src/components dir we're requiring from\n    const allMatchingThemes = this.themes.filter(({ themeDir }) =>\n      filepath.includes(path.join(themeDir, `src`))\n    )\n\n    // The same theme can be included twice in the themes list causing multiple\n    // matches. This case should only be counted as a single match for that theme.\n    return _.uniqBy(allMatchingThemes, `themeName`)\n  }\n\n  // given a theme name, return all of the possible shadow locations\n  getBaseShadowDirsForThemes(theme) {\n    return Array.from(this.themes)\n      .reverse()\n      .map(({ themeName, themeDir }) => {\n        if (themeName === theme) {\n          return path.join(themeDir, `src`)\n        } else {\n          return path.join(themeDir, `src`, theme)\n        }\n      })\n  }\n\n  requestPathIsIssuerShadowPath({ requestPath, issuerPath, userSiteDir }) {\n    // get the issuer's theme\n    const matchingThemes = this.getMatchingThemesForPath(requestPath)\n    if (matchingThemes.length !== 1) {\n      return false\n    }\n    const [theme] = matchingThemes\n\n    // get the location of the component relative to src/\n    const [, component] = requestPath.split(path.join(theme.themeDir, `src`))\n\n    // get list of potential shadow locations\n    const shadowFiles = this.getBaseShadowDirsForThemes(theme.themeName)\n      .concat(path.join(userSiteDir, `src`, theme.themeName))\n      .map(dir => path.join(dir, component))\n\n    // if the issuer is requesting a path that is a potential shadow path of itself\n    return shadowFiles.includes(pathWithoutExtension(issuerPath))\n  }\n}\n"],"file":"index.js"}