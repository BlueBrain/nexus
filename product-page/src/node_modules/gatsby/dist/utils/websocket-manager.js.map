{"version":3,"sources":["../../src/utils/websocket-manager.ts"],"names":["getCachedPageData","pagePath","program","pages","store","getState","publicDir","path","join","directory","has","pageData","result","id","err","Error","undefined","hashPaths","paths","map","update","digest","getCachedStaticQueryResults","resultsMap","cachedStaticQueryResults","Map","staticQueryComponents","forEach","staticQueryComponent","hash","filePath","fileResult","fs","readFileSync","console","log","componentPath","set","JSON","parse","getRoomNameFromPath","WebsocketManager","activePaths","Set","connectedClients","errors","pageResults","staticQueryResults","init","server","websocket","on","socket","activePath","handshake","headers","referer","url","add","send","type","payload","message","errorID","leaveRoom","leave","leftRoom","sockets","adapter","rooms","length","delete","getDataForPath","why","get","telemetry","trackCli","siteMeasurements","clientsCount","Array","from","debounce","getSocket","emitStaticQueryData","data","emitPageData","emitError","websocketManager"],"mappings":"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","sourcesContent":["/* eslint-disable no-invalid-this */\nimport path from \"path\"\nimport { store } from \"../redux\"\nimport { Server as HTTPSServer } from \"https\"\nimport { Server as HTTPServer } from \"http\"\nimport fs from \"fs\"\nimport { readPageData, IPageDataWithQueryResult } from \"../utils/page-data\"\nimport telemetry from \"gatsby-telemetry\"\nimport url from \"url\"\nimport { createHash } from \"crypto\"\nimport { normalizePagePath, denormalizePagePath } from \"./normalize-page-path\"\nimport socketIO from \"socket.io\"\n\nexport interface IPageQueryResult {\n  id: string\n  result?: IPageDataWithQueryResult\n}\n\nexport interface IStaticQueryResult {\n  id: string\n  result: unknown // TODO: Improve this once we understand what the type is\n}\n\ntype PageResultsMap = Map<string, IPageQueryResult>\ntype QueryResultsMap = Map<string, IStaticQueryResult>\n\n/**\n * Get cached page query result for given page path.\n * @param {string} pagePath Path to a page.\n */\nconst getCachedPageData = async (\n  pagePath: string\n): Promise<IPageQueryResult> => {\n  const { program, pages } = store.getState()\n  const publicDir = path.join(program.directory, `public`)\n  if (pages.has(denormalizePagePath(pagePath)) || pages.has(pagePath)) {\n    try {\n      const pageData: IPageDataWithQueryResult = await readPageData(\n        publicDir,\n        pagePath\n      )\n\n      return {\n        result: pageData,\n        id: pagePath,\n      }\n    } catch (err) {\n      throw new Error(\n        `Error loading a result for the page query in \"${pagePath}\". Query was not run and no cached result was found.`\n      )\n    }\n  }\n\n  return {\n    id: pagePath,\n    result: undefined,\n  }\n}\n\nconst hashPaths = (paths?: string[]): undefined | Array<string | undefined> => {\n  if (!paths) {\n    return undefined\n  }\n  return paths.map(path => {\n    if (!path) {\n      return undefined\n    }\n    return createHash(`sha256`).update(path).digest(`hex`)\n  })\n}\n\n/**\n * Get cached StaticQuery results for components that Gatsby didn't run query yet.\n * @param {QueryResultsMap} resultsMap Already stored results for queries that don't need to be read from files.\n * @param {string} directory Root directory of current project.\n */\nconst getCachedStaticQueryResults = (\n  resultsMap: QueryResultsMap,\n  directory: string\n): QueryResultsMap => {\n  const cachedStaticQueryResults: QueryResultsMap = new Map()\n  const { staticQueryComponents } = store.getState()\n  staticQueryComponents.forEach(staticQueryComponent => {\n    // Don't read from file if results were already passed from query runner\n    if (resultsMap.has(staticQueryComponent.hash)) return\n    const filePath = path.join(\n      directory,\n      `public`,\n      `static`,\n      `d`,\n      `${staticQueryComponent.hash}.json`\n    )\n    const fileResult = fs.readFileSync(filePath, `utf-8`)\n    if (fileResult === `undefined`) {\n      console.log(\n        `Error loading a result for the StaticQuery in \"${staticQueryComponent.componentPath}\". Query was not run and no cached result was found.`\n      )\n      return\n    }\n    cachedStaticQueryResults.set(staticQueryComponent.hash, {\n      result: JSON.parse(fileResult),\n      id: staticQueryComponent.hash,\n    })\n  })\n  return cachedStaticQueryResults\n}\n\nconst getRoomNameFromPath = (path: string): string => `path-${path}`\n\nexport class WebsocketManager {\n  activePaths: Set<string> = new Set()\n  connectedClients = 0\n  errors: Map<string, string> = new Map()\n  pageResults: PageResultsMap = new Map()\n  staticQueryResults: QueryResultsMap = new Map()\n  websocket: socketIO.Server | undefined\n\n  init = ({\n    directory,\n    server,\n  }: {\n    directory: string\n    server: HTTPSServer | HTTPServer\n  }): socketIO.Server => {\n    const cachedStaticQueryResults = getCachedStaticQueryResults(\n      this.staticQueryResults,\n      directory\n    )\n    this.staticQueryResults = new Map([\n      ...this.staticQueryResults,\n      ...cachedStaticQueryResults,\n    ])\n\n    this.websocket = socketIO(server)\n\n    this.websocket.on(`connection`, socket => {\n      let activePath: string | null = null\n      if (socket?.handshake?.headers?.referer) {\n        const path = url.parse(socket.handshake.headers.referer).path\n        if (path) {\n          activePath = path\n          this.activePaths.add(path)\n        }\n      }\n\n      this.connectedClients += 1\n      // Send already existing static query results\n      this.staticQueryResults.forEach(result => {\n        socket.send({\n          type: `staticQueryResult`,\n          payload: result,\n        })\n      })\n      this.errors.forEach((message, errorID) => {\n        socket.send({\n          type: `overlayError`,\n          payload: {\n            id: errorID,\n            message,\n          },\n        })\n      })\n\n      const leaveRoom = (path: string): void => {\n        socket.leave(getRoomNameFromPath(path))\n        if (!this.websocket) return\n        const leftRoom = this.websocket.sockets.adapter.rooms[\n          getRoomNameFromPath(path)\n        ]\n        if (!leftRoom || leftRoom.length === 0) {\n          this.activePaths.delete(path)\n        }\n      }\n\n      const getDataForPath = async (path: string): Promise<void> => {\n        if (!this.pageResults.has(path)) {\n          try {\n            const result = await getCachedPageData(path)\n\n            this.pageResults.set(path, result)\n          } catch (err) {\n            console.log(err.message)\n\n            return\n          }\n        }\n\n        socket.send({\n          type: `pageQueryResult`,\n          why: `getDataForPath`,\n          payload: this.pageResults.get(path),\n        })\n\n        if (this.connectedClients > 0) {\n          telemetry.trackCli(\n            `WEBSOCKET_PAGE_DATA_UPDATE`,\n            {\n              siteMeasurements: {\n                clientsCount: this.connectedClients,\n                paths: hashPaths(Array.from(this.activePaths)),\n              },\n            },\n            { debounce: true }\n          )\n        }\n      }\n\n      socket.on(`getDataForPath`, getDataForPath)\n\n      socket.on(`registerPath`, (path: string): void => {\n        socket.join(getRoomNameFromPath(path))\n        activePath = path\n        this.activePaths.add(path)\n      })\n\n      socket.on(`disconnect`, (): void => {\n        if (activePath) leaveRoom(activePath)\n        this.connectedClients -= 1\n      })\n\n      socket.on(`unregisterPath`, (path: string): void => {\n        leaveRoom(path)\n      })\n    })\n\n    return this.websocket\n  }\n\n  getSocket = (): socketIO.Server | undefined => this.websocket\n\n  emitStaticQueryData = (data: IStaticQueryResult): void => {\n    this.staticQueryResults.set(data.id, data)\n\n    if (this.websocket) {\n      this.websocket.send({ type: `staticQueryResult`, payload: data })\n      if (this.connectedClients > 0) {\n        telemetry.trackCli(\n          `WEBSOCKET_EMIT_STATIC_PAGE_DATA_UPDATE`,\n          {\n            siteMeasurements: {\n              clientsCount: this.connectedClients,\n              paths: hashPaths(Array.from(this.activePaths)),\n            },\n          },\n          { debounce: true }\n        )\n      }\n    }\n  }\n\n  emitPageData = (data: IPageQueryResult): void => {\n    data.id = normalizePagePath(data.id)\n    this.pageResults.set(data.id, data)\n\n    if (this.websocket) {\n      this.websocket.send({ type: `pageQueryResult`, payload: data })\n\n      if (this.connectedClients > 0) {\n        telemetry.trackCli(\n          `WEBSOCKET_EMIT_PAGE_DATA_UPDATE`,\n          {\n            siteMeasurements: {\n              clientsCount: this.connectedClients,\n              paths: hashPaths(Array.from(this.activePaths)),\n            },\n          },\n          { debounce: true }\n        )\n      }\n    }\n  }\n\n  emitError = (id: string, message?: string): void => {\n    if (message) {\n      this.errors.set(id, message)\n    } else {\n      this.errors.delete(id)\n    }\n\n    if (this.websocket) {\n      this.websocket.send({ type: `overlayError`, payload: { id, message } })\n    }\n  }\n}\n\nexport const websocketManager: WebsocketManager = new WebsocketManager()\n"],"file":"websocket-manager.js"}