"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.websocketManager = exports.WebsocketManager = void 0;

var _path = _interopRequireDefault(require("path"));

var _redux = require("../redux");

var _fs = _interopRequireDefault(require("fs"));

var _pageData = require("../utils/page-data");

var _gatsbyTelemetry = _interopRequireDefault(require("gatsby-telemetry"));

var _url = _interopRequireDefault(require("url"));

var _crypto = require("crypto");

var _normalizePagePath = require("./normalize-page-path");

var _socket = _interopRequireDefault(require("socket.io"));

/* eslint-disable no-invalid-this */

/**
 * Get cached page query result for given page path.
 * @param {string} pagePath Path to a page.
 */
const getCachedPageData = async pagePath => {
  const {
    program,
    pages
  } = _redux.store.getState();

  const publicDir = _path.default.join(program.directory, `public`);

  if (pages.has((0, _normalizePagePath.denormalizePagePath)(pagePath)) || pages.has(pagePath)) {
    try {
      const pageData = await (0, _pageData.readPageData)(publicDir, pagePath);
      return {
        result: pageData,
        id: pagePath
      };
    } catch (err) {
      throw new Error(`Error loading a result for the page query in "${pagePath}". Query was not run and no cached result was found.`);
    }
  }

  return {
    id: pagePath,
    result: undefined
  };
};

const hashPaths = paths => {
  if (!paths) {
    return undefined;
  }

  return paths.map(path => {
    if (!path) {
      return undefined;
    }

    return (0, _crypto.createHash)(`sha256`).update(path).digest(`hex`);
  });
};
/**
 * Get cached StaticQuery results for components that Gatsby didn't run query yet.
 * @param {QueryResultsMap} resultsMap Already stored results for queries that don't need to be read from files.
 * @param {string} directory Root directory of current project.
 */


const getCachedStaticQueryResults = (resultsMap, directory) => {
  const cachedStaticQueryResults = new Map();

  const {
    staticQueryComponents
  } = _redux.store.getState();

  staticQueryComponents.forEach(staticQueryComponent => {
    // Don't read from file if results were already passed from query runner
    if (resultsMap.has(staticQueryComponent.hash)) return;

    const filePath = _path.default.join(directory, `public`, `static`, `d`, `${staticQueryComponent.hash}.json`);

    const fileResult = _fs.default.readFileSync(filePath, `utf-8`);

    if (fileResult === `undefined`) {
      console.log(`Error loading a result for the StaticQuery in "${staticQueryComponent.componentPath}". Query was not run and no cached result was found.`);
      return;
    }

    cachedStaticQueryResults.set(staticQueryComponent.hash, {
      result: JSON.parse(fileResult),
      id: staticQueryComponent.hash
    });
  });
  return cachedStaticQueryResults;
};

const getRoomNameFromPath = path => `path-${path}`;

class WebsocketManager {
  constructor() {
    this.activePaths = new Set();
    this.connectedClients = 0;
    this.errors = new Map();
    this.pageResults = new Map();
    this.staticQueryResults = new Map();

    this.init = ({
      directory,
      server
    }) => {
      const cachedStaticQueryResults = getCachedStaticQueryResults(this.staticQueryResults, directory);
      this.staticQueryResults = new Map([...this.staticQueryResults, ...cachedStaticQueryResults]);
      this.websocket = (0, _socket.default)(server);
      this.websocket.on(`connection`, socket => {
        var _socket$handshake, _socket$handshake$hea;

        let activePath = null;

        if (socket === null || socket === void 0 ? void 0 : (_socket$handshake = socket.handshake) === null || _socket$handshake === void 0 ? void 0 : (_socket$handshake$hea = _socket$handshake.headers) === null || _socket$handshake$hea === void 0 ? void 0 : _socket$handshake$hea.referer) {
          const path = _url.default.parse(socket.handshake.headers.referer).path;

          if (path) {
            activePath = path;
            this.activePaths.add(path);
          }
        }

        this.connectedClients += 1; // Send already existing static query results

        this.staticQueryResults.forEach(result => {
          socket.send({
            type: `staticQueryResult`,
            payload: result
          });
        });
        this.errors.forEach((message, errorID) => {
          socket.send({
            type: `overlayError`,
            payload: {
              id: errorID,
              message
            }
          });
        });

        const leaveRoom = path => {
          socket.leave(getRoomNameFromPath(path));
          if (!this.websocket) return;
          const leftRoom = this.websocket.sockets.adapter.rooms[getRoomNameFromPath(path)];

          if (!leftRoom || leftRoom.length === 0) {
            this.activePaths.delete(path);
          }
        };

        const getDataForPath = async path => {
          if (!this.pageResults.has(path)) {
            try {
              const result = await getCachedPageData(path);
              this.pageResults.set(path, result);
            } catch (err) {
              console.log(err.message);
              return;
            }
          }

          socket.send({
            type: `pageQueryResult`,
            why: `getDataForPath`,
            payload: this.pageResults.get(path)
          });

          if (this.connectedClients > 0) {
            _gatsbyTelemetry.default.trackCli(`WEBSOCKET_PAGE_DATA_UPDATE`, {
              siteMeasurements: {
                clientsCount: this.connectedClients,
                paths: hashPaths(Array.from(this.activePaths))
              }
            }, {
              debounce: true
            });
          }
        };

        socket.on(`getDataForPath`, getDataForPath);
        socket.on(`registerPath`, path => {
          socket.join(getRoomNameFromPath(path));
          activePath = path;
          this.activePaths.add(path);
        });
        socket.on(`disconnect`, () => {
          if (activePath) leaveRoom(activePath);
          this.connectedClients -= 1;
        });
        socket.on(`unregisterPath`, path => {
          leaveRoom(path);
        });
      });
      return this.websocket;
    };

    this.getSocket = () => this.websocket;

    this.emitStaticQueryData = data => {
      this.staticQueryResults.set(data.id, data);

      if (this.websocket) {
        this.websocket.send({
          type: `staticQueryResult`,
          payload: data
        });

        if (this.connectedClients > 0) {
          _gatsbyTelemetry.default.trackCli(`WEBSOCKET_EMIT_STATIC_PAGE_DATA_UPDATE`, {
            siteMeasurements: {
              clientsCount: this.connectedClients,
              paths: hashPaths(Array.from(this.activePaths))
            }
          }, {
            debounce: true
          });
        }
      }
    };

    this.emitPageData = data => {
      data.id = (0, _normalizePagePath.normalizePagePath)(data.id);
      this.pageResults.set(data.id, data);

      if (this.websocket) {
        this.websocket.send({
          type: `pageQueryResult`,
          payload: data
        });

        if (this.connectedClients > 0) {
          _gatsbyTelemetry.default.trackCli(`WEBSOCKET_EMIT_PAGE_DATA_UPDATE`, {
            siteMeasurements: {
              clientsCount: this.connectedClients,
              paths: hashPaths(Array.from(this.activePaths))
            }
          }, {
            debounce: true
          });
        }
      }
    };

    this.emitError = (id, message) => {
      if (message) {
        this.errors.set(id, message);
      } else {
        this.errors.delete(id);
      }

      if (this.websocket) {
        this.websocket.send({
          type: `overlayError`,
          payload: {
            id,
            message
          }
        });
      }
    };
  }

}

exports.WebsocketManager = WebsocketManager;
const websocketManager = new WebsocketManager();
exports.websocketManager = websocketManager;
//# sourceMappingURL=websocket-manager.js.map