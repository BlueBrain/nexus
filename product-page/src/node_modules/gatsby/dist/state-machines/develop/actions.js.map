{"version":3,"sources":["../../../src/state-machines/develop/actions.ts"],"names":["callApi","store","event","payload","addNodeMutation","nodeMutationBatch","push","assignStoreAndWorkerPool","_context","workerPool","data","setQueryRunningFinished","boundActionCreators","setProgramStatus","ProgramStatus","BOOTSTRAP_QUERY_RUNNING_FINISHED","markQueryFilesDirty","queryFilesDirty","markSourceFilesDirty","sourceFilesDirty","markSourceFilesClean","assignServiceResult","spawnMutationListener","mutationListener","listenForMutations","assignServers","spawnWebpackListener","webpackListener","compiler","undefined","assignWebhookBody","webhookBody","clearWebhookBody","finishParentSpan","parentSpan","finish","saveDbState","logError","reporter","error","panic","markNodesDirty","nodesMutatedDuringQueryRun","buildActions"],"mappings":"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","sourcesContent":["import {\n  assign,\n  AnyEventObject,\n  ActionFunction,\n  spawn,\n  ActionFunctionMap,\n  DoneEventObject,\n} from \"xstate\"\nimport { IBuildContext } from \"../../services\"\nimport { boundActionCreators } from \"../../redux/actions\"\nimport { listenForMutations } from \"../../services/listen-for-mutations\"\nimport { DataLayerResult } from \"../data-layer\"\nimport { saveState } from \"../../db\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { ProgramStatus } from \"../../redux/types\"\nimport { createWebpackWatcher } from \"../../services/listen-to-webpack\"\nimport { callRealApi } from \"../../utils/call-deferred-api\"\n/**\n * Handler for when we're inside handlers that should be able to mutate nodes\n * Instead of queueing, we call it right away\n */\nexport const callApi: ActionFunction<IBuildContext, AnyEventObject> = (\n  { store },\n  event\n) => callRealApi(event.payload, store)\n\n/**\n * Event handler used in all states where we're not ready to process node\n * mutations. Instead we add it to a batch to process when we're next idle\n */\nexport const addNodeMutation = assign<IBuildContext, AnyEventObject>({\n  nodeMutationBatch: ({ nodeMutationBatch = [] }, { payload }) => {\n    // It's not pretty, but it's much quicker than concat\n    nodeMutationBatch.push(payload)\n    return nodeMutationBatch\n  },\n})\n\nexport const assignStoreAndWorkerPool = assign<IBuildContext, DoneEventObject>(\n  (_context, event) => {\n    const { store, workerPool } = event.data\n    return {\n      store,\n      workerPool,\n    }\n  }\n)\n\nconst setQueryRunningFinished = async (): Promise<void> => {\n  boundActionCreators.setProgramStatus(\n    ProgramStatus.BOOTSTRAP_QUERY_RUNNING_FINISHED\n  )\n}\n\nexport const markQueryFilesDirty = assign<IBuildContext>({\n  queryFilesDirty: true,\n})\n\nexport const markSourceFilesDirty = assign<IBuildContext>({\n  sourceFilesDirty: true,\n})\n\nexport const markSourceFilesClean = assign<IBuildContext>({\n  sourceFilesDirty: false,\n})\n\nexport const assignServiceResult = assign<IBuildContext, DoneEventObject>(\n  (_context, { data }): DataLayerResult => data\n)\n\n/**\n * This spawns the service that listens to the `emitter` for various mutation events\n */\nexport const spawnMutationListener = assign<IBuildContext>({\n  mutationListener: () => spawn(listenForMutations, `listen-for-mutations`),\n})\n\nexport const assignServers = assign<IBuildContext, AnyEventObject>(\n  (_context, { data }) => {\n    return {\n      ...data,\n    }\n  }\n)\n\nexport const spawnWebpackListener = assign<IBuildContext, AnyEventObject>({\n  webpackListener: ({ compiler }) => {\n    if (!compiler) {\n      return undefined\n    }\n    return spawn(createWebpackWatcher(compiler))\n  },\n})\n\nexport const assignWebhookBody = assign<IBuildContext, AnyEventObject>({\n  webhookBody: (_context, { payload }) => payload?.webhookBody,\n})\n\nexport const clearWebhookBody = assign<IBuildContext, AnyEventObject>({\n  webhookBody: undefined,\n})\n\nexport const finishParentSpan = ({ parentSpan }: IBuildContext): void =>\n  parentSpan?.finish()\n\nexport const saveDbState = (): Promise<void> => saveState()\n\nexport const logError: ActionFunction<IBuildContext, AnyEventObject> = (\n  _context,\n  event\n) => {\n  reporter.error(event.data)\n}\n\nexport const panic: ActionFunction<IBuildContext, AnyEventObject> = (\n  _context,\n  event\n) => {\n  reporter.panic(event.data)\n}\n\n/**\n * Event handler used in all states where we're not ready to process a file change\n * Instead we add it to a batch to process when we're next idle\n */\n// export const markFilesDirty: BuildMachineAction = assign<IBuildContext>({\n//   filesDirty: true,\n// })\n\nexport const markNodesDirty = assign<IBuildContext>({\n  nodesMutatedDuringQueryRun: true,\n})\n\nexport const buildActions: ActionFunctionMap<IBuildContext, AnyEventObject> = {\n  callApi,\n  markNodesDirty,\n  addNodeMutation,\n  spawnMutationListener,\n  assignStoreAndWorkerPool,\n  assignServiceResult,\n  assignServers,\n  markQueryFilesDirty,\n  assignWebhookBody,\n  clearWebhookBody,\n  finishParentSpan,\n  spawnWebpackListener,\n  markSourceFilesDirty,\n  markSourceFilesClean,\n  saveDbState,\n  setQueryRunningFinished,\n  panic,\n  logError,\n}\n"],"file":"actions.js"}