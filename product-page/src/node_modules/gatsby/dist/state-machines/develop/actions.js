"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.buildActions = exports.markNodesDirty = exports.panic = exports.logError = exports.saveDbState = exports.finishParentSpan = exports.clearWebhookBody = exports.assignWebhookBody = exports.spawnWebpackListener = exports.assignServers = exports.spawnMutationListener = exports.assignServiceResult = exports.markSourceFilesClean = exports.markSourceFilesDirty = exports.markQueryFilesDirty = exports.assignStoreAndWorkerPool = exports.addNodeMutation = exports.callApi = void 0;

var _xstate = require("xstate");

var _actions = require("../../redux/actions");

var _listenForMutations = require("../../services/listen-for-mutations");

var _db = require("../../db");

var _reporter = _interopRequireDefault(require("gatsby-cli/lib/reporter"));

var _types = require("../../redux/types");

var _listenToWebpack = require("../../services/listen-to-webpack");

var _callDeferredApi = require("../../utils/call-deferred-api");

/**
 * Handler for when we're inside handlers that should be able to mutate nodes
 * Instead of queueing, we call it right away
 */
const callApi = ({
  store
}, event) => (0, _callDeferredApi.callRealApi)(event.payload, store);
/**
 * Event handler used in all states where we're not ready to process node
 * mutations. Instead we add it to a batch to process when we're next idle
 */


exports.callApi = callApi;
const addNodeMutation = (0, _xstate.assign)({
  nodeMutationBatch: ({
    nodeMutationBatch = []
  }, {
    payload
  }) => {
    // It's not pretty, but it's much quicker than concat
    nodeMutationBatch.push(payload);
    return nodeMutationBatch;
  }
});
exports.addNodeMutation = addNodeMutation;
const assignStoreAndWorkerPool = (0, _xstate.assign)((_context, event) => {
  const {
    store,
    workerPool
  } = event.data;
  return {
    store,
    workerPool
  };
});
exports.assignStoreAndWorkerPool = assignStoreAndWorkerPool;

const setQueryRunningFinished = async () => {
  _actions.boundActionCreators.setProgramStatus(_types.ProgramStatus.BOOTSTRAP_QUERY_RUNNING_FINISHED);
};

const markQueryFilesDirty = (0, _xstate.assign)({
  queryFilesDirty: true
});
exports.markQueryFilesDirty = markQueryFilesDirty;
const markSourceFilesDirty = (0, _xstate.assign)({
  sourceFilesDirty: true
});
exports.markSourceFilesDirty = markSourceFilesDirty;
const markSourceFilesClean = (0, _xstate.assign)({
  sourceFilesDirty: false
});
exports.markSourceFilesClean = markSourceFilesClean;
const assignServiceResult = (0, _xstate.assign)((_context, {
  data
}) => data);
/**
 * This spawns the service that listens to the `emitter` for various mutation events
 */

exports.assignServiceResult = assignServiceResult;
const spawnMutationListener = (0, _xstate.assign)({
  mutationListener: () => (0, _xstate.spawn)(_listenForMutations.listenForMutations, `listen-for-mutations`)
});
exports.spawnMutationListener = spawnMutationListener;
const assignServers = (0, _xstate.assign)((_context, {
  data
}) => {
  return { ...data
  };
});
exports.assignServers = assignServers;
const spawnWebpackListener = (0, _xstate.assign)({
  webpackListener: ({
    compiler
  }) => {
    if (!compiler) {
      return undefined;
    }

    return (0, _xstate.spawn)((0, _listenToWebpack.createWebpackWatcher)(compiler));
  }
});
exports.spawnWebpackListener = spawnWebpackListener;
const assignWebhookBody = (0, _xstate.assign)({
  webhookBody: (_context, {
    payload
  }) => payload === null || payload === void 0 ? void 0 : payload.webhookBody
});
exports.assignWebhookBody = assignWebhookBody;
const clearWebhookBody = (0, _xstate.assign)({
  webhookBody: undefined
});
exports.clearWebhookBody = clearWebhookBody;

const finishParentSpan = ({
  parentSpan
}) => parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.finish();

exports.finishParentSpan = finishParentSpan;

const saveDbState = () => (0, _db.saveState)();

exports.saveDbState = saveDbState;

const logError = (_context, event) => {
  _reporter.default.error(event.data);
};

exports.logError = logError;

const panic = (_context, event) => {
  _reporter.default.panic(event.data);
};
/**
 * Event handler used in all states where we're not ready to process a file change
 * Instead we add it to a batch to process when we're next idle
 */
// export const markFilesDirty: BuildMachineAction = assign<IBuildContext>({
//   filesDirty: true,
// })


exports.panic = panic;
const markNodesDirty = (0, _xstate.assign)({
  nodesMutatedDuringQueryRun: true
});
exports.markNodesDirty = markNodesDirty;
const buildActions = {
  callApi,
  markNodesDirty,
  addNodeMutation,
  spawnMutationListener,
  assignStoreAndWorkerPool,
  assignServiceResult,
  assignServers,
  markQueryFilesDirty,
  assignWebhookBody,
  clearWebhookBody,
  finishParentSpan,
  spawnWebpackListener,
  markSourceFilesDirty,
  markSourceFilesClean,
  saveDbState,
  setQueryRunningFinished,
  panic,
  logError
};
exports.buildActions = buildActions;
//# sourceMappingURL=actions.js.map