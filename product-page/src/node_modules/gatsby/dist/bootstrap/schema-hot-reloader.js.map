{"version":3,"sources":["../../src/bootstrap/schema-hot-reloader.ts"],"names":["inferredTypesChanged","typeMap","prevTypeMap","Object","keys","some","type","dirty","lastMetadata","maybeRebuildSchema","inferenceMetadata","store","getState","activity","report","activityTimer","start","parentSpan","end","snapshotInferenceMetadata","bootstrapSchemaHotReloader","emitter","on","startSchemaHotReloader","stopSchemaHotReloader","off","cancel"],"mappings":";;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAMA,MAAMA,oBAAoB,GAAG,CAC3BC,OAD2B,EAE3BC,WAF2B,KAI3BC,MAAM,CAACC,IAAP,CAAYH,OAAZ,EAAqBI,IAArB,CACEC,IAAI,IACFL,OAAO,CAACK,IAAD,CAAP,CAAcC,KAAd,IAAuB,CAAC,wCAAgBN,OAAO,CAACK,IAAD,CAAvB,EAA+BJ,WAAW,CAACI,IAAD,CAA1C,CAF5B,CAJF;;AASA,IAAIE,YAAJ,C,CAEA;AACA;;AACA,MAAMC,kBAAkB,GAAG,sBAAS,YAA2B;AAC7D,QAAM;AAAEC,IAAAA;AAAF,MAAwBC,aAAMC,QAAN,EAA9B;;AAEA,MAAI,CAACZ,oBAAoB,CAACU,iBAAiB,CAACT,OAAnB,EAA4BO,YAAY,CAACP,OAAzC,CAAzB,EAA4E;AAC1E;AACD;;AAED,QAAMY,QAAQ,GAAGC,kBAAOC,aAAP,CAAsB,gBAAtB,CAAjB;;AACAF,EAAAA,QAAQ,CAACG,KAAT;AACA,QAAM,qBAAQ;AAAEC,IAAAA,UAAU,EAAEJ;AAAd,GAAR,CAAN;AACA,QAAM,4CAAyB,KAAzB,EAAgC;AAAEI,IAAAA,UAAU,EAAEJ;AAAd,GAAhC,CAAN;AACAA,EAAAA,QAAQ,CAACK,GAAT;AACD,CAZ0B,EAYxB,IAZwB,CAA3B;;AAcA,SAASC,yBAAT,GAA2C;AACzC,QAAM;AAAET,IAAAA;AAAF,MAAwBC,aAAMC,QAAN,EAA9B;;AACAJ,EAAAA,YAAY,GAAG,uBAAUE,iBAAV,CAAf;AACD;;AAEM,SAASU,0BAAT,GAA4C;AACjD;AACA;AACA;AACAD,EAAAA,yBAAyB;;AACzBE,iBAAQC,EAAR,CAAY,YAAZ,EAAyBH,yBAAzB;;AAEAI,EAAAA,sBAAsB;AACvB;;AAEM,SAASA,sBAAT,GAAwC;AAC7C;AACA;AACAF,iBAAQC,EAAR,CAAY,yBAAZ,EAAsCb,kBAAtC;AACD;;AAEM,SAASe,qBAAT,GAAuC;AAC5CH,iBAAQI,GAAR,CAAa,yBAAb,EAAuChB,kBAAvC;;AACAA,EAAAA,kBAAkB,CAACiB,MAAnB;AACD","sourcesContent":["import { debounce, cloneDeep } from \"lodash\"\nimport { emitter, store } from \"../redux\"\nimport { rebuild } from \"../schema\"\nimport { haveEqualFields } from \"../schema/infer/inference-metadata\"\nimport { updateStateAndRunQueries } from \"../query/query-watcher\"\nimport report from \"gatsby-cli/lib/reporter\"\nimport { IGatsbyState } from \"../redux/types\"\n\ntype TypeMap = IGatsbyState[\"inferenceMetadata\"][\"typeMap\"]\ntype InferenceMetadata = IGatsbyState[\"inferenceMetadata\"]\n\nconst inferredTypesChanged = (\n  typeMap: TypeMap,\n  prevTypeMap: TypeMap\n): boolean =>\n  Object.keys(typeMap).some(\n    type =>\n      typeMap[type].dirty && !haveEqualFields(typeMap[type], prevTypeMap[type])\n  )\n\nlet lastMetadata: InferenceMetadata\n\n// API_RUNNING_QUEUE_EMPTY could be emitted multiple types\n// in a short period of time, so debounce seems reasonable\nconst maybeRebuildSchema = debounce(async (): Promise<void> => {\n  const { inferenceMetadata } = store.getState()\n\n  if (!inferredTypesChanged(inferenceMetadata.typeMap, lastMetadata.typeMap)) {\n    return\n  }\n\n  const activity = report.activityTimer(`rebuild schema`)\n  activity.start()\n  await rebuild({ parentSpan: activity })\n  await updateStateAndRunQueries(false, { parentSpan: activity })\n  activity.end()\n}, 1000)\n\nfunction snapshotInferenceMetadata(): void {\n  const { inferenceMetadata } = store.getState()\n  lastMetadata = cloneDeep(inferenceMetadata)\n}\n\nexport function bootstrapSchemaHotReloader(): void {\n  // Snapshot inference metadata at the time of the last schema rebuild\n  // (even if schema was rebuilt elsewhere)\n  // Using the snapshot later to check if inferred types actually changed since the last rebuild\n  snapshotInferenceMetadata()\n  emitter.on(`SET_SCHEMA`, snapshotInferenceMetadata)\n\n  startSchemaHotReloader()\n}\n\nexport function startSchemaHotReloader(): void {\n  // Listen for node changes outside of a regular sourceNodes API call,\n  // e.g. markdown file update via watcher\n  emitter.on(`API_RUNNING_QUEUE_EMPTY`, maybeRebuildSchema)\n}\n\nexport function stopSchemaHotReloader(): void {\n  emitter.off(`API_RUNNING_QUEUE_EMPTY`, maybeRebuildSchema)\n  maybeRebuildSchema.cancel()\n}\n"],"file":"schema-hot-reloader.js"}