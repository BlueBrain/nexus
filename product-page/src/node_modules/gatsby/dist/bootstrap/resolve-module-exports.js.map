{"version":3,"sources":["../../src/bootstrap/resolve-module-exports.ts"],"names":["staticallyAnalyzeExports","modulePath","resolver","require","resolve","absPath","exportNames","err","code","fs","readFileSync","ast","SyntaxError","codeFrame","start","loc","highlightCode","report","panic","message","isCommonJS","isES6","ImportDeclaration","ExportNamedDeclaration","astPath","declaration","node","type","declarations","id","push","name","ExportSpecifier","exportName","exported","ExportDefaultDeclaration","t","isIdentifier","isArrowFunctionExpression","isFunctionDeclaration","AssignmentExpression","nodeLeft","left","isMemberExpression","property","object","exp","process","env","NODE_ENV","resolveModuleExports","mode","Object","keys","filter","e"],"mappings":"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","sourcesContent":["import fs from \"fs\"\nimport * as t from \"@babel/types\"\nimport traverse from \"@babel/traverse\"\nimport { codeFrameColumns, SourceLocation } from \"@babel/code-frame\"\nimport { babelParseToAst } from \"../utils/babel-parse-to-ast\"\nimport report from \"gatsby-cli/lib/reporter\"\n\nimport { testRequireError } from \"../utils/test-require-error\"\n\nconst staticallyAnalyzeExports = (\n  modulePath: string,\n  resolver = require.resolve\n): string[] => {\n  let absPath: string | undefined\n  const exportNames: string[] = []\n\n  try {\n    absPath = resolver(modulePath)\n  } catch (err) {\n    return exportNames // doesn't exist\n  }\n  const code = fs.readFileSync(absPath, `utf8`) // get file contents\n\n  let ast\n  try {\n    ast = babelParseToAst(code, absPath)\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      // Pretty print syntax errors\n      const codeFrame = codeFrameColumns(\n        code,\n        {\n          start: ((err as unknown) as { loc: SourceLocation[\"start\"] }).loc,\n        },\n        {\n          highlightCode: true,\n        }\n      )\n\n      report.panic(\n        `Syntax error in \"${absPath}\":\\n${err.message}\\n${codeFrame}`\n      )\n    } else {\n      // if it's not syntax error, just throw it\n      throw err\n    }\n  }\n\n  let isCommonJS = false\n  let isES6 = false\n\n  // extract names of exports from file\n  traverse(ast, {\n    // Check if the file is using ES6 imports\n    ImportDeclaration: function ImportDeclaration() {\n      isES6 = true\n    },\n\n    ExportNamedDeclaration: function ExportNamedDeclaration(astPath) {\n      const declaration = astPath.node.declaration\n\n      // get foo from `export const foo = bar`\n      if (\n        declaration?.type === `VariableDeclaration` &&\n        declaration.declarations[0]?.id.type === `Identifier`\n      ) {\n        isES6 = true\n        exportNames.push(declaration.declarations[0].id.name)\n      }\n\n      // get foo from `export function foo()`\n      if (\n        declaration?.type === `FunctionDeclaration` &&\n        declaration.id?.type === `Identifier`\n      ) {\n        isES6 = true\n        exportNames.push(declaration.id.name)\n      }\n    },\n\n    // get foo from `export { foo } from 'bar'`\n    // get foo from `export { foo }`\n    ExportSpecifier: function ExportSpecifier(astPath) {\n      const exportName = astPath?.node?.exported?.name\n      isES6 = true\n      if (exportName) {\n        exportNames.push(exportName)\n      }\n    },\n\n    // export default () => {}\n    // export default function() {}\n    // export default function foo() {}\n    // const foo = () => {}; export default foo\n    ExportDefaultDeclaration: function ExportDefaultDeclaration(astPath) {\n      const declaration = astPath.node.declaration\n      if (\n        !t.isIdentifier(declaration) &&\n        !t.isArrowFunctionExpression(declaration) &&\n        !t.isFunctionDeclaration(declaration)\n      ) {\n        return\n      }\n\n      let name = ``\n      if (t.isIdentifier(declaration)) {\n        name = declaration.name\n      } else if (t.isFunctionDeclaration(declaration) && declaration.id) {\n        name = declaration.id.name\n      }\n\n      const exportName = `export default${name ? ` ${name}` : ``}`\n      isES6 = true\n      exportNames.push(exportName)\n    },\n\n    AssignmentExpression: function AssignmentExpression(astPath) {\n      const nodeLeft = astPath.node.left\n\n      if (!t.isMemberExpression(nodeLeft)) {\n        return\n      }\n\n      // ignore marker property `__esModule`\n      if (\n        t.isIdentifier(nodeLeft.property) &&\n        nodeLeft.property.name === `__esModule`\n      ) {\n        return\n      }\n\n      // get foo from `exports.foo = bar`\n      if (\n        t.isIdentifier(nodeLeft.object) &&\n        nodeLeft.object.name === `exports`\n      ) {\n        isCommonJS = true\n        exportNames.push((nodeLeft.property as t.Identifier).name)\n      }\n\n      // get foo from `module.exports.foo = bar`\n      if (t.isMemberExpression(nodeLeft.object)) {\n        const exp: t.MemberExpression = nodeLeft.object\n\n        if (\n          t.isIdentifier(exp.object) &&\n          t.isIdentifier(exp.property) &&\n          exp.object.name === `module` &&\n          exp.property.name === `exports`\n        ) {\n          isCommonJS = true\n          exportNames.push((nodeLeft.property as t.Identifier).name)\n        }\n      }\n    },\n  })\n\n  if (isES6 && isCommonJS && process.env.NODE_ENV !== `test`) {\n    report.panic(\n      `This plugin file is using both CommonJS and ES6 module systems together which we don't support.\nYou'll need to edit the file to use just one or the other.\n\nplugin: ${modulePath}.js\n\nThis didn't cause a problem in Gatsby v1 so you might want to review the migration doc for this:\nhttps://gatsby.dev/no-mixed-modules\n      `\n    )\n  }\n  return exportNames\n}\n\n/**\n * Given a `require.resolve()` compatible path pointing to a JS module,\n * return an array listing the names of the module's exports.\n *\n * Returns [] for invalid paths and modules without exports.\n *\n * @param modulePath\n * @param mode\n * @param resolver\n */\nexport const resolveModuleExports = (\n  modulePath: string,\n  { mode = `analysis`, resolver = require.resolve } = {}\n): string[] => {\n  if (mode === `require`) {\n    let absPath: string | undefined\n    try {\n      absPath = resolver(modulePath)\n      return Object.keys(require(modulePath)).filter(\n        exportName => exportName !== `__esModule`\n      )\n    } catch (e) {\n      if (!testRequireError(modulePath, e)) {\n        // if module exists, but requiring it cause errors,\n        // show the error to the user and terminate build\n        report.panic(`Error in \"${absPath}\":`, e)\n      }\n    }\n  } else {\n    return staticallyAnalyzeExports(modulePath, resolver)\n  }\n\n  return []\n}\n"],"file":"resolve-module-exports.js"}