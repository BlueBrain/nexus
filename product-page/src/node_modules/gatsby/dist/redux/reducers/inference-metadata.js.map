{"version":3,"sources":["../../../src/redux/reducers/inference-metadata.ts"],"names":["ignoredFields","Set","NodeInterfaceFields","initialTypeMetadata","incrementalReducer","state","action","type","typeDefs","Array","isArray","payload","ignoredTypes","reduce","typesWithoutInference","forEach","nodes","typeName","ignored","types","node","oldNode","internal","addedField","previousFields","fields","dirty","fullNodes","Object","keys","StepsEnum","initialState","step","initialBuild","typeMap","inferenceMetadataReducer","incrementalBuild"],"mappings":"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","sourcesContent":["// Tracking structure of nodes to utilize this metadata for schema inference\n// Type descriptors stay relevant at any point in time making incremental inference trivial\nimport { omit } from \"lodash\"\nimport {\n  addNode,\n  addNodes,\n  deleteNode,\n  ignore,\n  disable,\n} from \"../../schema/infer/inference-metadata\"\nimport { NodeInterfaceFields } from \"../../schema/types/node-interface\"\nimport { typesWithoutInference } from \"../../schema/types/type-defs\"\n\nimport { IGatsbyState, ActionsUnion } from \"../types\"\n\nconst ignoredFields: Set<string> = new Set([\n  ...NodeInterfaceFields,\n  `__gatsby_resolved`,\n])\n\nconst initialTypeMetadata = (): { ignoredFields: Set<string> } => {\n  return { ignoredFields }\n}\n\nconst incrementalReducer = (\n  state: IGatsbyState[\"inferenceMetadata\"][\"typeMap\"] = {},\n  action: ActionsUnion\n): IGatsbyState[\"inferenceMetadata\"][\"typeMap\"] => {\n  switch (action.type) {\n    case `CREATE_TYPES`: {\n      const typeDefs = Array.isArray(action.payload)\n        ? action.payload\n        : [action.payload]\n      const ignoredTypes = typeDefs.reduce(typesWithoutInference, [])\n      ignoredTypes.forEach(type => {\n        state[type] = ignore(state[type] || initialTypeMetadata())\n      })\n      return state\n    }\n\n    case `BUILD_TYPE_METADATA`: {\n      // Overwrites existing metadata\n      const { nodes, typeName } = action.payload\n      if (!state[typeName]?.ignored) {\n        state[typeName] = addNodes(initialTypeMetadata(), nodes)\n      }\n      return state\n    }\n\n    case `DISABLE_TYPE_INFERENCE`: {\n      // Note: types disabled here will be re-enabled after BUILD_TYPE_METADATA\n      const types = action.payload\n      types.forEach(type => {\n        state[type] = disable(state[type] || initialTypeMetadata())\n      })\n      return state\n    }\n\n    case `CREATE_NODE`: {\n      const { payload: node, oldNode } = action\n      const { type } = node.internal\n      if (oldNode) {\n        state[type] = deleteNode(state[type] || initialTypeMetadata(), oldNode)\n      }\n      state[type] = addNode(state[type] || initialTypeMetadata(), node)\n      return state\n    }\n\n    case `DELETE_NODE`: {\n      const node = action.payload\n      if (!node) return state\n      const { type } = node.internal\n      state[type] = deleteNode(state[type] || initialTypeMetadata(), node)\n      return state\n    }\n\n    case `ADD_FIELD_TO_NODE`: {\n      const { payload: node, addedField } = action\n      const { type } = node.internal\n\n      // Must unregister previous fields first.\n      // Can't simply add { fields: { [addedField]: node.fields[addedField] } }\n      // because it will count `fields` key twice for the same node\n      const previousFields = omit(node.fields, [addedField])\n      state[type] = deleteNode(state[type], { ...node, fields: previousFields })\n      state[type] = addNode(state[type], { ...node, fields: node.fields })\n\n      // TODO: there might be an edge case when the same field is \"added\" twice.\n      //   Then we'll count it twice in metadata. The only way to avoid it as I see it\n      //   is to pass original node before modifications along with a new node\n      //   in action payload and utilize original `node.fields` in deleteNode call above\n      return state\n    }\n\n    case `ADD_CHILD_NODE_TO_PARENT_NODE`: {\n      // Marking parent type as dirty so that it rebuilds\n      const { type } = action.payload.internal\n      state[type].dirty = true\n      return state\n    }\n\n    // Deprecated, will be removed in Gatsby v3.\n    case `DELETE_NODES`: {\n      const { fullNodes } = action\n      fullNodes.forEach(node => {\n        const { type } = node.internal\n        state[type] = deleteNode(state[type] || initialTypeMetadata(), node)\n      })\n      return state\n    }\n\n    case `SET_SCHEMA`: {\n      Object.keys(state).forEach(type => {\n        state[type].dirty = false\n      })\n      return state\n    }\n\n    default:\n      return state\n  }\n}\n\nenum StepsEnum {\n  initialBuild = `initialBuild`,\n  incrementalBuild = `incrementalBuild`,\n}\n\nconst initialState = (): IGatsbyState[\"inferenceMetadata\"] => {\n  return {\n    step: StepsEnum.initialBuild, // `initialBuild` | `incrementalBuild`\n    typeMap: {},\n  }\n}\n\nexport const inferenceMetadataReducer = (\n  state: IGatsbyState[\"inferenceMetadata\"] = initialState(),\n  action: ActionsUnion\n): IGatsbyState[\"inferenceMetadata\"] => {\n  switch (action.type) {\n    case `CREATE_NODE`:\n    case `DELETE_NODE`:\n    case `DELETE_NODES`:\n    case `ADD_CHILD_NODE_TO_PARENT_NODE`:\n    case `ADD_FIELD_TO_NODE`: {\n      // Perf: disable incremental inference until the first schema build.\n      // There are plugins which create and delete lots of nodes during bootstrap,\n      // which makes this reducer to do a lot of unnecessary work.\n      // Instead we defer the initial metadata creation until the first schema build\n      // and then enable incremental updates explicitly\n      if (state.step === StepsEnum.initialBuild) {\n        return state\n      }\n      state.typeMap = incrementalReducer(state.typeMap, action)\n      return state\n    }\n\n    case `START_INCREMENTAL_INFERENCE`: {\n      return {\n        ...state,\n        step: StepsEnum.incrementalBuild,\n      }\n    }\n\n    case `DELETE_CACHE`: {\n      return initialState()\n    }\n\n    default: {\n      state.typeMap = incrementalReducer(state.typeMap, action)\n      return state\n    }\n  }\n}\n"],"file":"inference-metadata.js"}