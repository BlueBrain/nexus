"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.buildHTML = void 0;

var _bluebird = _interopRequireDefault(require("bluebird"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _reporter = _interopRequireDefault(require("gatsby-cli/lib/reporter"));

var _errors = require("gatsby-cli/lib/reporter/errors");

var _gatsbyTelemetry = _interopRequireDefault(require("gatsby-telemetry"));

var _lodash = require("lodash");

var _webpack = _interopRequireDefault(require("webpack"));

var _webpack2 = _interopRequireDefault(require("../utils/webpack.config"));

var _webpackErrorUtils = require("../utils/webpack-error-utils");

// TODO
const runWebpack = compilerConfig => new _bluebird.default((resolve, reject) => {
  (0, _webpack.default)(compilerConfig).run((err, stats) => {
    if (err) {
      reject(err);
    } else {
      resolve(stats);
    }
  });
});

const doBuildRenderer = async ({
  directory
}, webpackConfig) => {
  const stats = await runWebpack(webpackConfig);

  if (stats.hasErrors()) {
    _reporter.default.panic((0, _webpackErrorUtils.structureWebpackErrors)(`build-html`, stats.compilation.errors));
  } // render-page.js is hard coded in webpack.config


  return `${directory}/public/render-page.js`;
};

const buildRenderer = async (program, stage, parentSpan) => {
  const {
    directory
  } = program;
  const config = await (0, _webpack2.default)(program, directory, stage, null, {
    parentSpan
  });
  return doBuildRenderer(program, config);
};

const deleteRenderer = async rendererPath => {
  try {
    await _fsExtra.default.remove(rendererPath);
    await _fsExtra.default.remove(`${rendererPath}.map`);
  } catch (e) {// This function will fail on Windows with no further consequences.
  }
};

const renderHTMLQueue = async (workerPool, activity, htmlComponentRendererPath, pages) => {
  // We need to only pass env vars that are set programmatically in gatsby-cli
  // to child process. Other vars will be picked up from environment.
  const envVars = [[`NODE_ENV`, process.env.NODE_ENV], [`gatsby_executing_command`, process.env.gatsby_executing_command], [`gatsby_log_level`, process.env.gatsby_log_level]]; // const start = process.hrtime()

  const segments = (0, _lodash.chunk)(pages, 50);
  await _bluebird.default.map(segments, async pageSegment => {
    await workerPool.renderHTML({
      envVars,
      htmlComponentRendererPath,
      paths: pageSegment
    });

    if (activity && activity.tick) {
      activity.tick(pageSegment.length);
    }
  });
};

class BuildHTMLError extends Error {
  constructor(error) {
    super(error.message); // We must use getOwnProperty because keys like `stack` are not enumerable,
    // but we want to copy over the entire error

    this.codeFrame = ``;
    Object.getOwnPropertyNames(error).forEach(key => {
      this[key] = error[key];
    });
  }

}

const doBuildPages = async (rendererPath, pagePaths, activity, workerPool) => {
  _gatsbyTelemetry.default.addSiteMeasurement(`BUILD_END`, {
    pagesCount: pagePaths.length
  });

  try {
    await renderHTMLQueue(workerPool, activity, rendererPath, pagePaths);
  } catch (error) {
    const prettyError = await (0, _errors.createErrorFromString)(error.stack, `${rendererPath}.map`);
    const buildError = new BuildHTMLError(prettyError);
    buildError.context = error.context;
    throw buildError;
  }
};

const buildHTML = async ({
  program,
  stage,
  pagePaths,
  activity,
  workerPool
}) => {
  const rendererPath = await buildRenderer(program, stage, activity.span);
  await doBuildPages(rendererPath, pagePaths, activity, workerPool);
  await deleteRenderer(rendererPath);
};

exports.buildHTML = buildHTML;
//# sourceMappingURL=build-html.js.map