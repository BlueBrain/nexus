{"version":3,"sources":["../../src/commands/build-utils.ts"],"names":["checkFolderIsEmpty","path","fs","existsSync","readdirSync","length","getChangedPageDataKeys","state","cachedPageData","pageData","pageKeys","forEach","newPageDataHash","key","has","push","previousPageDataHash","get","pages","keys","collectRemovedPageData","deletedPageKeys","_value","checkAndRemoveEmptyDir","publicDir","pagePath","pageHtmlDirectory","dirname","pageDataDirectory","join","removeSync","sortedPageKeysByNestedLevel","sort","a","b","currentPagePathValue","split","previousPagePathValue","removePageFiles","removePages","map","removePageDataList","Promise","all","then"],"mappings":";;;;;;;AAAA;;AACA;;AAEA;;AAIA;;AAGA,MAAMA,kBAAkB,GAAIC,IAAD,IACzBC,iBAAGC,UAAH,CAAcF,IAAd,KAAuB,CAACC,iBAAGE,WAAH,CAAeH,IAAf,EAAqBI,MAD/C;;AAGO,MAAMC,sBAAsB,GAAG,CACpCC,KADoC,EAEpCC,cAFoC,KAGvB;AACb,MAAIA,cAAc,IAAID,KAAK,CAACE,QAA5B,EAAsC;AACpC,UAAMC,QAAkB,GAAG,EAA3B;AACAH,IAAAA,KAAK,CAACE,QAAN,CAAeE,OAAf,CAAuB,CAACC,eAAD,EAA0BC,GAA1B,KAA0C;AAC/D,UAAI,CAACL,cAAc,CAACM,GAAf,CAAmBD,GAAnB,CAAL,EAA8B;AAC5BH,QAAAA,QAAQ,CAACK,IAAT,CAAcF,GAAd;AACD,OAFD,MAEO;AACL,cAAMG,oBAAoB,GAAGR,cAAc,CAACS,GAAf,CAAmBJ,GAAnB,CAA7B;;AACA,YAAID,eAAe,KAAKI,oBAAxB,EAA8C;AAC5CN,UAAAA,QAAQ,CAACK,IAAT,CAAcF,GAAd;AACD;AACF;AACF,KATD;AAUA,WAAOH,QAAP;AACD;;AAED,SAAO,CAAC,GAAGH,KAAK,CAACW,KAAN,CAAYC,IAAZ,EAAJ,CAAP;AACD,CApBM;;;;AAsBA,MAAMC,sBAAsB,GAAG,CACpCb,KADoC,EAEpCC,cAFoC,KAGvB;AACb,MAAIA,cAAc,IAAID,KAAK,CAACE,QAA5B,EAAsC;AACpC,UAAMY,eAAyB,GAAG,EAAlC;AACAb,IAAAA,cAAc,CAACG,OAAf,CAAuB,CAACW,MAAD,EAAiBT,GAAjB,KAAiC;AACtD,UAAI,CAACN,KAAK,CAACE,QAAN,CAAeK,GAAf,CAAmBD,GAAnB,CAAL,EAA8B;AAC5BQ,QAAAA,eAAe,CAACN,IAAhB,CAAqBF,GAArB;AACD;AACF,KAJD;AAKA,WAAOQ,eAAP;AACD;;AACD,SAAO,EAAP;AACD,CAdM;;;;AAgBP,MAAME,sBAAsB,GAAG,CAACC,SAAD,EAAoBC,QAApB,KAA+C;AAC5E,QAAMC,iBAAiB,GAAGzB,cAAK0B,OAAL,CACxB,mCAAoBH,SAApB,EAA+BC,QAA/B,CADwB,CAA1B;;AAGA,QAAMG,iBAAiB,GAAG3B,cAAK4B,IAAL,CACxBL,SADwB,EAEvB,WAFuB,EAGxB,6BAAcC,QAAd,CAHwB,CAA1B,CAJ4E,CAS5E;;;AACA,MAAIzB,kBAAkB,CAAC0B,iBAAD,CAAtB,EAA2C;AACzCxB,qBAAG4B,UAAH,CAAcJ,iBAAd;AACD;;AACD,MAAI1B,kBAAkB,CAAC4B,iBAAD,CAAtB,EAA2C;AACzC1B,qBAAG4B,UAAH,CAAcF,iBAAd;AACD;AACF,CAhBD;;AAkBA,MAAMG,2BAA2B,GAAIrB,QAAD,IAClCA,QAAQ,CAACsB,IAAT,CAAc,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACtB,QAAMC,oBAAoB,GAAGF,CAAC,CAACG,KAAF,CAAS,GAAT,EAAa/B,MAA1C;AACA,QAAMgC,qBAAqB,GAAGH,CAAC,CAACE,KAAF,CAAS,GAAT,EAAa/B,MAA3C;AACA,SAAOgC,qBAAqB,GAAGF,oBAA/B;AACD,CAJD,CADF;;AAOO,MAAMG,eAAe,GAAG,OAC7Bd,SAD6B,EAE7Bd,QAF6B,KAGX;AAClB,QAAM6B,WAAW,GAAG7B,QAAQ,CAAC8B,GAAT,CAAaf,QAAQ,IACvC,sBAAmB;AAAED,IAAAA;AAAF,GAAnB,EAAkCC,QAAlC,CADkB,CAApB;AAIA,QAAMgB,kBAAkB,GAAG/B,QAAQ,CAAC8B,GAAT,CAAaf,QAAQ,IAC9C,8BAAeD,SAAf,EAA0BC,QAA1B,CADyB,CAA3B;AAIA,SAAOiB,OAAO,CAACC,GAAR,CAAY,CAAC,GAAGJ,WAAJ,EAAiB,GAAGE,kBAApB,CAAZ,EAAqDG,IAArD,CAA0D,MAAM;AACrE;AACAb,IAAAA,2BAA2B,CAACrB,QAAD,CAA3B,CAAsCC,OAAtC,CAA8Cc,QAAQ,IAAI;AACxDF,MAAAA,sBAAsB,CAACC,SAAD,EAAYC,QAAZ,CAAtB;AACD,KAFD;AAGD,GALM,CAAP;AAMD,CAlBM","sourcesContent":["import fs from \"fs-extra\"\nimport path from \"path\"\n\nimport {\n  remove as removePageHtmlFile,\n  getPageHtmlFilePath,\n} from \"../utils/page-html\"\nimport { removePageData, fixedPagePath } from \"../utils/page-data\"\nimport { IGatsbyState } from \"../redux/types\"\n\nconst checkFolderIsEmpty = (path: string): boolean =>\n  fs.existsSync(path) && !fs.readdirSync(path).length\n\nexport const getChangedPageDataKeys = (\n  state: IGatsbyState,\n  cachedPageData: Map<string, string>\n): string[] => {\n  if (cachedPageData && state.pageData) {\n    const pageKeys: string[] = []\n    state.pageData.forEach((newPageDataHash: string, key: string) => {\n      if (!cachedPageData.has(key)) {\n        pageKeys.push(key)\n      } else {\n        const previousPageDataHash = cachedPageData.get(key)\n        if (newPageDataHash !== previousPageDataHash) {\n          pageKeys.push(key)\n        }\n      }\n    })\n    return pageKeys\n  }\n\n  return [...state.pages.keys()]\n}\n\nexport const collectRemovedPageData = (\n  state: IGatsbyState,\n  cachedPageData: Map<string, string>\n): string[] => {\n  if (cachedPageData && state.pageData) {\n    const deletedPageKeys: string[] = []\n    cachedPageData.forEach((_value: string, key: string) => {\n      if (!state.pageData.has(key)) {\n        deletedPageKeys.push(key)\n      }\n    })\n    return deletedPageKeys\n  }\n  return []\n}\n\nconst checkAndRemoveEmptyDir = (publicDir: string, pagePath: string): void => {\n  const pageHtmlDirectory = path.dirname(\n    getPageHtmlFilePath(publicDir, pagePath)\n  )\n  const pageDataDirectory = path.join(\n    publicDir,\n    `page-data`,\n    fixedPagePath(pagePath)\n  )\n  // if page's folder is empty also remove matching page-data folder\n  if (checkFolderIsEmpty(pageHtmlDirectory)) {\n    fs.removeSync(pageHtmlDirectory)\n  }\n  if (checkFolderIsEmpty(pageDataDirectory)) {\n    fs.removeSync(pageDataDirectory)\n  }\n}\n\nconst sortedPageKeysByNestedLevel = (pageKeys: string[]): string[] =>\n  pageKeys.sort((a, b) => {\n    const currentPagePathValue = a.split(`/`).length\n    const previousPagePathValue = b.split(`/`).length\n    return previousPagePathValue - currentPagePathValue\n  })\n\nexport const removePageFiles = async (\n  publicDir: string,\n  pageKeys: string[]\n): Promise<void> => {\n  const removePages = pageKeys.map(pagePath =>\n    removePageHtmlFile({ publicDir }, pagePath)\n  )\n\n  const removePageDataList = pageKeys.map(pagePath =>\n    removePageData(publicDir, pagePath)\n  )\n\n  return Promise.all([...removePages, ...removePageDataList]).then(() => {\n    // Sort removed pageKeys by nested directories and remove if empty.\n    sortedPageKeysByNestedLevel(pageKeys).forEach(pagePath => {\n      checkAndRemoveEmptyDir(publicDir, pagePath)\n    })\n  })\n}\n"],"file":"build-utils.js"}