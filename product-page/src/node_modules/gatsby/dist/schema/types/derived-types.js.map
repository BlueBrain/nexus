{"version":3,"sources":["../../../src/schema/types/derived-types.ts"],"names":["getDerivedTypes","typeComposer","getExtension","Set","clearDerivedTypes","schemaComposer","derivedTypes","typeName","values","derivedTypeComposer","getAnyTC","delete","ObjectTypeComposer","InterfaceTypeComposer","removeInputTypeComposer","setExtension","addDerivedType","derivedTypeName","add"],"mappings":";;;;;AA+BA;;AA/BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiDA,MAAMA,eAAe,GAAG,CAAC;AACvBC,EAAAA;AADuB,CAAD,KAILA,YAAY,CAACC,YAAb,CAA2B,cAA3B,KAA6C,IAAIC,GAAJ,EAJhE;;AAMO,MAAMC,iBAAiB,GAAG,CAAC;AAChCC,EAAAA,cADgC;AAEhCJ,EAAAA;AAFgC,CAAD,KAMrB;AACV,QAAMK,YAAY,GAAGN,eAAe,CAAC;AAAEC,IAAAA;AAAF,GAAD,CAApC;;AAEA,OAAK,MAAMM,QAAX,IAAuBD,YAAY,CAACE,MAAb,EAAvB,EAA8C;AAC5C,UAAMC,mBAAmB,GAAGJ,cAAc,CAACK,QAAf,CAAwBH,QAAxB,CAA5B;AACAH,IAAAA,iBAAiB,CAAC;AAAEC,MAAAA,cAAF;AAAkBJ,MAAAA,YAAY,EAAEQ;AAAhC,KAAD,CAAjB;AACAJ,IAAAA,cAAc,CAACM,MAAf,CAAsBJ,QAAtB;AACD;;AAED,MACEN,YAAY,YAAYW,kCAAxB,IACAX,YAAY,YAAYY,qCAF1B,EAGE;AACAZ,IAAAA,YAAY,CAACa,uBAAb;AACD;;AAEDb,EAAAA,YAAY,CAACc,YAAb,CAA2B,cAA3B,EAA0C,IAAIZ,GAAJ,EAA1C;AACD,CAvBM;;;;AAyBA,MAAMa,cAAc,GAAG,CAAC;AAC7Bf,EAAAA,YAD6B;AAE7BgB,EAAAA;AAF6B,CAAD,KAMlB;AACV,QAAMX,YAAY,GAAGN,eAAe,CAAC;AAAEC,IAAAA;AAAF,GAAD,CAApC;AACAA,EAAAA,YAAY,CAACc,YAAb,CAA2B,cAA3B,EAA0CT,YAAY,CAACY,GAAb,CAAiBD,eAAjB,CAA1C;AACD,CATM","sourcesContent":["/**\n * Derived types are types that make sense only when their base type exists\n *\n * Take this node for example:\n * {\n *   internal: { type: 'Foo' },\n *   fields: {\n *     bar: \"string\",\n *   }\n * }\n *\n * It will produce following types:\n * Foo\n * FooFields\n *\n * FooInputFilter\n * FooSortInput\n *\n * FooFieldsInputFilter\n * FooFieldsSortFilter\n * etc\n *\n * Derived types:\n *   Foo: FooFields, FooInputFilter, FooSortInput\n *   FooFields: FooFieldsInputFilter, FooFieldsSortFilter\n *\n * Caveats:\n *   Only types created via inference are marked as derived. So if in the example above\n *   user explicitly defines `FooFields` type (via `createTypes` call) it won't be considered\n *   a derived type\n */\nimport {\n  ObjectTypeComposer,\n  InterfaceTypeComposer,\n  ScalarTypeComposer,\n  SchemaComposer,\n  InputTypeComposer,\n  EnumTypeComposer,\n  UnionTypeComposer,\n} from \"graphql-compose\"\n\ntype AllTypeComposer =\n  | ObjectTypeComposer\n  | InputTypeComposer\n  | EnumTypeComposer\n  | InterfaceTypeComposer\n  | UnionTypeComposer\n  | ScalarTypeComposer\n\nconst getDerivedTypes = ({\n  typeComposer,\n}: {\n  typeComposer: AllTypeComposer\n}): Set<string> => typeComposer.getExtension(`derivedTypes`) || new Set()\n\nexport const clearDerivedTypes = ({\n  schemaComposer,\n  typeComposer,\n}: {\n  schemaComposer: SchemaComposer<any>\n  typeComposer: AllTypeComposer\n}): void => {\n  const derivedTypes = getDerivedTypes({ typeComposer })\n\n  for (const typeName of derivedTypes.values()) {\n    const derivedTypeComposer = schemaComposer.getAnyTC(typeName)\n    clearDerivedTypes({ schemaComposer, typeComposer: derivedTypeComposer })\n    schemaComposer.delete(typeName)\n  }\n\n  if (\n    typeComposer instanceof ObjectTypeComposer ||\n    typeComposer instanceof InterfaceTypeComposer\n  ) {\n    typeComposer.removeInputTypeComposer()\n  }\n\n  typeComposer.setExtension(`derivedTypes`, new Set())\n}\n\nexport const addDerivedType = ({\n  typeComposer,\n  derivedTypeName,\n}: {\n  typeComposer: AllTypeComposer\n  derivedTypeName: string\n}): void => {\n  const derivedTypes = getDerivedTypes({ typeComposer })\n  typeComposer.setExtension(`derivedTypes`, derivedTypes.add(derivedTypeName))\n}\n"],"file":"derived-types.js"}