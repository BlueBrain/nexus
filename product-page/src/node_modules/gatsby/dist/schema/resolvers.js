"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.findMany = findMany;
exports.findOne = findOne;
exports.findManyPaginated = findManyPaginated;
exports.paginate = paginate;
exports.link = link;
exports.fileByPath = fileByPath;
exports.wrappingResolver = wrappingResolver;
exports.defaultResolver = exports.defaultFieldResolver = exports.group = exports.distinct = void 0;

var _path = _interopRequireDefault(require("path"));

var _normalizePath = _interopRequireDefault(require("normalize-path"));

var _lodash = _interopRequireDefault(require("lodash"));

var _graphql = require("graphql");

var _reporter = _interopRequireDefault(require("gatsby-cli/lib/reporter"));

var _utils = require("../query/utils");

var _getValueAt = require("../utils/get-value-at");

function findMany(typeName) {
  return function findManyResolver(_source, args, context, info) {
    if (context.stats) {
      context.stats.totalRunQuery++;
      context.stats.totalPluralRunQuery++;
    }

    return context.nodeModel.runQuery({
      query: args,
      firstOnly: false,
      type: info.schema.getType(typeName),
      stats: context.stats,
      tracer: context.tracer
    }, {
      path: context.path,
      connectionType: typeName
    });
  };
}

function findOne(typeName) {
  return function findOneResolver(_source, args, context, info) {
    if (context.stats) {
      context.stats.totalRunQuery++;
    }

    return context.nodeModel.runQuery({
      query: {
        filter: args
      },
      firstOnly: true,
      type: info.schema.getType(typeName),
      stats: context.stats,
      tracer: context.tracer
    }, {
      path: context.path
    });
  };
}

function findManyPaginated(typeName) {
  return async function findManyPaginatedResolver(source, args, context, info) {
    // Peek into selection set and pass on the `field` arg of `group` and
    // `distinct` which might need to be resolved.
    const group = getProjectedField(info, `group`);
    const distinct = getProjectedField(info, `distinct`);
    const extendedArgs = { ...args,
      group: group || [],
      distinct: distinct || []
    };
    const result = await findMany(typeName)(source, extendedArgs, context, info);
    return paginate(result, {
      skip: args.skip,
      limit: args.limit
    });
  };
}

const distinct = function distinctResolver(source, args) {
  const {
    field
  } = args;
  const {
    edges
  } = source;
  const values = edges.reduce((acc, {
    node
  }) => {
    const value = (0, _getValueAt.getValueAt)(node, `__gatsby_resolved.${field}`) || (0, _getValueAt.getValueAt)(node, field);
    return value != null ? acc.concat(value instanceof Date ? value.toISOString() : value) : acc;
  }, []);
  return Array.from(new Set(values)).sort();
};

exports.distinct = distinct;

const group = function groupResolver(source, args) {
  const {
    field
  } = args;
  const {
    edges
  } = source;
  const groupedResults = edges.reduce((acc, {
    node
  }) => {
    const value = (0, _getValueAt.getValueAt)(node, `__gatsby_resolved.${field}`) || (0, _getValueAt.getValueAt)(node, field);
    const values = Array.isArray(value) ? value : [value];
    values.filter(value => value != null).forEach(value => {
      const key = value instanceof Date ? value.toISOString() : value;
      acc[key] = (acc[key] || []).concat(node);
    });
    return acc; // Note: using Object.create on purpose:
    //   object key may be arbitrary string including reserved words (i.e. `constructor`)
    //   see: https://github.com/gatsbyjs/gatsby/issues/22508
  }, Object.create(null));
  return Object.keys(groupedResults).sort().reduce((acc, fieldValue) => {
    acc.push({ ...paginate(groupedResults[fieldValue], args),
      field,
      fieldValue
    });
    return acc;
  }, []);
};

exports.group = group;

function paginate(results = [], {
  skip = 0,
  limit
}) {
  if (results === null) {
    results = [];
  }

  const count = results.length;
  const items = results.slice(skip, limit && skip + limit);
  const pageCount = limit ? Math.ceil(skip / limit) + Math.ceil((count - skip) / limit) : skip ? 2 : 1;
  const currentPage = limit ? Math.ceil(skip / limit) + 1 : skip ? 2 : 1;
  const hasPreviousPage = currentPage > 1;
  const hasNextPage = skip + (limit || NaN) < count;
  return {
    totalCount: count,
    edges: items.map((item, i, arr) => {
      return {
        node: item,
        next: arr[i + 1],
        previous: arr[i - 1]
      };
    }),
    nodes: items,
    pageInfo: {
      currentPage,
      hasPreviousPage,
      hasNextPage,
      itemCount: items.length,
      pageCount,
      perPage: limit,
      totalCount: count
    }
  };
}

function link(options = {
  by: `id`
}, fieldConfig) {
  return async function linkResolver(source, args, context, info) {
    const resolver = fieldConfig.resolve || context.defaultFieldResolver;
    const fieldValue = await resolver(source, args, context, { ...info,
      from: options.from || info.from,
      fromNode: options.from ? options.fromNode : info.fromNode
    });
    if (fieldValue == null) return null;
    const returnType = (0, _graphql.getNullableType)(options.type || info.returnType);
    const type = (0, _graphql.getNamedType)(returnType);

    if (options.by === `id`) {
      if (Array.isArray(fieldValue)) {
        return context.nodeModel.getNodesByIds({
          ids: fieldValue,
          type: type
        }, {
          path: context.path
        });
      } else {
        return context.nodeModel.getNodeById({
          id: fieldValue,
          type: type
        }, {
          path: context.path
        });
      }
    }

    const equals = value => {
      return {
        eq: value
      };
    };

    const oneOf = value => {
      return {
        in: value
      };
    }; // Return early if fieldValue is [] since { in: [] } doesn't make sense


    if (Array.isArray(fieldValue) && fieldValue.length === 0) {
      return fieldValue;
    }

    const operator = Array.isArray(fieldValue) ? oneOf : equals;
    const runQueryArgs = args;
    runQueryArgs.filter = options.by.split(`.`).reduceRight((acc, key, i, {
      length
    }) => {
      return {
        [key]: i === length - 1 ? operator(acc) : acc
      };
    }, fieldValue);
    const firstOnly = !(returnType instanceof _graphql.GraphQLList);

    if (context.stats) {
      context.stats.totalRunQuery++;

      if (firstOnly) {
        context.stats.totalPluralRunQuery++;
      }
    }

    const result = await context.nodeModel.runQuery({
      query: runQueryArgs,
      firstOnly,
      type,
      stats: context.stats,
      tracer: context.tracer
    }, {
      path: context.path
    });

    if (returnType instanceof _graphql.GraphQLList && Array.isArray(fieldValue) && Array.isArray(result)) {
      return fieldValue.map(value => result.find(obj => (0, _getValueAt.getValueAt)(obj, options.by) === value));
    } else {
      return result;
    }
  };
}

function fileByPath(options = {}, fieldConfig) {
  return async function fileByPathResolver(source, args, context, info) {
    const resolver = fieldConfig.resolve || context.defaultFieldResolver;
    const fieldValue = await resolver(source, args, context, { ...info,
      from: options.from || info.from,
      fromNode: options.from ? options.fromNode : info.fromNode
    });
    if (fieldValue == null) return null; // Find the File node for this node (we assume the node is something
    // like markdown which would be a child node of a File node).

    const parentFileNode = context.nodeModel.findRootNodeAncestor(source, node => node.internal && node.internal.type === `File`);

    const findLinkedFileNode = relativePath => {
      // Use the parent File node to create the absolute path to
      // the linked file.
      const fileLinkPath = (0, _normalizePath.default)(_path.default.resolve(parentFileNode.dir, relativePath)); // Use that path to find the linked File node.

      const linkedFileNode = _lodash.default.find(context.nodeModel.getAllNodes({
        type: `File`
      }), n => n.absolutePath === fileLinkPath);

      return linkedFileNode;
    };

    return resolveValue(findLinkedFileNode, fieldValue);
  };
}

function resolveValue(resolve, value) {
  return Array.isArray(value) ? value.map(v => resolveValue(resolve, v)) : resolve(value);
}

function getProjectedField(info, fieldName) {
  const selectionSet = info.fieldNodes[0].selectionSet;

  if (selectionSet) {
    const fieldNodes = getFieldNodeByNameInSelectionSet(selectionSet, fieldName, info);
    const returnType = (0, _graphql.getNullableType)(info.returnType);

    if ((0, _graphql.isObjectType)(returnType) || (0, _graphql.isInterfaceType)(returnType)) {
      var _field$args;

      const field = returnType.getFields()[fieldName];
      const fieldArg = field === null || field === void 0 ? void 0 : (_field$args = field.args) === null || _field$args === void 0 ? void 0 : _field$args.find(arg => arg.name === `field`);

      if (fieldArg) {
        const fieldEnum = (0, _graphql.getNullableType)(fieldArg.type);

        if ((0, _graphql.isEnumType)(fieldEnum)) {
          return fieldNodes.reduce((acc, fieldNode) => {
            var _fieldNode$arguments;

            const fieldArg = (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.find(arg => arg.name.value === `field`);

            if ((fieldArg === null || fieldArg === void 0 ? void 0 : fieldArg.value.kind) === _graphql.Kind.ENUM) {
              const enumKey = fieldArg.value.value;
              const enumValue = fieldEnum.getValue(enumKey);

              if (enumValue) {
                return [...acc, enumValue.value];
              }
            }

            return acc;
          }, []);
        }
      }
    }
  }

  return [];
}

function getFieldNodeByNameInSelectionSet(selectionSet, fieldName, info) {
  return selectionSet.selections.reduce((acc, selection) => {
    if (selection.kind === _graphql.Kind.FRAGMENT_SPREAD) {
      const fragmentDef = info.fragments[selection.name.value];

      if (fragmentDef) {
        return [...acc, ...getFieldNodeByNameInSelectionSet(fragmentDef.selectionSet, fieldName, info)];
      }
    } else if (selection.kind === _graphql.Kind.INLINE_FRAGMENT) {
      return [...acc, ...getFieldNodeByNameInSelectionSet(selection.selectionSet, fieldName, info)];
    }
    /* FIELD_NODE */
    else {
        if (selection.name.value === fieldName) {
          return [...acc, selection];
        }
      }

    return acc;
  }, []);
}

const defaultFieldResolver = function defaultFieldResolver(source, args, context, info) {
  if (typeof source == `object` && source !== null || typeof source === `function`) {
    if (info.from) {
      if (info.fromNode) {
        const node = context.nodeModel.findRootNodeAncestor(source);
        if (!node) return null;
        return (0, _getValueAt.getValueAt)(node, info.from);
      }

      return (0, _getValueAt.getValueAt)(source, info.from);
    }

    const property = source[info.fieldName];

    if (typeof property === `function`) {
      return source[info.fieldName](args, context, info);
    }

    return property;
  }

  return null;
};

exports.defaultFieldResolver = defaultFieldResolver;
let WARNED_ABOUT_RESOLVERS = false;

function badResolverInvocationMessage(missingVar, path) {
  const resolverName = path ? `${(0, _utils.pathToArray)(path)} ` : ``;
  return `GraphQL Resolver ${resolverName}got called without "${missingVar}" argument. This might cause unexpected errors.
  
It's likely that this has happened in a schemaCustomization with manually invoked resolver. If manually invoking resolvers, it's best to invoke them as follows:

  resolve(parent, args, context, info)

`;
}

function wrappingResolver(resolver) {
  return async function wrappedTracingResolver(parent, args, context, info) {
    if (!WARNED_ABOUT_RESOLVERS) {
      if (!info) {
        _reporter.default.warn(badResolverInvocationMessage(`info`));

        WARNED_ABOUT_RESOLVERS = true;
      } else if (!context) {
        _reporter.default.warn(badResolverInvocationMessage(`context`, info.path));

        WARNED_ABOUT_RESOLVERS = true;
      }
    }

    let activity;

    if (context === null || context === void 0 ? void 0 : context.tracer) {
      activity = context.tracer.createResolverActivity(info.path, `${info.parentType.name}.${info.fieldName}`);
      activity.start();
    }

    try {
      return resolver(parent, args, context, info);
    } finally {
      if (activity) {
        activity.end();
      }
    }
  };
}

const defaultResolver = wrappingResolver(defaultFieldResolver);
exports.defaultResolver = defaultResolver;
//# sourceMappingURL=resolvers.js.map