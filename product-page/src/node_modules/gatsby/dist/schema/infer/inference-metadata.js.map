{"version":3,"sources":["../../../src/schema/infer/inference-metadata.ts"],"names":["getType","value","key","includes","Date","String","Array","isArray","length","Object","keys","updateValueDescriptorObject","typeInfo","nodeId","operation","metadata","path","push","dprops","forEach","v","descriptor","undefined","updateValueDescriptor","pop","updateValueDescriptorArray","item","updateValueDescriptorRelNodes","listOfNodeIds","delta","nodes","dirty","updateValueDescriptorString","empty","example","typeName","total","first","mergeObjectKeys","dpropsKeysA","dpropsKeysB","otherProps","Set","concat","descriptorsAreEqual","otherDescriptor","types","possibleTypes","otherTypes","childDescriptorsAreEqual","type","array","dpropsKeys","object","every","prop","nodeIds","relatedNode","id","Boolean","relatedNodeList","nodeFields","node","ignoredFields","filter","has","updateTypeMetadata","initialMetadata","disabled","ignored","fieldMap","field","ignore","set","disable","addNode","deleteNode","addNodes","reduce","isEmpty","hasNodes","typeMetadata","haveEqualFields","otherFieldMap","fields","state"],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-use-before-define */\n/*\n## Incrementally track the structure of nodes with metadata\n\nThis metadata can be later utilized for schema inference\n(via building `exampleValue` or directly)\n\n### Usage example:\n\n```javascript\n  const node1 = { id: '1', foo: 25, bar: 'str' }\n  const node2 = { id: '1', foo: 'conflict' }\n\n  let meta = { ignoredFields: new Set(['id']) }\n  meta = addNode(meta, node1)\n  meta = addNode(meta, node2)\n  console.log(meta.fieldMap)\n  // outputs: {\n  //   foo: {\n  //     int: { total: 1, example: 25 },\n  //     string: { total: 1, example: 'conflict' },\n  //   },\n  //   bar: {\n  //     string: { total: 1, example: 'str' },\n  //   },\n  // }\n\n  const example1 = getExampleObject({ meta, typeName, typeConflictReporter })\n  console.log(example1)\n  // outputs { bar: 'str' }\n  // and reports conflicts discovered\n\n  meta = deleteNode(meta, node2)\n  console.log(meta.fieldMap)\n  // outputs: {\n  //   foo: {\n  //     int: { total: 1, example: 25 },\n  //     string: { total: 0, example: 'conflict' },\n  //   },\n  //   bar: { string: { total: 1, example: 'str' } },\n  // }\n\n  const example2 = getExampleObject({ meta, typeName, typeConflictReporter })\n  // outputs: { foo: 25, bar: 'str' }\n```\n\n`addNode`, `deleteNode`, `getExampleObject` are O(N) where N is the number\nof fields in the node object (including nested fields)\n\n### Caveats\n\n* Conflict tracking for arrays is tricky, i.e.: { a: [5, \"foo\"] } and { a: [5] }, { a: [\"foo\"] }\n  are represented identically in metadata. To workaround it we additionally track first NodeId:\n  { a: { array: { item: { int: { total: 1, first: `1` }, string: { total: 1, first: `1` } }}\n  { a: { array: { item: { int: { total: 1, first: `1` }, string: { total: 1, first: `2` } }}\n  This way we can produce more useful conflict reports\n  (still rare edge cases possible when reporting may be confusing, i.e. when node is deleted)\n*/\n\nimport { isEqual } from \"lodash\"\nimport { is32BitInteger } from \"../../utils/is-32-bit-integer\"\nimport { looksLikeADate } from \"../types/date\"\nimport { Node } from \"../../../index\"\nimport { TypeConflictReporter } from \"./type-conflict-reporter\"\n\nexport interface ITypeInfo {\n  first?: string\n  total: number\n  example?: unknown\n}\n\nexport interface ITypeInfoString extends ITypeInfo {\n  empty: number\n  example: string\n}\n\nexport interface ITypeInfoDate extends ITypeInfo {\n  example: string\n}\n\nexport interface ITypeInfoNumber extends ITypeInfo {\n  example: number\n}\n\nexport interface ITypeInfoBoolean extends ITypeInfo {\n  example: boolean\n}\n\nexport interface ITypeInfoArray extends ITypeInfo {\n  item: IValueDescriptor\n}\n\nexport interface ITypeInfoRelatedNodes extends ITypeInfo {\n  nodes: { [key: string]: number }\n}\n\nexport interface ITypeInfoObject extends ITypeInfo {\n  dprops: {\n    [name: string]: IValueDescriptor\n  }\n}\n\nexport interface IValueDescriptor {\n  int?: ITypeInfoNumber\n  float?: ITypeInfoNumber\n  date?: ITypeInfoDate\n  string?: ITypeInfoString\n  boolean?: ITypeInfoBoolean\n  array?: ITypeInfoArray\n  relatedNode?: ITypeInfoRelatedNodes\n  relatedNodeList?: ITypeInfoRelatedNodes\n  object?: ITypeInfoObject\n}\n\nexport type ValueType = keyof IValueDescriptor\n\nexport interface ITypeMetadata {\n  typeName?: string\n  disabled?: boolean\n  ignored?: boolean\n  dirty?: boolean\n  total?: number\n  ignoredFields?: Set<string>\n  fieldMap?: Record<string, IValueDescriptor>\n  typeConflictReporter?: TypeConflictReporter\n  [key: string]: unknown\n}\n\ntype Operation = \"add\" | \"del\"\n\nconst getType = (value: unknown, key: string): ValueType | \"null\" => {\n  // Staying as close as possible to GraphQL types\n  switch (typeof value) {\n    case `number`:\n      return is32BitInteger(value) ? `int` : `float`\n    case `string`:\n      if (key.includes(`___NODE`)) {\n        return `relatedNode`\n      }\n      return looksLikeADate(value) ? `date` : `string`\n    case `boolean`:\n      return `boolean`\n    case `object`:\n      if (value === null) return `null`\n      if (value instanceof Date) return `date`\n      if (value instanceof String) return `string`\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return `null`\n        }\n        return key.includes(`___NODE`) ? `relatedNodeList` : `array`\n      }\n      if (!Object.keys(value).length) return `null`\n      return `object`\n    default:\n      // bigint, symbol, function, unknown (host objects in IE were typeof \"unknown\", for example)\n      return `null`\n  }\n}\n\nconst updateValueDescriptorObject = (\n  value: object,\n  typeInfo: ITypeInfoObject,\n  nodeId: string,\n  operation: Operation,\n  metadata: ITypeMetadata,\n  path: object[]\n): void => {\n  path.push(value)\n\n  const { dprops = {} } = typeInfo\n  typeInfo.dprops = dprops\n\n  Object.keys(value).forEach(key => {\n    const v = value[key]\n\n    let descriptor = dprops[key]\n    if (descriptor === undefined) {\n      descriptor = {}\n      dprops[key] = descriptor\n    }\n\n    updateValueDescriptor(nodeId, key, v, operation, descriptor, metadata, path)\n  })\n\n  path.pop()\n}\n\nconst updateValueDescriptorArray = (\n  value: unknown[],\n  key: string,\n  typeInfo: ITypeInfoArray,\n  nodeId: string,\n  operation: Operation,\n  metadata: ITypeMetadata,\n  path: object[]\n): void => {\n  value.forEach(item => {\n    let descriptor = typeInfo.item\n    if (descriptor === undefined) {\n      descriptor = {}\n      typeInfo.item = descriptor\n    }\n\n    updateValueDescriptor(\n      nodeId,\n      key,\n      item,\n      operation,\n      descriptor,\n      metadata,\n      path\n    )\n  })\n}\n\nconst updateValueDescriptorRelNodes = (\n  listOfNodeIds: string[],\n  delta: number,\n  operation: Operation,\n  typeInfo: ITypeInfoRelatedNodes,\n  metadata: ITypeMetadata\n): void => {\n  const { nodes = {} } = typeInfo\n  typeInfo.nodes = nodes\n\n  listOfNodeIds.forEach(nodeId => {\n    nodes[nodeId] = (nodes[nodeId] || 0) + delta\n\n    // Treat any new related node addition or removal as a structural change\n    // FIXME: this will produce false positives as this node can be\n    //  of the same type as another node already in the map (but we don't know it here)\n    if (nodes[nodeId] === 0 || (operation === `add` && nodes[nodeId] === 1)) {\n      metadata.dirty = true\n    }\n  })\n}\n\nconst updateValueDescriptorString = (\n  value: string,\n  delta: number,\n  typeInfo: ITypeInfoString\n): void => {\n  if (value === ``) {\n    const { empty = 0 } = typeInfo\n    typeInfo.empty = empty + delta\n  }\n  typeInfo.example =\n    typeof typeInfo.example !== `undefined` ? typeInfo.example : value\n}\n\nconst updateValueDescriptor = (\n  nodeId: string,\n  key: string,\n  value: unknown,\n  operation: Operation = `add`,\n  descriptor: IValueDescriptor,\n  metadata: ITypeMetadata,\n  path: object[]\n): void => {\n  // The object may be traversed multiple times from root.\n  // Each time it does it should not revisit the same node twice\n  if (path.includes(value as object)) {\n    return\n  }\n\n  const typeName = getType(value, key)\n\n  if (typeName === `null`) {\n    return\n  }\n\n  const delta = operation === `del` ? -1 : 1\n\n  let typeInfo: ITypeInfo | undefined = descriptor[typeName]\n  if (typeInfo === undefined) {\n    typeInfo = (descriptor[typeName] as ITypeInfo) = { total: 0 }\n  }\n  typeInfo.total += delta\n\n  // Keeping track of structural changes\n  // (when value of a new type is added or an existing type has no more values assigned)\n  if (typeInfo.total === 0 || (operation === `add` && typeInfo.total === 1)) {\n    metadata.dirty = true\n  }\n\n  // Keeping track of the first node for this type. Only used for better conflict reporting.\n  // (see Caveats section in the header comments)\n  if (operation === `add`) {\n    if (!typeInfo.first) {\n      typeInfo.first = nodeId\n    }\n  } else if (operation === `del`) {\n    if (typeInfo.first === nodeId || typeInfo.total === 0) {\n      typeInfo.first = undefined\n    }\n  }\n\n  switch (typeName) {\n    case `object`:\n      updateValueDescriptorObject(\n        value as object,\n        typeInfo as ITypeInfoObject,\n        nodeId,\n        operation,\n        metadata,\n        path\n      )\n      return\n    case `array`:\n      updateValueDescriptorArray(\n        value as Array<unknown>,\n        key,\n        typeInfo as ITypeInfoArray,\n        nodeId,\n        operation,\n        metadata,\n        path\n      )\n      return\n    case `relatedNode`:\n      updateValueDescriptorRelNodes(\n        [value as string],\n        delta,\n        operation,\n        typeInfo as ITypeInfoRelatedNodes,\n        metadata\n      )\n      return\n    case `relatedNodeList`:\n      updateValueDescriptorRelNodes(\n        value as string[],\n        delta,\n        operation,\n        typeInfo as ITypeInfoRelatedNodes,\n        metadata\n      )\n      return\n    case `string`:\n      updateValueDescriptorString(\n        value as string,\n        delta,\n        typeInfo as ITypeInfoString\n      )\n      return\n  }\n\n  // int, float, boolean, null\n\n  typeInfo.example =\n    typeof typeInfo.example !== `undefined` ? typeInfo.example : value\n}\n\nconst mergeObjectKeys = (\n  dpropsKeysA: object = {},\n  dpropsKeysB: object = {}\n): string[] => {\n  const dprops = Object.keys(dpropsKeysA)\n  const otherProps = Object.keys(dpropsKeysB)\n  return [...new Set(dprops.concat(otherProps))]\n}\n\nconst descriptorsAreEqual = (\n  descriptor?: IValueDescriptor,\n  otherDescriptor?: IValueDescriptor\n): boolean => {\n  const types = possibleTypes(descriptor)\n  const otherTypes = possibleTypes(otherDescriptor)\n\n  const childDescriptorsAreEqual = (type: string): boolean => {\n    switch (type) {\n      case `array`:\n        return descriptorsAreEqual(\n          descriptor?.array?.item,\n          otherDescriptor?.array?.item\n        )\n      case `object`: {\n        const dpropsKeys = mergeObjectKeys(\n          descriptor?.object?.dprops,\n          otherDescriptor?.object?.dprops\n        )\n        return dpropsKeys.every(prop =>\n          descriptorsAreEqual(\n            descriptor?.object?.dprops[prop],\n            otherDescriptor?.object?.dprops[prop]\n          )\n        )\n      }\n      case `relatedNode`: {\n        const nodeIds = mergeObjectKeys(\n          descriptor?.relatedNode?.nodes,\n          otherDescriptor?.relatedNode?.nodes\n        )\n        // Must be present in both descriptors or absent in both\n        // in order to be considered equal\n        return nodeIds.every(\n          id =>\n            Boolean(descriptor?.relatedNode?.nodes[id]) ===\n            Boolean(otherDescriptor?.relatedNode?.nodes[id])\n        )\n      }\n      case `relatedNodeList`: {\n        const nodeIds = mergeObjectKeys(\n          descriptor?.relatedNodeList?.nodes,\n          otherDescriptor?.relatedNodeList?.nodes\n        )\n        return nodeIds.every(\n          id =>\n            Boolean(descriptor?.relatedNodeList?.nodes[id]) ===\n            Boolean(otherDescriptor?.relatedNodeList?.nodes[id])\n        )\n      }\n      default:\n        return true\n    }\n  }\n\n  // Equal when all possible types are equal (including conflicts)\n  return isEqual(types, otherTypes) && types.every(childDescriptorsAreEqual)\n}\n\nconst nodeFields = (node: Node, ignoredFields = new Set()): string[] =>\n  Object.keys(node).filter(key => !ignoredFields.has(key))\n\nconst updateTypeMetadata = (\n  metadata = initialMetadata(),\n  operation: Operation,\n  node: Node\n): ITypeMetadata => {\n  if (metadata.disabled) {\n    return metadata\n  }\n  metadata.total = (metadata.total || 0) + (operation === `add` ? 1 : -1)\n  if (metadata.ignored) {\n    return metadata\n  }\n  const { ignoredFields, fieldMap = {} } = metadata\n\n  nodeFields(node, ignoredFields).forEach(field => {\n    let descriptor = fieldMap[field]\n    if (descriptor === undefined) {\n      descriptor = {}\n      fieldMap[field] = descriptor\n    }\n\n    updateValueDescriptor(\n      node.id,\n      field,\n      node[field],\n      operation,\n      descriptor,\n      metadata,\n      []\n    )\n  })\n  metadata.fieldMap = fieldMap\n  return metadata\n}\n\nconst ignore = (metadata = initialMetadata(), set = true): ITypeMetadata => {\n  metadata.ignored = set\n  metadata.fieldMap = {}\n  return metadata\n}\n\nconst disable = (metadata = initialMetadata(), set = true): ITypeMetadata => {\n  metadata.disabled = set\n  return metadata\n}\n\nconst addNode = (metadata: ITypeMetadata, node: Node): ITypeMetadata =>\n  updateTypeMetadata(metadata, `add`, node)\n\nconst deleteNode = (metadata: ITypeMetadata, node: Node): ITypeMetadata =>\n  updateTypeMetadata(metadata, `del`, node)\nconst addNodes = (metadata = initialMetadata(), nodes: Node[]): ITypeMetadata =>\n  nodes.reduce(addNode, metadata)\n\nconst possibleTypes = (descriptor: IValueDescriptor = {}): ValueType[] =>\n  Object.keys(descriptor).filter(\n    type => descriptor[type].total > 0\n  ) as ValueType[]\n\nconst isEmpty = ({ fieldMap }): boolean =>\n  Object.keys(fieldMap).every(\n    field => possibleTypes(fieldMap[field]).length === 0\n  )\n\n// Even empty type may still have nodes\nconst hasNodes = (typeMetadata: ITypeMetadata): boolean =>\n  (typeMetadata.total ?? 0) > 0\n\nconst haveEqualFields = (\n  { fieldMap = {} } = {},\n  { fieldMap: otherFieldMap = {} } = {}\n): boolean => {\n  const fields = mergeObjectKeys(fieldMap, otherFieldMap)\n  return fields.every(field =>\n    descriptorsAreEqual(fieldMap[field], otherFieldMap[field])\n  )\n}\n\nconst initialMetadata = (state?: object): ITypeMetadata => {\n  return {\n    typeName: undefined,\n    disabled: false,\n    ignored: false,\n    dirty: false,\n    total: 0,\n    ignoredFields: undefined,\n    fieldMap: {},\n    ...state,\n  }\n}\n\nexport {\n  addNode,\n  addNodes,\n  deleteNode,\n  ignore,\n  disable,\n  isEmpty,\n  hasNodes,\n  haveEqualFields,\n  initialMetadata,\n}\n"],"file":"inference-metadata.js"}