{"version":3,"sources":["../../src/query/better-queue-custom-store.ts"],"names":["memoryStoreWithPriorityBuckets","uuid","queueMap","Map","tasks","taskIdToPriority","running","priorityKeys","updatePriorityKeys","Array","from","keys","sort","a","b","addTaskWithPriority","taskId","priority","needToUpdatePriorityKeys","priorityTasks","get","set","push","connect","cb","size","getTask","deleteTask","delete","splice","indexOf","putTask","task","oldTask","oldPriority","oldPriorityTasks","takeFirstN","n","lockId","String","remainingTasks","haveSomeTasks","tasksToRun","tasksWithSamePriority","grabbedTaskIds","forEach","length","takeLastN","reverse","deleteCount","Math","min","getRunningTasks","getLock","releaseLock"],"mappings":"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","sourcesContent":["import { Store } from \"better-queue\"\n\nexport function memoryStoreWithPriorityBuckets<T>(): Store<T> {\n  type RunningTasks = Record<string, T>\n  let uuid = 0\n\n  /**\n   * Task ids grouped by priority\n   */\n  const queueMap = new Map<number, Array<string>>()\n\n  /**\n   * Task id to task lookup\n   */\n  const tasks = new Map<string, T>()\n\n  /**\n   * Task id to priority lookup\n   */\n  const taskIdToPriority = new Map<string, number>()\n\n  /**\n   * Lock to running tasks object\n   */\n  const running: Record<string, RunningTasks> = {}\n\n  let priorityKeys: Array<number> = []\n  const updatePriorityKeys = (): void => {\n    priorityKeys = Array.from(queueMap.keys()).sort((a, b) => b - a)\n  }\n\n  const addTaskWithPriority = (taskId: string, priority: number): boolean => {\n    let needToUpdatePriorityKeys = false\n    let priorityTasks = queueMap.get(priority)\n    if (!priorityTasks) {\n      priorityTasks = []\n      queueMap.set(priority, priorityTasks)\n      needToUpdatePriorityKeys = true\n    }\n\n    taskIdToPriority.set(taskId, priority)\n    priorityTasks.push(taskId)\n    return needToUpdatePriorityKeys\n  }\n\n  return {\n    connect: function (cb): void {\n      cb(null, tasks.size)\n    },\n    getTask: function (taskId, cb): void {\n      // @ts-ignore\n      cb(null, tasks.get(taskId))\n    },\n    deleteTask: function (taskId, cb): void {\n      if (tasks.get(taskId)) {\n        tasks.delete(taskId)\n        const priority = taskIdToPriority.get(taskId)\n        if (priority) {\n          const priorityTasks = queueMap.get(priority) ?? []\n          priorityTasks.splice(priorityTasks.indexOf(taskId), 1)\n          taskIdToPriority.delete(taskId)\n        }\n      }\n      cb()\n    },\n    putTask: function (taskId, task, priority = 0, cb): void {\n      const oldTask = tasks.get(taskId)\n      tasks.set(taskId, task)\n      let needToUpdatePriorityKeys = false\n      if (oldTask) {\n        const oldPriority = taskIdToPriority.get(taskId)\n\n        if (oldPriority && oldPriority !== priority) {\n          const oldPriorityTasks = queueMap.get(oldPriority) ?? []\n          oldPriorityTasks.splice(oldPriorityTasks.indexOf(taskId), 1)\n\n          if (\n            addTaskWithPriority(taskId, priority) // ||\n            // oldPriorityTasks.length === 0\n          ) {\n            needToUpdatePriorityKeys = true\n          }\n        }\n      } else {\n        needToUpdatePriorityKeys = addTaskWithPriority(taskId, priority)\n      }\n\n      if (needToUpdatePriorityKeys) {\n        updatePriorityKeys()\n      }\n      cb(null)\n    },\n    takeFirstN: function (n, cb): void {\n      const lockId = String(uuid++)\n      let remainingTasks = n\n      let needToUpdatePriorityKeys = false\n      let haveSomeTasks = false\n      const tasksToRun: RunningTasks = {}\n\n      for (const priority of priorityKeys) {\n        const tasksWithSamePriority = queueMap.get(priority)\n        const grabbedTaskIds =\n          tasksWithSamePriority?.splice(0, remainingTasks) ?? []\n        grabbedTaskIds.forEach(taskId => {\n          // add task to task that will run\n          // and remove it from waiting list\n          const task = tasks.get(taskId)\n          if (task) {\n            tasksToRun[taskId] = task\n            tasks.delete(taskId)\n            taskIdToPriority.delete(taskId)\n            haveSomeTasks = true\n          }\n        })\n\n        remainingTasks -= grabbedTaskIds.length\n        if (tasksWithSamePriority?.length === 0) {\n          queueMap.delete(priority)\n          needToUpdatePriorityKeys = true\n        }\n        if (remainingTasks <= 0) {\n          break\n        }\n      }\n\n      if (needToUpdatePriorityKeys) {\n        updatePriorityKeys()\n      }\n\n      if (haveSomeTasks) {\n        running[lockId] = tasksToRun\n      }\n\n      cb(null, lockId)\n    },\n    takeLastN: function (n, cb): void {\n      // This is not really used by Gatsby, but will be implemented for\n      // completion in easiest possible way (so not very performant).\n      // Mostly done so generic test suite used by other stores passes.\n      // This is mostly C&P from takeFirstN, with array reversal and different\n      // splice args\n      const lockId = String(uuid++)\n      let remainingTasks = n\n      let needToUpdatePriorityKeys = false\n      let haveSomeTasks = false\n      const tasksToRun = {}\n\n      for (const priority of priorityKeys.reverse()) {\n        const tasksWithSamePriority = queueMap.get(priority) ?? []\n        const deleteCount = Math.min(\n          remainingTasks,\n          tasksWithSamePriority.length\n        )\n        const grabbedTaskIds = tasksWithSamePriority.splice(\n          tasksWithSamePriority.length - deleteCount,\n          deleteCount\n        )\n        grabbedTaskIds.forEach(taskId => {\n          // add task to task that will run\n          // and remove it from waiting list\n          tasksToRun[taskId] = tasks.get(taskId)\n          tasks.delete(taskId)\n          taskIdToPriority.delete(taskId)\n          haveSomeTasks = true\n        })\n\n        remainingTasks -= grabbedTaskIds.length\n        if (tasksWithSamePriority.length === 0) {\n          queueMap.delete(priority)\n          needToUpdatePriorityKeys = true\n        }\n        if (remainingTasks <= 0) {\n          break\n        }\n      }\n\n      if (needToUpdatePriorityKeys) {\n        updatePriorityKeys()\n      }\n\n      if (haveSomeTasks) {\n        running[lockId] = tasksToRun\n      }\n\n      cb(null, lockId)\n    },\n    // @ts-ignore\n    // getRunningTasks is an extension to the interface, and is only used in the tests\n    getRunningTasks: function (\n      cb: (err?: any, value?: Record<string, RunningTasks>) => void\n    ): void {\n      cb(null, running)\n    },\n    getLock: function (lockId, cb): void {\n      cb(null, running[lockId])\n    },\n    releaseLock: function (lockId, cb): void {\n      delete running[lockId]\n      cb(null)\n    },\n  }\n}\n"],"file":"better-queue-custom-store.js"}