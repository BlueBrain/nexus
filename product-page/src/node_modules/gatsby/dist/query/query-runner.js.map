{"version":3,"sources":["../../src/query/query-runner.ts"],"names":["resultHashes","Map","queryRunner","graphqlRunner","queryJob","parentSpan","program","store","getState","graphql","query","context","queryName","promise","isPending","timeoutId","setTimeout","messageParts","componentPath","isPage","path","push","_","isEmpty","JSON","stringify","report","warn","join","finally","clearTimeout","result","id","errors","urlPath","undefined","queryContext","plugin","pluginCreatorId","structuredErrors","map","e","structuredError","message","filePath","location","codeFrame","locations","line","column","filter","Boolean","panicOnBuild","Object","assign","pageContext","internalComponentName","component","componentChunkName","updatedAt","pluginCreator___NODE","isCreatedByStatefulCreatePages","resultJSON","resultHash","crypto","createHash","update","digest","get","directory","set","resultPath","replace","fs","outputFile","dispatch","type","payload","hash","boundActionCreators","pageQueryRun","process","env","GATSBY_EXPERIMENTAL_PAGE_BUILD_ON_DATA_CHANGES","setPageData"],"mappings":"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","sourcesContent":["import { Span } from \"opentracing\"\nimport _ from \"lodash\"\nimport fs from \"fs-extra\"\nimport report from \"gatsby-cli/lib/reporter\"\nimport crypto from \"crypto\"\nimport { ExecutionResult } from \"graphql\"\n\nimport path from \"path\"\nimport { store } from \"../redux\"\nimport { boundActionCreators } from \"../redux/actions\"\nimport { getCodeFrame } from \"./graphql-errors\"\nimport errorParser from \"./error-parser\"\n\nimport { GraphQLRunner } from \"./graphql-runner\"\nimport { IExecutionResult, PageContext } from \"./types\"\nimport { pageDataExists } from \"../utils/page-data\"\n\nconst resultHashes = new Map()\n\ninterface IQueryJob {\n  id: string\n  hash?: string\n  query: string\n  componentPath: string\n  context: PageContext\n  isPage: boolean\n  pluginCreatorId: string\n}\n\n// Run query\nexport const queryRunner = async (\n  graphqlRunner: GraphQLRunner,\n  queryJob: IQueryJob,\n  parentSpan: Span | undefined\n): Promise<IExecutionResult> => {\n  const { program } = store.getState()\n\n  const graphql = (\n    query: string,\n    context: Record<string, unknown>,\n    queryName: string\n  ): Promise<ExecutionResult> => {\n    // Check if query takes too long, print out warning\n    const promise = graphqlRunner.query(query, context, {\n      parentSpan,\n      queryName,\n    })\n    let isPending = true\n\n    const timeoutId = setTimeout(() => {\n      if (isPending) {\n        const messageParts = [\n          `Query takes too long:`,\n          `File path: ${queryJob.componentPath}`,\n        ]\n\n        if (queryJob.isPage) {\n          const { path, context } = queryJob.context\n          messageParts.push(`URL path: ${path}`)\n\n          if (!_.isEmpty(context)) {\n            messageParts.push(`Context: ${JSON.stringify(context, null, 4)}`)\n          }\n        }\n\n        report.warn(messageParts.join(`\\n`))\n      }\n    }, 15000)\n\n    promise.finally(() => {\n      isPending = false\n      clearTimeout(timeoutId)\n    })\n\n    return promise\n  }\n\n  // Run query\n  let result: IExecutionResult\n  // Nothing to do if the query doesn't exist.\n  if (!queryJob.query || queryJob.query === ``) {\n    result = {}\n  } else {\n    result = await graphql(queryJob.query, queryJob.context, queryJob.id)\n  }\n\n  // If there's a graphql error then log the error. If we're building, also\n  // quit.\n  if (result && result.errors) {\n    let urlPath = undefined\n    let queryContext = {}\n    const plugin = queryJob.pluginCreatorId || `none`\n\n    if (queryJob.isPage) {\n      urlPath = queryJob.context.path\n      queryContext = queryJob.context.context\n    }\n\n    const structuredErrors = result.errors\n      .map(e => {\n        const structuredError = errorParser({\n          message: e.message,\n          filePath: undefined,\n          location: undefined,\n        })\n\n        structuredError.context = {\n          ...structuredError.context,\n          codeFrame: getCodeFrame(\n            queryJob.query,\n            e.locations && e.locations[0].line,\n            e.locations && e.locations[0].column\n          ),\n          filePath: queryJob.componentPath,\n          ...(urlPath ? { urlPath } : {}),\n          ...queryContext,\n          plugin,\n        }\n\n        return structuredError\n      })\n      .filter(Boolean)\n\n    report.panicOnBuild(structuredErrors)\n  }\n\n  // Add the page context onto the results.\n  if (queryJob && queryJob.isPage) {\n    result[`pageContext`] = Object.assign({}, queryJob.context)\n  }\n\n  // Delete internal data from pageContext\n  if (result.pageContext) {\n    delete result.pageContext.path\n    delete result.pageContext.internalComponentName\n    delete result.pageContext.component\n    delete result.pageContext.componentChunkName\n    delete result.pageContext.updatedAt\n    delete result.pageContext.pluginCreator___NODE\n    delete result.pageContext.pluginCreatorId\n    delete result.pageContext.componentPath\n    delete result.pageContext.context\n    delete result.pageContext.isCreatedByStatefulCreatePages\n  }\n\n  const resultJSON = JSON.stringify(result)\n  const resultHash = crypto\n    .createHash(`sha1`)\n    .update(resultJSON)\n    .digest(`base64`)\n\n  if (\n    resultHash !== resultHashes.get(queryJob.id) ||\n    (queryJob.isPage &&\n      !pageDataExists(path.join(program.directory, `public`), queryJob.id))\n  ) {\n    resultHashes.set(queryJob.id, resultHash)\n\n    if (queryJob.isPage) {\n      // We need to save this temporarily in cache because\n      // this might be incomplete at the moment\n      const resultPath = path.join(\n        program.directory,\n        `.cache`,\n        `json`,\n        `${queryJob.id.replace(/\\//g, `_`)}.json`\n      )\n      await fs.outputFile(resultPath, resultJSON)\n      store.dispatch({\n        type: `ADD_PENDING_PAGE_DATA_WRITE`,\n        payload: {\n          path: queryJob.id,\n        },\n      })\n    } else {\n      // The babel plugin is hard-coded to load static queries from\n      // public/static/d/\n      const resultPath = path.join(\n        program.directory,\n        `public`,\n        `static`,\n        `d`,\n        `${queryJob.hash}.json`\n      )\n      await fs.outputFile(resultPath, resultJSON)\n    }\n  }\n\n  boundActionCreators.pageQueryRun({\n    path: queryJob.id,\n    componentPath: queryJob.componentPath,\n    isPage: queryJob.isPage,\n  })\n\n  // Sets pageData to the store, here for easier access to the resultHash\n  if (\n    process.env.GATSBY_EXPERIMENTAL_PAGE_BUILD_ON_DATA_CHANGES &&\n    queryJob.isPage\n  ) {\n    boundActionCreators.setPageData({\n      id: queryJob.id,\n      resultHash,\n    })\n  }\n  return result\n}\n"],"file":"query-runner.js"}